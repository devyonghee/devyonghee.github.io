<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://devyonghee.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://devyonghee.github.io/" rel="alternate" type="text/html" /><updated>2023-10-07T12:47:45+00:00</updated><id>https://devyonghee.github.io/feed.xml</id><title type="html">devyonghee blog</title><entry><title type="html">[SQL AntiPattern] 4부 애플리케이션 개발 안티패턴</title><link href="https://devyonghee.github.io/book/2023/09/28/sql-anti-pattern-part4/" rel="alternate" type="text/html" title="[SQL AntiPattern] 4부 애플리케이션 개발 안티패턴" /><published>2023-09-28T00:00:00+00:00</published><updated>2023-09-28T00:00:00+00:00</updated><id>https://devyonghee.github.io/book/2023/09/28/sql-anti-pattern-part4</id><content type="html" xml:base="https://devyonghee.github.io/book/2023/09/28/sql-anti-pattern-part4/">&lt;p&gt;SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다.&lt;br /&gt;
4부에서는 애플리케이션에서 SQL 을 다루는 방법에 대해 알아본다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;20장-읽을-수-있는-패스워드-패스워드를-복구하거나-재설정하기&quot;&gt;20장 읽을 수 있는 패스워드: 패스워드를 복구하거나 재설정하기&lt;/h2&gt;

&lt;p&gt;대부분 사용자가 패스워드를 잊어버린 경우, 
이메일 피드백을 통해 패스워드를 복구하거나 재설정하는 기능을 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-패스워드를-평문으로-저장하기&quot;&gt;안티패턴: 패스워드를 평문으로 저장하기&lt;/h3&gt;

&lt;p&gt;패스워드를 평문으로 담은 이메일로 제공해준다면, 
심각한 보안 결함이 되고 접근 권한을 제공해줄 수 있기 때문에 위험하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;패스워드 저장&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;패스워드를 평문으로 저장하거나 평문 상태로 전달하면 안전하지 않음&lt;/li&gt;
      &lt;li&gt;해커가 네트워크 패킷을 가로채 SQL 문 확인 가능&lt;/li&gt;
      &lt;li&gt;데이터베이스 서버에서 접근 권한을 제공해줄 수 있음&lt;/li&gt;
      &lt;li&gt;백업 데이터를 읽을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패스워드 인증&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;패스워드가 평문으로 저장되어 있으면 평문으로 비교 수행&lt;/li&gt;
      &lt;li&gt;공격자에게 패스워드가 노출될 위험이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이메일로 패스워드 보내기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이메일은 해커가 가로채거나, 로깅, 저장할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션이 다른 서드파티 서비스에 접근해야 하는 경우&lt;/li&gt;
  &lt;li&gt;인트라넷 애플리케이션인 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-패스워드의-소금-친-해시-값을-저장한다&quot;&gt;해법: 패스워드의 소금 친 해시 값을 저장한다&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;해시 함수 이해하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;일방향 해시 함수로 패스워드 부호화(encode)
        &lt;ul&gt;
          &lt;li&gt;ex) SHA-256 알고리즘을 사용하면 문자열 길이가 항상 같음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;역을 구하기 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SQL 에서 해시 사용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHA2()&lt;/code&gt; 함수를 사용해 해시 값을 생성&lt;/li&gt;
      &lt;li&gt;해시 함수가 리턴할 수 없는 값(16진수가 아닌 값)으로 변경하면 계정을 잠글 수 있음
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noaccess&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;해시에 소금 추가하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;소금(salt): 일방향 함수의 입력값에 덧붙이는 랜덤비트&lt;/li&gt;
      &lt;li&gt;해시 값을 구하기 전에 패스워드에 덧붙이는 무의미한 바이트열임 (8바이트면 충분)&lt;/li&gt;
      &lt;li&gt;데이터베이스에서 해커가 해시 값과 비교하여 찾을 수 없도록 임의아 값을 추가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SQL 에서 패스워드 숨기기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;네트워크 패킷 또는 SQL 로그 파일을 가로챈다면 패스워드가 노출될 수 있음&lt;/li&gt;
      &lt;li&gt;애플리케이션 코드에서 해시 값을 계산해 SQL 에서 활용&lt;/li&gt;
      &lt;li&gt;브라우저와 웹 애플리케이션 서버에서는 HTTPS 같은 보안 프로토콜 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패스워드 복구가 아닌 패스워드 재설정 사용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해시 값이 저장되어 있으므로 복구 불가능&lt;/li&gt;
      &lt;li&gt;이메일로 패스워드 대신 임시 패스워드를 보냄
        &lt;ul&gt;
          &lt;li&gt;짧은 시간이 지나면 만료시킬 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;아이디에 유일한 토큰을 할당하여 이메일로 보내 패스워드 재설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;안전한 암호학 기술
    &lt;ul&gt;
      &lt;li&gt;PBKDF2: 키 강화 표준&lt;/li&gt;
      &lt;li&gt;Bcrypt: 적응성 해시 함수 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21장-sql-인젝션-동적-sql-쿼리-작성하기&quot;&gt;21장 SQL 인젝션: 동적 SQL 쿼리 작성하기&lt;/h2&gt;

&lt;p&gt;쿼리 문자열과 애플리케이션 변수를 섞어 SQL 문자열로 만드는 것을 동적 SQL(dynamic SQL) 이라고 한다.&lt;br /&gt;
안전하게 동적 SQL 을 만드는 방법에 대해 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-검증되지-않은-입력을-코드로-실행하기&quot;&gt;안티패턴: 검증되지 않은 입력을 코드로 실행하기&lt;/h3&gt;

&lt;p&gt;SQL 인젝션: 어떤 내용을 SQL 쿼리 문자열에 삽입하여 쿼리의 동작을 의도와 다르게 수정하는 것&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;사고는 발생할 것이다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이름에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'&lt;/code&gt; 이 포함되면 의도하지 않은 형태로 바뀔 수 있음&lt;/li&gt;
      &lt;li&gt;의도하지 않은 동작이 실행될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최고의 웹 보안 위협&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;SQL 문이 파싱되기 전에 동적인 부분을 삽입하면 SQL 인젝션 위험이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;치료를 위한 탐구&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;값을 이스케이프하기
        &lt;ul&gt;
          &lt;li&gt;따옴표 문자를 두 개 또는 역슬래시를 추가하여 문자 리터럴로 변경&lt;/li&gt;
          &lt;li&gt;문자열 삽입하기 전에 애플리케이션 데이터를 변환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;쿼리 파라미터
        &lt;ul&gt;
          &lt;li&gt;동적 값 삽입 대신 쿼리를 만들 때 파라미터 자리를 미리 정의하여 실행할 때 값 제공&lt;/li&gt;
          &lt;li&gt;이스케이프할 필요도 없고 이스케이프 함수의 결함을 고려하지 않아도 됨&lt;/li&gt;
          &lt;li&gt;보편적인 해결 방법은 될 수 없음
            &lt;ul&gt;
              &lt;li&gt;값의 목록을 하나의 파라미터로 전달 불가능&lt;/li&gt;
              &lt;li&gt;테이블 이름은 파라미터로 전달 불가능&lt;/li&gt;
              &lt;li&gt;컬럼 이름을 파라미터로 전달 불가능&lt;/li&gt;
              &lt;li&gt;SQL 키뤄드를 파라미터로 전달 불가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;저장 프로시저
        &lt;ul&gt;
          &lt;li&gt;보통 고정된 SQL 을 포함하며, 프로시저 정의할 때 파싱&lt;/li&gt;
          &lt;li&gt;애플리케이션 코드에서 동적 SQL 사용하는 것처럼 위험함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터 접근 프레임워크
        &lt;ul&gt;
          &lt;li&gt;어떤 프레임워크든 안전한 SQL 코드만 작성하도록 강제 불가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-1&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;있을 수 없음&lt;/li&gt;
  &lt;li&gt;코드를 방어적으로 작성해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-아무도-믿지-마라&quot;&gt;해법: 아무도 믿지 마라&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;입력 값 필터링&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력에 대해 유효하지 않은 문자 모두 제거
        &lt;ul&gt;
          &lt;li&gt;정수가 필요하다면, 정수에 맞는 내용만 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파라미터를 통한 값 전달&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쿼리의 동적 부분이 단순한 값이라면 SQL 표현과 파라미터 분리 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동적 값 인용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쿼리 파라미터 사용으로 옵티마이저의 인덱스 사용이 잘못될 수 있음&lt;/li&gt;
      &lt;li&gt;특별한 경우 SQL 문제 해당 값을 직접 삽입하는 것이 나을 수 있음
        &lt;ul&gt;
          &lt;li&gt;성숙된 문자열 인용 함수를 사용하여 방어적으로 작성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사용자의 입력을 코드와 격리하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;요청 파라미터로 미리 값을 정의하여 SQL 쿼리에 사용
        &lt;ul&gt;
          &lt;li&gt;ex) 정렬 목록 또는 방향의 리스트를 정의 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;up&lt;/code&gt; =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASC&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;down&lt;/code&gt; =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DESC&lt;/code&gt;)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사용자의 입력을 SQL 쿼리와 직접 엮지 않아 안전&lt;/li&gt;
      &lt;li&gt;SQL의 어느 부분이든 동적으로 생성 가능&lt;/li&gt;
      &lt;li&gt;사용자의 입력이 유효한지 검증 가능&lt;/li&gt;
      &lt;li&gt;쿼리의 내용을 사용자 인터페이스에서 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;코드 검토를 함께할 동료 구하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;SQL 인젝션 위험에 익숙한 동료에게 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22장-가상키-편집증-데이터-정돈하기&quot;&gt;22장 가상키 편집증: 데이터 정돈하기&lt;/h2&gt;

&lt;p&gt;수열 중간에 숫자가 몇 개 빠지면 불편한 것은 데이터베이스 기술에 대한 이해나 확인이 부족한 것이 보통이다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-모든-틈-메우기&quot;&gt;안티패턴: 모든 틈 메우기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시퀀스에서 벗어난 번호 할당하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;새로운 행에 키 값을 할당할 때 사용되지 않은 첫번째 값을 사용하고 싶을 수 있음
        &lt;ul&gt;
          &lt;li&gt;동시성 문제 발생될 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;비효율적이며 에러가 발생될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기존 행의 번호를 다시 매기기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기존 행에 대한 키 값을 업데이트해 틈을 메우고 연속적으로 만들 수 있음
        &lt;ul&gt;
          &lt;li&gt;사용되지 않은 키 값을 찾아야 함&lt;/li&gt;
          &lt;li&gt;PK 값을 재할당하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 문 실행 필요&lt;/li&gt;
          &lt;li&gt;동시성 문제 발생될 수 있음&lt;/li&gt;
          &lt;li&gt;외래키가 있다면 제약조건을 비활성화하고 자식 행까지 업데이트 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;업데이트해도 디폴트 가상키 생성기를 사용하면 틈이 메워지지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 불일치 만들기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;PK 를 재사용하는 것을 위험함&lt;/li&gt;
      &lt;li&gt;가상키에 빈 값이 있다고 재할당하면 안됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-2&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;가상키 값을 바꿔야할 이유는 없음&lt;/li&gt;
  &lt;li&gt;PK 칼럼의 값이 의미를 가진다면 자연키임&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-극복하라&quot;&gt;해법: 극복하라&lt;/h3&gt;

&lt;p&gt;행을 식별하는 데 연속적인 숫자일 필요는 없음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;행에 번호 매기기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;행 번호는 PK 와 대응되는 것이 아님&lt;/li&gt;
      &lt;li&gt;페이지 처리하는데 유용&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROW_NUMBER()&lt;/code&gt; 윈도 함수를 사용하면 쿼리 결과 집합에 대한 연속된 번호 확인 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GUID 사용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;GUID(Global Unique Identifier): 128비트 의사난수로 32자리 16진수&lt;/li&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;중복 걱정없이 동시에 가상키 생성 가능&lt;/li&gt;
          &lt;li&gt;틈에 대한 불평이 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;키 값이 길어짐&lt;/li&gt;
          &lt;li&gt;값이 랜덤하여 패턴 추론이 어렵고, 큰 값이 최근 행을 나타내지 않음&lt;/li&gt;
          &lt;li&gt;공간도 많이 차지하고 속도도 느림&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;가장 중요한 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터베이스를 정리를 해결하기 위해서는 커뮤티케이션도 중요
        &lt;ul&gt;
          &lt;li&gt;기술 설명&lt;/li&gt;
          &lt;li&gt;비용을 명확하게 함&lt;/li&gt;
          &lt;li&gt;자연키 사용하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;23장-나쁜-것-안-보기-코드를-적게-작성하기&quot;&gt;23장 나쁜 것 안 보기: 코드를 적게 작성하기&lt;/h2&gt;

&lt;p&gt;간결한 코드를 작성해야 하는 이유&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;작동하는 애플리케이션 코딩을 빨리 끝낼 수 있음&lt;/li&gt;
  &lt;li&gt;테스트화, 문서화, 동료 검토할 코드 양 감소&lt;/li&gt;
  &lt;li&gt;코드양이 적으면 버그도 적음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;안티패턴-짚-없이-벽돌-만들기&quot;&gt;안티패턴: 짚 없이 벽돌 만들기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;진단 없는 진료&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;함수로부터 리턴된 상태값 체크 필요
        &lt;ul&gt;
          &lt;li&gt;ex) db 커넥션, 잘못된 쿼리 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;읽기간 행&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;SQL 쿼리를 문자열로 생성하는 애플리케이션 코드를 보는 것은 매우 어려움&lt;/li&gt;
      &lt;li&gt;디버깅할 때, SQL 자체를 보고 판단하는 것이 빠름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-3&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;에러에 대해 할 것이 없다면 에러 검사 생략 가능&lt;/li&gt;
  &lt;li&gt;예외를 던져 호출 스택의 위로 전달될 수 있도록 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-에러에서-우아하게-복구하기&quot;&gt;해법: 에러에서 우아하게 복구하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;리듬 유지하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;API 호출 후 리턴 상태나 예외 확인&lt;/li&gt;
      &lt;li&gt;에러가 발생할 수 있는 모든 호출에 대해 상태 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스텝 되짚기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;API 메서드의 인수에서 SQL 쿼리를 만들지 말고 변수를 사용해서 만들기
        &lt;ul&gt;
          &lt;li&gt;변수 값 확인할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SQL 을 따로 출력하도록 함
        &lt;ul&gt;
          &lt;li&gt;ORM 프레임워크를 사용하면 디버깅이 복잡해질 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SQL 쿼리를 HTML 주석으로 출력하면 안됨
        &lt;ul&gt;
          &lt;li&gt;해커가 데이터베이스 구조를 파악할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;24장-외교적-면책특권-관례-따르기&quot;&gt;24장 외교적 면책특권: 관례 따르기&lt;/h2&gt;

&lt;p&gt;좋은 소프트웨어 공학적 습관&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Subversion 이나 Git 같은 버전 관리 도구로 코드 관리&lt;/li&gt;
  &lt;li&gt;자동화된 단위 테스트나 기능 테스트 개발하고 실행&lt;/li&gt;
  &lt;li&gt;요구사항과 구현 전략 기록하기 위해 명세서, 문서, 코드 주석 작성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;안티패턴-sql을-2등-시민으로-만들기&quot;&gt;안티패턴: SQL을 2등 시민으로 만들기&lt;/h3&gt;

&lt;p&gt;애플리케이션 코드에서 따르는 개발 관례를 데이터베이스 코드에는 면제된다고 생각한다.&lt;br /&gt;
이 책에서는 이러한 안티패턴을 ‘외교적 면책특권’이라 한다.&lt;br /&gt;
데이터베이스는 애플리케이션의 기초로 품질이 중요하므로 좋은 관례를 따라야 한다.&lt;/p&gt;

&lt;h4 id=&quot;사용이-합당한-경우-4&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;한 번 이상 사용할 모든 코드에 대해 문서화, 테스트, 소드 관리를 해야 함&lt;/li&gt;
  &lt;li&gt;임시적인 코드
    &lt;ul&gt;
      &lt;li&gt;사용 후에 바로 지우기&lt;/li&gt;
      &lt;li&gt;최소한 코드의 목적이나 사용방법 정도의 간단한 기록 남기기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-초당적-품질-문화-확립&quot;&gt;해법: 초당적 품질 문화 확립&lt;/h3&gt;

&lt;p&gt;소프트웨어 공학의 전체 생명주기 수행&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로젝트 요구사항을 문서로 명확하게 명세&lt;/li&gt;
  &lt;li&gt;요구사항에 대한 솔루션을 설계하고 개발&lt;/li&gt;
  &lt;li&gt;솔루션이 요구사항에 맞는지 검토하고 테스트&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;증거1: 문서화&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ERD(Entity-Relationship Diagram)
        &lt;ul&gt;
          &lt;li&gt;테이블과 테이블 사이의 관계를 나타내는 ERD&lt;/li&gt;
          &lt;li&gt;데이터베이스가 복잡하고 많으면 여러 개의 다이어그램으로 분해&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;테이블, 칼럼, 뷰
        &lt;ul&gt;
          &lt;li&gt;색인 테이블, 교차 테이블, 종속 테이블 같은 테이블 정보&lt;/li&gt;
          &lt;li&gt;컬럼의 값의 의미&lt;/li&gt;
          &lt;li&gt;뷰를 생성해야 하는 이유, 어디에 사용되는지, 업데이트가 가능 여부&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;관계
        &lt;ul&gt;
          &lt;li&gt;참조 정합성 제약조건의 의도 설명 필요&lt;/li&gt;
          &lt;li&gt;암묵적 관계인 경우 관계가 있는지조차 파악이 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;트리거
        &lt;ul&gt;
          &lt;li&gt;구현된 비즈니스 규칙 정보
            &lt;ul&gt;
              &lt;li&gt;ex) 데이터 검증, 데이터 변환, 데이터베이스 변경 로깅 등&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;저장 프로시저
        &lt;ul&gt;
          &lt;li&gt;해결하고자 하는 문제&lt;/li&gt;
          &lt;li&gt;데이터 변경 여부&lt;/li&gt;
          &lt;li&gt;입력과 출력 데이터 타입&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SQL 보안
        &lt;ul&gt;
          &lt;li&gt;애플리케이션에서 사용하기 위해 정의한 계정 정보&lt;/li&gt;
          &lt;li&gt;각 계정이 가지고 있는 접근 권한, 역할&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터베이스 기반 구조
        &lt;ul&gt;
          &lt;li&gt;사용하는 DBMS 제품 이름 및 버전&lt;/li&gt;
          &lt;li&gt;데이터베이스 서버 호스트 네임&lt;/li&gt;
          &lt;li&gt;데이터베이스 서버 개수&lt;/li&gt;
          &lt;li&gt;리클리케이션, 클러스터, 프록시 사용 여부&lt;/li&gt;
          &lt;li&gt;커넥션 옵션, 네트워크, 포트, 백업 정책&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;객체-관계 매핑
        &lt;ul&gt;
          &lt;li&gt;구현된 비즈니스 규칙 정보&lt;/li&gt;
          &lt;li&gt;데이터 유효성 검증, 데이터 변환, 로깅, 캐싱, 프로파일링 기술 방식&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;증거의 흔적: 소스 코드 제어&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터 정의 스크립트
        &lt;ul&gt;
          &lt;li&gt;데이터베이스 객체를 정의하는 SQL 문을 포함한 스크림트 실행 방법 제공&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;트리거와 프로시저
        &lt;ul&gt;
          &lt;li&gt;프로젝트 코드의 일부로 생각하고 관리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부트스트랩 데이터
        &lt;ul&gt;
          &lt;li&gt;색인 테이블에 초기 상태가 필요할 수 있으므로 데이터 보관&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ERD와 문서
        &lt;ul&gt;
          &lt;li&gt;데이터베이스 요구사항, 구현, 애플리케이션과의 통합 기술&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DBA 스크립트
        &lt;ul&gt;
          &lt;li&gt;애플리케이션 밖에서 실행되는 데이터 처리 작업 코드도 애플리케이션 코드와 같이 관리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;입증 책임: 테스트&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;테이블, 컬럼, 뷰
        &lt;ul&gt;
          &lt;li&gt;테이블과 뷰가 실제 존재 여부 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;제약조건
        &lt;ul&gt;
          &lt;li&gt;제약조건 때문에 에러가 발생할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt; 문 실행 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;트리거
        &lt;ul&gt;
          &lt;li&gt;강제 실행하여 시나리오 테스트&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;저장 프로시저
        &lt;ul&gt;
          &lt;li&gt;단위 테스트와 비슷하게 테스트 실행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부트스트랩 데이터
        &lt;ul&gt;
          &lt;li&gt;쿼리를 통해 초기 데이터가 존재하는지 검증&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;쿼리
        &lt;ul&gt;
          &lt;li&gt;테스트 환경에서 쿼리 실행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ORM 클래스
        &lt;ul&gt;
          &lt;li&gt;애플리케이션과 비슷하게 테스트 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;담당 건수: 여러 브랜치에서 작업하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이상적으로 애플리케이션 리비전마다 별도의 데이터베이스 인스턴스 생성하는 것이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;25장-마법의-콩-mvc에서-모델-단순화하기&quot;&gt;25장 마법의 콩: MVC에서 모델 단순화하기&lt;/h2&gt;

&lt;p&gt;개발 기간을 줄일 수 있다면, 소프트웨어를 개발하는 비용도 줄어든다.&lt;br /&gt;
MVC 아키텍처를 사용하면 애플리케이션의 관심사를 분리할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컨트롤러
    &lt;ul&gt;
      &lt;li&gt;사용자 입력 받기, 응답할 작업 정의, 모델로 작업 위임, 결과를 뷰&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델
    &lt;ul&gt;
      &lt;li&gt;애플리케이션의 중심&lt;/li&gt;
      &lt;li&gt;입력 값 검증, 비즈니스 로직, 데이터베이스와 상호작용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;뷰
    &lt;ul&gt;
      &lt;li&gt;사용자 인터페이스에 정보 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;안티패턴-액티브-레코드인-모델&quot;&gt;안티패턴: 액티브 레코드인 모델&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;액티브 레코드: 모델 객체의 필드를 데이터베이스에 있는 테이블 하나의 컬럼과 매핑하는 디자인 패턴&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MVC 애플리케이션에서 모든 모델 클래스가 액티브 레코드 클래스를 상속하는 것은 좋지 않음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;액티브 레코드는 모델을 스키마와 결합시킨다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;액티브 레코드 클래스는 데이터베이스의 테이블 하나 또는 뷰를 표현&lt;/li&gt;
      &lt;li&gt;새로운 구조의 데이터를 표현하기 위해서는 모델 클래스, 애플리케이션 코드도 함께 수정 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;액티브 레코드는 CRUD 함수를 노출시킨다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;의도치 않은 용도로 액티브 레코드 클래스의 CRUD 함수를 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;액티브 레코드는 빈약한 도메인 모델을 조장한다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;빈약한 도메인 모델(anemic domain model)
        &lt;ul&gt;
          &lt;li&gt;모델을 단순한 데이터 접근 객체로 취급하여 비즈니스 로직이 모델 외부에 존재, 동작 응집도 낮아짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;마법의 콩은 단위 테스트가 어렵다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모델 테스트
        &lt;ul&gt;
          &lt;li&gt;데이터 접근과 분리해 모델의 동작 테스트가 어려움&lt;/li&gt;
          &lt;li&gt;데이터베이스 픽스처를 사용하면 데이터베이스가 필요해지고, 준비 작업고 정리 작접이 느려짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;뷰 테스트
        &lt;ul&gt;
          &lt;li&gt;렌더링한 후 HTML 을 파싱해 특정 요소를 찾는 코드 실행 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;컨트롤러 테스트
        &lt;ul&gt;
          &lt;li&gt;가짜 HTTP 요청 생성 필요&lt;/li&gt;
          &lt;li&gt;HTTP 응답을 골라내야 함&lt;/li&gt;
          &lt;li&gt;비즈니스 로직을 테스트하는 데 많은 설정 코드가 필요해지고, 테스트 실행이 느려짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-5&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;액티브 레코드 디자인 패턴은 문제는 없음&lt;/li&gt;
  &lt;li&gt;모델을 DAO 와 동일하게 정의하여 단순화 가능&lt;/li&gt;
  &lt;li&gt;프로토타입(prototype) 만드는 경우
    &lt;ul&gt;
      &lt;li&gt;코드를 빨리 작성하는 것이 유지보수 하는 것보다 중요한 경우&lt;/li&gt;
      &lt;li&gt;기술적 부채를 탕감하기 위한 리팩토링 시간 확보 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-액티브-레코드를-가지는-모델&quot;&gt;해법: 액티브 레코드를 가지는 모델&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;모델 이해하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;정보 전문가
        &lt;ul&gt;
          &lt;li&gt;어떤 동작에 책임이 있는 객체는 동작을 수행하는 데 필요한 모든 데이터를 가지고 있어야 함&lt;/li&gt;
          &lt;li&gt;모델과 액티브 레코드와 같은 DAO 사이의 관계는 HAS-A(집합연관) 여야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;창조자
        &lt;ul&gt;
          &lt;li&gt;모델이 데이터를 데이터베이스에 저장하는 방법은 내부 구현 상세여야 함&lt;/li&gt;
          &lt;li&gt;컨트롤러와 뷰는 데이터베이스 상호작용하는 방법을 알 필요 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;낮은 결합도
        &lt;ul&gt;
          &lt;li&gt;논리적으로 독립적인 코드 블록 분리&lt;/li&gt;
          &lt;li&gt;클래스의 구현을 변경할 수 있는 유연성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;높은 응집도
        &lt;ul&gt;
          &lt;li&gt;도메인 모델 클래스의 인터페이스는 의도된 사용법을 반영해야 함&lt;/li&gt;
          &lt;li&gt;데이터베이스의 물리적 구조나 CRUD 동작을 반영하면 안됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;도메인 모델 동작하게 하기
        &lt;ul&gt;
          &lt;li&gt;모델은 애플리케이션을 위한 비즈니스 로직 구현하는 곳
            &lt;ul&gt;
              &lt;li&gt;애플리케이션에서 도메인의 객체지향적 표현&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;간단한 객체 테스트하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모델을 DAO 에서 분리하면 DAO 의 스텁(stub) 과 목(mock)을 생성해 단위 테스트 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;땅으로 내려오기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;객체지향 설계 원칙을 공부하면 생산적으로 데이터 접근 객체 사용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;부록-정규화-규칙&quot;&gt;부록: 정규화 규칙&lt;/h2&gt;

&lt;h3 id=&quot;관계형의-뜻&quot;&gt;관계형의 뜻&lt;/h3&gt;

&lt;p&gt;관계형(relational) 이라는 용어는 테이블 사이의 관계를 뜻하는 게 아니라,&lt;br /&gt;
테이블 자체 또는 테이블과 컬럼 사이의 관계를 뜻한다.&lt;/p&gt;

&lt;p&gt;테이블 정규화를 하기 전에 적절한 관계인지 몇 가지 조건을 만족하는지 확인해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;행은 위아래 순서를 가지지 않는다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;순서를 고려하지 않는다면 행의 집합은 동일해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컬럼은 좌우 순서를 가지지 않는다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컬럼에 대한 위치 의미를 두면 안됨 (19장 암묵적 컬럼과 연관)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중복 행은 허용되지 않는다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;다른 행과 구분할 수 있어야 하고 개별 행에 접근할 수 있어야 함 (PK 제약 조건)&lt;/li&gt;
      &lt;li&gt;모든 컬럼은 하나의 타입과 값만을 가져야 함 안티 패턴
        &lt;ul&gt;
          &lt;li&gt;안티 패턴 ex) EAV 테이블&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;행은 숨은 컴포넌트를 갖지 않는다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컬럼은 데이터 값을 포함하며, 행 ID나 객체 ID 같은 스토리지 지시자를 갖지 않음
        &lt;ul&gt;
          &lt;li&gt;안티 패턴 ex) 가상키 편집증&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정규화에-대한-미신&quot;&gt;정규화에 대한 미신&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;정규화는 데이터베이스를 느리게 만듦
    &lt;ul&gt;
      &lt;li&gt;쿼리에 대해 엄청 큰 비용이 발생될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정규화에서는 데이터를 자식 테이블로 분리하고 참조
    &lt;ul&gt;
      &lt;li&gt;편의, 성능, 효율성을 위해 사용할 수 있지만 정규화와 관련된 내용은 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정규화는 EAV 설계에서와 같이 속성을 최대한 분리하는 것
    &lt;ul&gt;
      &lt;li&gt;위와 다르게 정규화는 읽기 편하고 쿼리하기 편하게 만들어 줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제 3정규형 이상으로 정규화할 필요는 없음
    &lt;ul&gt;
      &lt;li&gt;제 4정규형부터 위배되면 잠재적으로 데이터 손실을 초래할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정규화란&quot;&gt;정규화란?&lt;/h3&gt;

&lt;p&gt;정규화의 목표&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이해할 수 있는 방법으로 실셰계 표현&lt;/li&gt;
  &lt;li&gt;중복 저장, 데이터 이상 또는 모순 생기는 것을 방지&lt;/li&gt;
  &lt;li&gt;정합성 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정규화의-단계&quot;&gt;정규화의 단계&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/normalization-step.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/normalization-step.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/normalization-step.png&quot; class=&quot;zooming&quot; alt=&quot;normalization step&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        normalization step
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;제1 정규형
    &lt;ul&gt;
      &lt;li&gt;테이블이 관계여야 함&lt;/li&gt;
      &lt;li&gt;테이블이 반복 그룹을 가지지 않아야 함
        &lt;ul&gt;
          &lt;li&gt;한 행이 여러 개의 값을 가지지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;안티패턴
        &lt;ul&gt;
          &lt;li&gt;무단횡단: 여러 값이 들어가는 경우&lt;/li&gt;
          &lt;li&gt;다중 칼럼 속성: 같은 도메인의 여러 값이 여러 컬럼에 걸치는 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제2 정규형
    &lt;ul&gt;
      &lt;li&gt;특정 컬럼이 복합 PK 의 일부에 의해 결정되지 않아야 함
        &lt;ul&gt;
          &lt;li&gt;완전 함수 종속 만족&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제3 정규형
    &lt;ul&gt;
      &lt;li&gt;복합 PK 일부와 관계 없이 일부 컬럼이 특정 컬럼에 결정되지 않아야 함
        &lt;ul&gt;
          &lt;li&gt;이행적 종속 제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보이스-코드 정규형(BCNF, Boyce-Codd Normal Form)
    &lt;ul&gt;
      &lt;li&gt;제3 정규형보다 조금 강력한 버전&lt;/li&gt;
      &lt;li&gt;키 칼럼을 포함한 모든 속성은 키에 종속이어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제4 정규형
    &lt;ul&gt;
      &lt;li&gt;다치 종속 제거
        &lt;ul&gt;
          &lt;li&gt;관계 없는 독립적인 값들이 같은 컬럼에 종속되는 경우 다치 종속&lt;/li&gt;
          &lt;li&gt;ex) 여러 개의 다대다 관계를 하나의 교차 테이블로 나타내려할 때 위반&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제5 정규형
    &lt;ul&gt;
      &lt;li&gt;보이스-코드 정규형의 조건 만족&lt;/li&gt;
      &lt;li&gt;조인 종속 제거
        &lt;ul&gt;
          &lt;li&gt;조인 종속: 분해했다가 다시 조인했을 때 분해하기 전과 동일한 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도메인-키 정규형(DKNF, Domain-Key Normal Form)
    &lt;ul&gt;
      &lt;li&gt;테이블의 모든 제약조건은 테이블 도메인 제약조건과 키 제약조건의 논리적 결과&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제6 정규형
    &lt;ul&gt;
      &lt;li&gt;모든 조인 종속성 제거 추구&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관련 코드는 &lt;a href=&quot;https://github.com/devyonghee/sql-anti-pattern-study&quot;&gt;깃허브&lt;/a&gt; 참고&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SQL AntiPatterns&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="book" /><category term="book" /><category term="sql anti pattern" /><category term="database" /><category term="sql" /><summary type="html">SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다. 4부에서는 애플리케이션에서 SQL 을 다루는 방법에 대해 알아본다.</summary></entry><entry><title type="html">[SQL AntiPattern] 3부 쿼리 안티패턴</title><link href="https://devyonghee.github.io/book/2023/09/19/sql-anti-pattern-part3/" rel="alternate" type="text/html" title="[SQL AntiPattern] 3부 쿼리 안티패턴" /><published>2023-09-19T00:00:00+00:00</published><updated>2023-09-19T00:00:00+00:00</updated><id>https://devyonghee.github.io/book/2023/09/19/sql-anti-pattern-part3</id><content type="html" xml:base="https://devyonghee.github.io/book/2023/09/19/sql-anti-pattern-part3/">&lt;p&gt;SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다.&lt;br /&gt;
3부에서는 DML(Data Manipulation Language)에 대해 다룬다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;14장-모르는-것에-대한-두려움-누락된-값-구분하기&quot;&gt;14장 모르는 것에 대한 두려움: 누락된 값 구분하기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 을 포함하는 컬럼에 대해 쿼리를 작성해야 한다.&lt;br /&gt;
아래는 쿼리에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 값을 생산적으로 사용하는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;행을 생성할 때 값을 알수 없는 곳에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 사용&lt;/li&gt;
  &lt;li&gt;적용 가능한 값이 없는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 사용&lt;/li&gt;
  &lt;li&gt;유효하지 않은 값이 입력되는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 사용&lt;/li&gt;
  &lt;li&gt;외부 조인에서 매치되지 않는 행의 컬럼 값을 채우는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;안티패턴-null-을-일반-값처럼-사용&quot;&gt;안티패턴: NULL 을 일반 값처럼 사용&lt;/h3&gt;

&lt;p&gt;SQL 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;, 빈문자열과 다른 특별한 값으로 취급한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 값은 특별한 규칙을 따른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;수식에서 NULL 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 에 숫자를 더해도 알지 못하는 값이기 때문에 결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT NULL + 1 -&amp;gt; NULL&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT&lt;/code&gt; 같은 불리언 수식 결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NULL 을 가질 수 있는 컬럼 검색&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;여집합(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT&lt;/code&gt;)으로 검색해도 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 인 행은 검색되지 않음&lt;/li&gt;
      &lt;li&gt;동등 조건으로 검색해도 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 인 행은 검색되지 않음
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE column = NULL&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE column &amp;lt;&amp;gt; NULL&lt;/code&gt; 조건은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 인 행을 반환하지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쿼리 파라미터로 NULL 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 을 일반적인 값처럼 사용하기 어려워 파라미터로 사용 불가
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE column = ?&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;문제 회피하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 을 금지하기 위해 다른 값(ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;''&lt;/code&gt;…)으로 대체하면 문제가 될 수 있음
        &lt;ul&gt;
          &lt;li&gt;해당되는 값이 어떤 컬럼에서는 중요한 값이 될 수 있음&lt;/li&gt;
          &lt;li&gt;FK 설정이 어려워짐 (없는 값에 대한 행추가가 필요)&lt;/li&gt;
          &lt;li&gt;해당 값에 대한 의미를 기억하거나 문서화 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;누락된 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 로 표현하는 것이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;외부 데이터를 불러오거나(import) 내보내기(export) 하는 경우&lt;/li&gt;
  &lt;li&gt;누락된 값에 대해 특별한 구분이 있는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-유일한-값으로-null을-사용하라&quot;&gt;해법: 유일한 값으로 NULL을 사용하라&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스칼라 수식에서의 NULL&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;다음 모든 수식의 결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL + 1&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL = 1&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL &amp;lt;&amp;gt; 1&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL || 'string'&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL = NULL&lt;/code&gt; (모르는 값과 모르는 값은 같은지 알 수 없음)&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL &amp;lt;&amp;gt; NULL&lt;/code&gt; (모르는 값과 모르는 값은 다른지 알 수 없음)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불리언 수식에서의 NULL&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL AND TRUE&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL AND FALSE&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FALSE&lt;/code&gt; (어떤 값이든 FALSE와 AND 연산하면 FALSE)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL OR TRUE&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TRUE&lt;/code&gt; (어떤 값이든 TRUE와 OR 연산하면 TRUE)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL OR FALSE&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NULL 검색하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 을 검색하기 위해서는 다른 연산 필요
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS NULL&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS NOT NULL&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS DISTINCT FROM&lt;/code&gt; 을 사용하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS NULL&lt;/code&gt; 확인 조건이 포함됨
            &lt;ul&gt;
              &lt;li&gt;MySQL 에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS DISTINCT FROM&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 지원&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;칼럼을 NOT NULL 로 선언하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 값이 정책 위반 또는 의미가 없는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt; 선언 권장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동적 디폴트&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COALESCE&lt;/code&gt; 을 통해 특정 쿼리에서만 디폴트 값 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;15장-애매한-그룹-그룹당-최댓값을-가진-행-얻기&quot;&gt;15장 애매한 그룹: 그룹당 최댓값을 가진 행 얻기&lt;/h2&gt;

&lt;p&gt;그룹의 최댓값(또는 최솟값, 평균 값)과 함께 해당되는 다른 속성도 포함되는 쿼리를 작성하고자 한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 를 활용하면 값을 쉽게 구할 수 있지만 다른 속성의 값은 해당되는 행에 대한 값이 아닐 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-그룹되지-않은-컬럼-참조&quot;&gt;안티패턴: 그룹되지 않은 컬럼 참조&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;단일 값 규칙(Single-Value Rule)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 목록의 모든 컬럼은 그룹당 하나의 값을 가져야 함&lt;/li&gt;
      &lt;li&gt;하나의 값을 가지지 못한 경우 단일 값 규칙 위반이 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;내 뜻대로 동작하는 쿼리&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;다른 컬럼에서도 최대값에 대한 행을 가져온다면 다음과 같은 경우 추론 불가능
        &lt;ul&gt;
          &lt;li&gt;최댓값을 구하는 컬럼의 값이 같은 행이 여러 개인 경우&lt;/li&gt;
          &lt;li&gt;집계함수가 여러 개인 경우 (ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX(date_reported), MIN(date_reported)&lt;/code&gt;)&lt;/li&gt;
          &lt;li&gt;매칭되는 행이 존재하지 않는 경우 (ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM(hours) AS total, bug_id&lt;/code&gt;)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-1&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;함수 종속(functional dependency) 인 경우
    &lt;ul&gt;
      &lt;li&gt;ex) 외래키 그룹과 참조된 테이블의 속성을 가져오는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-컬럼을-모호하게-사용하지-않기&quot;&gt;해법: 컬럼을 모호하게 사용하지 않기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;함수 종속인 컬럼만 쿼리하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모호한 컬럼을 쿼리에서 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상호 연관된 서브쿼리 사용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;더이상 큰(작은) 값이 없는 데이터을 서브 쿼리로 검색&lt;/li&gt;
      &lt;li&gt;성능상 최적의 방법은 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유도 테이블(derived table) 사용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;유도 테이블 = 인라인 뷰: 테이블이 들어갈 자리에 서브쿼리 사용&lt;/li&gt;
      &lt;li&gt;서브쿼리 사용하는 방법보다 확장적응성(scalability)이 좋음&lt;/li&gt;
      &lt;li&gt;임시 테이블에 중간 결과를 저장하므로 성능상 최적의 방법은 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;조인 사용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;대응되는 행이 없을 수도 있는 행의 집합에 대해 외부 조인 사용&lt;/li&gt;
      &lt;li&gt;개념이 어렵고 유지보수가 어려움&lt;/li&gt;
      &lt;li&gt;확장적응성(scalability)이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다른 컬럼에 집계 함수 사용하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;집계 함수를 사용하여 단일 값 규칙을 따르도록 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;각 그룹에 대해 모든 값 연결하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP_CONCAT&lt;/code&gt; 함수를 사용하여 모든 값을 연결하여 조회&lt;/li&gt;
      &lt;li&gt;대응되는 값은 보여주지 않음&lt;/li&gt;
      &lt;li&gt;표준 SQL 은 아님&lt;/li&gt;
      &lt;li&gt;단일 값 규칙이 위반되는 경우 사용될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;16장-임의의-선택-샘플-행-가져오기&quot;&gt;16장 임의의 선택: 샘플 행 가져오기&lt;/h2&gt;

&lt;p&gt;대량의 집합에서 샘플 데이터를 요청하는 일은 흔하다.&lt;br /&gt;
임의의 샘플 데이터만 리턴할 수 있는 SQL 쿼리를 작성하고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-데이터를-임의로-정렬하기&quot;&gt;안티패턴: 데이터를 임의로 정렬하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;임의의 행을 고르기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RAND()&lt;/code&gt; 로 정렬하여 데이터를 임의로 선택
    &lt;ul&gt;
      &lt;li&gt;일반적인 정렬에 비해 인덱스를 사용할 수 없음&lt;/li&gt;
      &lt;li&gt;데이터가 많은 경우 매우 많은 비용이 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-2&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 집합이 적은 경우&lt;/li&gt;
  &lt;li&gt;데이터가 늘어날 일이 거의 없는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-테이블-전체-정렬-피하기&quot;&gt;해법: 테이블 전체 정렬 피하기&lt;/h3&gt;

&lt;p&gt;임의 정렬은 매우 많은 비용이 발생되므로 대안이 필요함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;1과 MAX 사이에서 임의의 키 값 고르기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;PK 값이 1부터 연속적으로 존재한다고 가정하여 사이의 난수 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다음으로 큰 키 값 고르기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;빈틈이 있는 경우를 위해 찾아내는 키 값의 이상인 행을 찾음
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE id &amp;gt;= {random_number}&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;빈틈 바로 앞에 있는 키 값이 자주 선택될 수 있는 단점&lt;/li&gt;
      &lt;li&gt;동일한 빈도로 선태되는 것이 중요하지 않으면 유용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모든 키 값의 목록을 구한 다음, 임의로 하나 고르기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;애플리케이션 코드에서 모든 키만을 조회하여 임의로 하나를 선택&lt;/li&gt;
      &lt;li&gt;또 다른 비용이 발생
        &lt;ul&gt;
          &lt;li&gt;모든 키를 조회하기 때문에 메모리 자원을 넘어설 수 있음&lt;/li&gt;
          &lt;li&gt;쿼리가 두 번 발생됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오프셋을 이용해 임의로 고르기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;행의 개수를 세고 임의의 수를 고르고 오프셋&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIMIT&lt;/code&gt; 절에 의존&lt;/li&gt;
      &lt;li&gt;키 값이 연속적이지 않아도 됨&lt;/li&gt;
      &lt;li&gt;각 행이 선택될 확률을 같아야 하는 경우 유용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;벤더 종속적인 방법&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Oracle: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAMPLE&lt;/code&gt; 절&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;17장-가난한-자의-검색-엔진-전체-텍스트-검색&quot;&gt;17장 가난한 자의 검색 엔진: 전체 텍스트 검색&lt;/h2&gt;

&lt;p&gt;텍스트 검색의 기능이 필요한데 성능과 확장 적응성이 필요하다.&lt;br /&gt;
하지만 SQL 에서 부분문자열(substring)을 비교하는 것은 비효율적이거나 부정확하다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-패턴-매칭-사용&quot;&gt;안티패턴: 패턴 매칭 사용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REGEXP&lt;/code&gt; 연산자 사용
    &lt;ul&gt;
      &lt;li&gt;많은 테이블 스캔 비용 발생&lt;/li&gt;
      &lt;li&gt;일반적인 인덱스 사용 불가&lt;/li&gt;
      &lt;li&gt;단순한 패턴 매칭을 원하지 않는 경우가 있음
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE '%one%'&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;money&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prone&lt;/code&gt; 포함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-3&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;간단한 경우의 패턴인 경우&lt;/li&gt;
  &lt;li&gt;아주 가끔씩만 실행되는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-작업에-맞는-올바른-도구-찾기&quot;&gt;해법: 작업에 맞는 올바른 도구 찾기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전체 텍스트 검색(full-text search)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;MySQL: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FULLTEXT&lt;/code&gt; 인덱스
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHAR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VARCHAR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TEXT&lt;/code&gt; 타입의 컬럼에 정의 가능&lt;/li&gt;
          &lt;li&gt;전체 텍스트 인덱스의 컬럼 지정 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Oracle
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CONTEXT&lt;/code&gt;: 하나의 텍스트 컬럼에 대해 정의, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CONTRAINS()&lt;/code&gt; 연산자 사용&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTXCAT&lt;/code&gt;: 짧은 텍스트 샘플과 다른 컬럼 함께 사용, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CATSEARCH()&lt;/code&gt; 연산자 사용&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTXXPATH&lt;/code&gt;: XML 문서 검색, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;existsNode()&lt;/code&gt; 연산자 사용&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTXRULE&lt;/code&gt;: 문서 분석하여 분류하는 규칙 설계&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PostgreSQL
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TSVECTOR&lt;/code&gt; 타입: 텍스트 검색을 위한 인덱스&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;직접 만들기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;전치 인덱스(inverted index)를 만들어서 검색
        &lt;ul&gt;
          &lt;li&gt;검색할 모든 단어의 목록을 저장하여 연관 시킴 (다대다 관계)&lt;/li&gt;
          &lt;li&gt;키워드에 대한 검색을 쉽게 하기 위해 저장 프로시저 작성
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REGEXP&lt;/code&gt; 연산자를 사용하여 검색하여 매칭 여부 결정&lt;/li&gt;
              &lt;li&gt;검색된 적이 있다면 키워드를 포함한 데이터를 매핑 테이블에 저장&lt;/li&gt;
              &lt;li&gt;검색된 적이 없다면 검색이 오래 걸릴 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;18장-스파게티-쿼리-sql-쿼리-줄이기&quot;&gt;18장 스파게티 쿼리: SQL 쿼리 줄이기&lt;/h2&gt;

&lt;p&gt;SQL 프로그래머들은 흔하게 복잡한 문제를 하나의 쿼리로 해결하려고 한다.&lt;br /&gt;
복잡한 문제를 단순화하는 방법을 찾아본다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-복잡한-문제를-한-번에-풀기&quot;&gt;안티패턴: 복잡한 문제를 한 번에 풀기&lt;/h3&gt;

&lt;p&gt;모든 작업을 한 줄의 코드로 해치워야 한다는 접근 방법은 좋지 않다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;의도하지 않은 제품&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;흔하게 카테시안 곱(Cartesian product)이 발생
        &lt;ul&gt;
          &lt;li&gt;쿼리에 사용된 두 테이블의 관계 제한 조건이 없는 경우 발생&lt;/li&gt;
          &lt;li&gt;훨씬 많은 행이 반환되어 성능 저하&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;그래도 충분하지 않다면&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;작성, 수정, 디버깅이 어려움&lt;/li&gt;
      &lt;li&gt;개선하는 데 많은 비용과 시간이 발생&lt;/li&gt;
      &lt;li&gt;복잡한 SQL 쿼리는 엔진이 최적화하여 실행하기 어려움
        &lt;ul&gt;
          &lt;li&gt;여러 개의 단순한 쿼리 사용이 좋음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;h4 id=&quot;사용이-합당한-경우-4&quot;&gt;사용이 합당한 경우&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;프레임워크나 비주얼 컴포넌트 라이버리를 사용하는 경우&lt;/li&gt;
      &lt;li&gt;모든 결과에 대해 정렬된 순서로 봐야하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-분할해서-정복하기&quot;&gt;해법: 분할해서 정복하기&lt;/h3&gt;

&lt;p&gt;동일한 결과 집합을 만드는 여러 쿼리 중에 단순한 쿼리를 선택해야 한다.&lt;br /&gt;
하지만 너무 많은 SQL 쿼리나 명령문 실행은 가장 효율적인 방법은 아닐 수 있으므로 균형을 잘 유지해야 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;한 번에 하나씩&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쿼리를 여러 개로 분할
        &lt;ul&gt;
          &lt;li&gt;원치 않은 카테시안 곱 방지&lt;/li&gt;
          &lt;li&gt;간단한 쿼리 추가가 쉬워짐&lt;/li&gt;
          &lt;li&gt;SQL 엔진은 단순한 쿼리를 최적화&lt;/li&gt;
          &lt;li&gt;쿼리 설명이 쉬워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UNION 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 쿼리의 겨과를 하나의 집합으로 묶을 수 있음&lt;/li&gt;
      &lt;li&gt;결과를 구분할 수 있는 컬럼 추가 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상사의 문제 해결하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;원하는 값들을 분리해서 쿼리를 작성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SQL 을 이용한 SQL 자동 생성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 쿼리로 나누면 데이터 값에 따라 변하는 비슷한 쿼리가 나올 수 있음&lt;/li&gt;
      &lt;li&gt;코드 생성을 통해 출력하는 코드를 작성하면 반복 잡업 제거 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;19장-암묵적-컬럼-타이핑-줄이기&quot;&gt;19장 암묵적 컬럼: 타이핑 줄이기&lt;/h2&gt;

&lt;p&gt;와일드카드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;)는 암묵적으로 컬럼을 조회하하는데 사용한다.&lt;br /&gt;
쿼리를 간결하게 하는 데 도움이 되지만 위험이 따른다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-지름길-좋아하면-길을-잃은다&quot;&gt;안티패턴: 지름길 좋아하면 길을 잃은다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;리팩터링 방해&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT&lt;/code&gt; 에 엉뚱한 값이 할당될 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 에서 컬럼 순서가 바뀌면 결과가 달라질 수 있음
        &lt;ul&gt;
          &lt;li&gt;오류 추적이 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;숨겨진 비용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;성능과 확장적응성(scalability) 저하
        &lt;ul&gt;
          &lt;li&gt;보다 더 많은 데이터가 전달될 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;요청한 것을 얻은 것이다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 컬럼을 요청하거나 칼럼의 목록을 명시적으로 나열해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-5&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;테스트를 위한 데이터 확인 용도의 임시 쿼리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-명시적으로-컬럼-이름-지정하기&quot;&gt;해법: 명시적으로 컬럼 이름 지정하기&lt;/h3&gt;

&lt;p&gt;항상 필요한 컬럼을 나열 해야 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;오류 검증&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;테이블 컬럼 위치가 바뀌어도 결과가 바뀌지 않음&lt;/li&gt;
      &lt;li&gt;컬럼이 추가되어도 결과에 나타나지 않음&lt;/li&gt;
      &lt;li&gt;컬럼이 삭제되면, 쿼리에서 에러 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;그거 필요하지 않을 꺼야&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;자연히 불필요한 컬럼을 쓰지 않게 됨&lt;/li&gt;
      &lt;li&gt;대역폭을 보다 효율적으로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어쨌든 와일드카드를 포기해야 돼&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;와일드카드를 사용하면 컬럼 하나씩 다루기 어려움&lt;/li&gt;
      &lt;li&gt;처음부터 와일드카드를 사용하지 않으면 쿼리 변경이 쉬워짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관련 코드는 &lt;a href=&quot;https://github.com/devyonghee/sql-anti-pattern-study&quot;&gt;깃허브&lt;/a&gt; 참고&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SQL AntiPatterns&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="book" /><category term="book" /><category term="sql anti pattern" /><category term="database" /><category term="sql" /><summary type="html">SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다. 3부에서는 DML(Data Manipulation Language)에 대해 다룬다.</summary></entry><entry><title type="html">[SQL AntiPattern] 2부 물리적 데이터베이스 설계 안티패턴</title><link href="https://devyonghee.github.io/book/2023/09/15/sql-anti-pattern-part2/" rel="alternate" type="text/html" title="[SQL AntiPattern] 2부 물리적 데이터베이스 설계 안티패턴" /><published>2023-09-15T00:00:00+00:00</published><updated>2023-09-15T00:00:00+00:00</updated><id>https://devyonghee.github.io/book/2023/09/15/sql-anti-pattern-part2</id><content type="html" xml:base="https://devyonghee.github.io/book/2023/09/15/sql-anti-pattern-part2/">&lt;p&gt;SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다.&lt;br /&gt;
2부에서는 데이터를 효율적으로 관리하는 방법에 대해 알아본다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;10장-반올림-오류-정수-대신-소수-사용&quot;&gt;10장 반올림 오류: 정수 대신 소수 사용&lt;/h2&gt;

&lt;p&gt;정수가 아닌 수를 저장하고 수를 저장해야 하는데,  &lt;br /&gt;
산술 연산도 수행하고 그 결과가 정확하도록 관리하고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-float-데이터-타입-사용&quot;&gt;안티패턴: FLOAT 데이터 타입 사용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;소수 데이터가 필요한 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLOAT&lt;/code&gt; 데이터 타입을 사용
    &lt;ul&gt;
      &lt;li&gt;IEEE 754 표준에 따라 실수를 이진 형식으로 부호화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;필요에 의한 반올림&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;십진수로 표현된 모든 수를 이진수로 표현할 수 없음&lt;/li&gt;
      &lt;li&gt;부동 소수점에 대해 정확하게 저장되지 않고 오차가 발생될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SQL 에서 FLOAT 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 데이터베이스에서는 부정확한 값을 보정해 스스로 의도한 값으로 표시됨&lt;/li&gt;
      &lt;li&gt;특정 값으로 검색을 해도 조회가 안될 수 있음&lt;/li&gt;
      &lt;li&gt;합계나 곱을 하는 경우 부동 소수점 수의 누적으로 더 큰 오차가 발생될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INTEGER&lt;/code&gt; 나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NUMERIC&lt;/code&gt; 타입이 지원하는 것보다 큰 범위의 실수 값을 사용하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-numeric-또는-decimal-데이터-타입-사용&quot;&gt;해법: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NUMERIC&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DECIMAL&lt;/code&gt; 데이터 타입 사용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NUMERIC&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DECIMAL&lt;/code&gt; 두 타입은 동일하게 동작
    &lt;ul&gt;
      &lt;li&gt;가능하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLOAT&lt;/code&gt; 은 사용하지 말자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컬럼 정의에서 지정한 정도까치 수치를 정확하게 표현&lt;/li&gt;
  &lt;li&gt;스케일 지정 가능&lt;/li&gt;
  &lt;li&gt;유리수가 반올림되지 않고 저장&lt;/li&gt;
  &lt;li&gt;산술 연산을 해도 기대한 값으로 표시됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11장-31가지-맛-칼럼을-특정-값으로-제한하기&quot;&gt;11장 31가지 맛: 칼럼을 특정 값으로 제한하기&lt;/h2&gt;

&lt;p&gt;칼럼의 값을 고정된 집합의 값으로 제한하고자 한다.&lt;br /&gt;
유효하지 않은 값은 데이터베이스에서 거부하는 것이 이상적이다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-칼럼-정의에-값-지정&quot;&gt;안티패턴: 칼럼 정의에 값 지정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;칼럼을 정의할 때 유효한 데이터 값 지정
    &lt;ul&gt;
      &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHECK&lt;/code&gt; 제약조건 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENUM&lt;/code&gt; 타입 사용&lt;/li&gt;
      &lt;li&gt;MySQL 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENUM&lt;/code&gt; 은 값을 문자열로 선언하지만, 내부적으로 서수(ordinal number)로 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중간에 있는 게 뭐지?&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 컬럼에서 허용되는 값의 목록을 얻기 어려움
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQL&lt;/code&gt; 의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INFORMATION_SCHEMA&lt;/code&gt; 시스템 뷰의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COLUMN_TYPE&lt;/code&gt; 에서 파싱하여 추출&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DISTINCT&lt;/code&gt; 를 사용해도 현재 데이터에 있는 값만 반환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;새로운 맛 추가하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENUM&lt;/code&gt; 이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHECK&lt;/code&gt; 제약조건에 값을 추가하려면 컬럼 재정의 필요&lt;/li&gt;
      &lt;li&gt;이전 정의에서 사용 되던 값 조회가 필요할 수 있음&lt;/li&gt;
      &lt;li&gt;ETL(extract, transform, load) 작업이 필요할 수 있음
        &lt;ul&gt;
          &lt;li&gt;해당 작업동안 테이블 접근 불가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예전 맛은 절대 없어지지 않는다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 값을 더 이상 사용되지 않게 만들면, 과거 데이터가 망가질 수 있음
        &lt;ul&gt;
          &lt;li&gt;과거 값을 유지하면, 입력하지 못하도록 설정 불가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;포팅이 어렵다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;체크 제약조건, 도메인, 사용자 정의 타입은 모든 데이터베이스 제품에서 균일하게 지원되지 않는 기능
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENUM&lt;/code&gt; 은 MySQL 고유 기능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-1&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;값의 집합이 변하지 않는 경우
    &lt;ul&gt;
      &lt;li&gt;집합 조회가 필요하다면 애플리케이션의 코드에서 유지하면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상호 배타적인 두 값 중 하나를 나타내는 경우
    &lt;ul&gt;
      &lt;li&gt;ex) LEFT/RIGHT, ACTIVE/INACTIVE, ON/OFF, INTERNAL/EXTERNAL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-데이터로-값을-지정하기&quot;&gt;해법: 데이터로 값을 지정하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;각 값을 행으로 하는 색인 테이블 생성
    &lt;ul&gt;
      &lt;li&gt;해당 테이블을 FK 제약조건으로 선언&lt;/li&gt;
      &lt;li&gt;값 제한 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;값의 집합 쿼리하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;메타데이터로 저장되지 않고 데이터로 저장되기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 문으로 조회 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;색인 테이블의 값 갱신하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT&lt;/code&gt; 문으로 값 추가 가능&lt;/li&gt;
      &lt;li&gt;접근 제한, ETL 작업, 컬럼 재정의 불필요&lt;/li&gt;
      &lt;li&gt;이전 정의했던 값 조회할 필요가 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;더 이상 사용하지 않는 값 지원하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;속성 컬럼을 추가하여 사용되지 않는 값 표시 가능
        &lt;ul&gt;
          &lt;li&gt;ex) ACTIVE/INACTIVE&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;포팅이 쉽다&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;표준 SQL 기능(FK 제약조건을 이용한 참조 정합성)만 사용&lt;/li&gt;
      &lt;li&gt;무한한 개수의 값 저장 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12장-유령-파일-이미지-또는-벌크-미디어-저장&quot;&gt;12장 유령 파일: 이미지 또는 벌크 미디어 저장&lt;/h2&gt;

&lt;p&gt;이미지나 다른 미디어에 대해 데이터베이스 엔티티와 연관을 갖도록 저장하고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-파일을-사용해야-한다고-가정&quot;&gt;안티패턴: 파일을 사용해야 한다고 가정&lt;/h3&gt;

&lt;p&gt;파일을 별도로 저장하고 경로만 저장하는 방식은 위험이 있음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;DELETE 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이미지 경로를 포함하는 행을 삭제할 때 자동으로 삭제 하는 방법이 없음&lt;/li&gt;
      &lt;li&gt;고아 이미지 파일이 누적될 위험&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;트랜잭션이 커밋되지 않아도 변경된 내용이 보여질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ROLLBACK 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;에러가 발생되어도 지워진 이미지 파일이 복구되지 않음 (업로드된 이미지도 삭제되지 않음)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;백업 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터베이스에는 백업 도구를 제공&lt;/li&gt;
      &lt;li&gt;외부 이미지 파일에 대해서도 백업하기 위한 도구 필요
        &lt;ul&gt;
          &lt;li&gt;백업했어도 제대로 동기화 된 상태인지도 파악이 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SQL 접근 권한 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;외부 파일은 SQL 문으로 접근권한 적용 불가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SQL 데이터 타입 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;저장된 경로는 문자열일 뿐이기 때문에 유효한 검증이 어려움&lt;/li&gt;
      &lt;li&gt;경로가 존재하는지 검증이 어려움&lt;/li&gt;
      &lt;li&gt;이동, 삭제에 대해 자동으로 업데이트되지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-2&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;보통 이미지는 크기가 크기 때문에 외부에 저장해야 성능에 영향을 미치지 않음&lt;/li&gt;
  &lt;li&gt;이미지를 제외해야 데이터베이스 백업 속도가 빨라짐&lt;/li&gt;
  &lt;li&gt;외부에 저장된 이미지는 미리보기나 편집이 쉬워짐
    &lt;ul&gt;
      &lt;li&gt;배치 편집이 필요한 경우 유용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-필요한-경우에는-blob-데이터-타입-사용&quot;&gt;해법: 필요한 경우에는 BLOB 데이터 타입 사용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLOB&lt;/code&gt; 칼럼에 저장하면 좋은 이유
    &lt;ul&gt;
      &lt;li&gt;이미지가 데이터베이스에 저장
        &lt;ul&gt;
          &lt;li&gt;이미지를 로드하기 위한 별도의 단계가 필요 없음&lt;/li&gt;
          &lt;li&gt;파일 경로가 잘못될 위험 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;행이 삭제되면 이미지도 자동 삭제&lt;/li&gt;
      &lt;li&gt;커밋하기 전까지 이미지 변경이 적용되지 않음&lt;/li&gt;
      &lt;li&gt;롤백되면 이전 상태로 자동 복원&lt;/li&gt;
      &lt;li&gt;행을 업데이트하면 잠금이 걸리므로 동시 업데이트 방지&lt;/li&gt;
      &lt;li&gt;데이터베이스 백업에 모든 이미지가 자동 포함&lt;/li&gt;
      &lt;li&gt;SQL 을 통해 이미지에 대한 접근 제어 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLOB&lt;/code&gt; 의 최대크기는 데이터베이스 종류마다 다름
    &lt;ul&gt;
      &lt;li&gt;ex) MySQL 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEDIUMBLOB&lt;/code&gt; 은 16MB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기존에 파일로 존재하던 이미지를 데이터베이스 BLOB 컬럼으로 로드 가능
    &lt;ul&gt;
      &lt;li&gt;ex) MySQL 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD_FILE()&lt;/code&gt; 함수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLOB&lt;/code&gt; 컬럼의 내용을 파일로 저장 가능
    &lt;ul&gt;
      &lt;li&gt;ex) MySQL 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT ... INTO DUMPFILE&lt;/code&gt; 문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;13장-인덱스-샷건-성능-최적화&quot;&gt;13장 인덱스 샷건: 성능 최적화&lt;/h2&gt;

&lt;p&gt;데이터베이스 성능을 향상 시키는 좋은 방법은 인덱스를 잘 활용하는 것이다.&lt;br /&gt;
인덱스를 언제, 어떻게 사용해야 하는지 알아보고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-무계획하게-인덱스-사용하기&quot;&gt;안티패턴: 무계획하게 인덱스 사용하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;인덱스를 잘못 사용하는 예
    &lt;ul&gt;
      &lt;li&gt;불충분한 인덱스 또는 정의하지 않음&lt;/li&gt;
      &lt;li&gt;너무 많은 인덱스 또는 도움 되지 않는 인덱스 정의&lt;/li&gt;
      &lt;li&gt;인덱스를 사용하지 않는 쿼리 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;없는 인덱스&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt; 사용할 때마다, 인덱스 데이터 구조 업데이트 필요
        &lt;ul&gt;
          &lt;li&gt;오버헤드가 발생되지만, 상쇄할 정도의 이득이 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt; 문에도 행을 찾을 때 인덱스가 도움이 될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;너무 많은 인덱스&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;PK 에 인덱스를 정의할 필요 없음&lt;/li&gt;
      &lt;li&gt;긴 문자열 타입에 인덱스가 크므로 컬럼 전체 검색이나 정렬할 쿼리가 없다면 필요 없음&lt;/li&gt;
      &lt;li&gt;복합 인덱스에서는 컬럼 순서가 중요함
        &lt;ul&gt;
          &lt;li&gt;검색 조건, 조인 조건, 정렬 순서에 맞춰 왼쪽에서 오른쪽 정렬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;많은 인덱스는 오버헤드만 발생시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인덱스가 도움이 되지 않을 때&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;복합 인덱스를 정의했는데 정렬 순서가 다른 경우&lt;/li&gt;
      &lt;li&gt;인덱스 컬럼이 변형된 경우
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE MONTH(date) = 4&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;조회하는 데이터가 예측 불가능하게 흩어져 있는 경우&lt;/li&gt;
      &lt;li&gt;검색할 문자열이 뒤에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE&lt;/code&gt; 검색하는 경우(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE '%??'&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;검색하는 데이터 타입이 다른 경우&lt;/li&gt;
      &lt;li&gt;NOT-EQUAL 비교된 경우
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT IN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT BETWEEN&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-3&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;경험에 근거해 가능한 최적의 추측하여 인덱스 정의 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-인덱스를-mentor하라&quot;&gt;해법: 인덱스를 MENTOR하라&lt;/h3&gt;

&lt;p&gt;MENTOR(Measure, Explain, Nominate, Test, Optimize, Rebuild) 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Measure(측정)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쿼리가 실행된 시간을 로그로 남겨 많은 비용이 들어간 작업을 식별하여 최적화&lt;/li&gt;
      &lt;li&gt;측정할 때에는 캐싱 기능 비활성화 필요&lt;/li&gt;
      &lt;li&gt;측정이 끝난 다음에는 오버헤드가 발생될 수 있으니 프로파일링 빈도를 줄이거나 비활성화 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Explain(실행 계획 확인)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쿼리 실행 계획 확인 (QEP, Query Execution Plan)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Nominate(지명)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쿼리에서 인덱스를 사용하지 않고 테이블에 접근하는 부분 확인
        &lt;ul&gt;
          &lt;li&gt;ex) MySQL Enterprise Query Analyzer&lt;/li&gt;
          &lt;li&gt;쿼리 실행 계획을 살펴봐도 확인 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test(테스트)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;인덱스 생성 후 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Optimize(최적화)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;시스템 메모리의 일정량을 캐시에 할당&lt;/li&gt;
      &lt;li&gt;인덱스를 캐시 메모리에 미리 로딩
        &lt;ul&gt;
          &lt;li&gt;ex) MySQL 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD INDEX INTO CACHE&lt;/code&gt; 문&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rebuild(재구성)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;주기적으로 인덱스 재정비
        &lt;ul&gt;
          &lt;li&gt;파일 시스템이 단편화되는 것처럼 인덱스도 균형을 잃을 수 있음&lt;/li&gt;
          &lt;li&gt;ex) MySQL 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANAALYZE TABLE&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPTIMIZE TABLE&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관련 코드는 &lt;a href=&quot;https://github.com/devyonghee/sql-anti-pattern-study&quot;&gt;깃허브&lt;/a&gt; 참고&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SQL AntiPatterns&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="book" /><category term="book" /><category term="sql anti pattern" /><category term="database" /><category term="sql" /><summary type="html">SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다. 2부에서는 데이터를 효율적으로 관리하는 방법에 대해 알아본다.</summary></entry><entry><title type="html">[SQL AntiPattern] 1부 논리적 데이터베이스 설계 안티패턴</title><link href="https://devyonghee.github.io/book/2023/09/01/sql-anti-pattern-part1/" rel="alternate" type="text/html" title="[SQL AntiPattern] 1부 논리적 데이터베이스 설계 안티패턴" /><published>2023-09-01T00:00:00+00:00</published><updated>2023-09-01T00:00:00+00:00</updated><id>https://devyonghee.github.io/book/2023/09/01/sql-anti-pattern-part1</id><content type="html" xml:base="https://devyonghee.github.io/book/2023/09/01/sql-anti-pattern-part1/">&lt;p&gt;SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다.&lt;br /&gt;
1부에서는 데이터베이스 테이블과 컬럼, 관계를 계획하는 방법에 대해 알아본다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2장-무단횡단-다중-값-속성-저장&quot;&gt;2장 무단횡단: 다중 값 속성 저장&lt;/h2&gt;

&lt;p&gt;다대다 관계를 위해 교차 테이블 생성을 피하기 위해 쉼표(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt;)로 구분된 목록을 사용한다.&lt;br /&gt;
이러한 안티패턴을 책에서는 ‘무단횡단’ 또는 ‘교차로’ 로 표현했다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-쉼표로-구분된-목록에-저장&quot;&gt;안티패턴: 쉼표로 구분된 목록에 저장&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;product&lt;/code&gt; 테이블의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account_id&lt;/code&gt; 컬럼을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VARCHAR&lt;/code&gt; 로 선언하고 쉼표로 구분해 나열하는 방법
(ex. ‘12,34’)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특정 계정에 대한 상품을 찾기 위해서는 패턴 매칭 필요
    &lt;ul&gt;
      &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REGEXP&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE&lt;/code&gt;…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;계정을 조회하기 위해서는 어려운 조인, 많은 비용 발생
    &lt;ul&gt;
      &lt;li&gt;인덱스 활용 불가&lt;/li&gt;
      &lt;li&gt;두 테이블의 카테시안 곱 생성하여 평가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제품 별 계정 정보를 집계하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COUNT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM&lt;/code&gt; 같은 집계 쿼리 사용 불가
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt; 의 개수를 세는 등 특별한 방법 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제품에 대한 계정 변경이 어려움
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concat&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt; 등의 함수를 사용해야 함 (정렬은 불가능)&lt;/li&gt;
      &lt;li&gt;특정 처리를 위해 많은 코드 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유효하지 않은 계정에 대한 검증이 어려움&lt;/li&gt;
  &lt;li&gt;문자열인 경우 구분자 문자를 포함하는 경우 처리가 모호함&lt;/li&gt;
  &lt;li&gt;목록 길이 제한을 정하는 것이 모호함 (각 항목의 길이가 다르면 들어갈 수 있는 항목의 개수가 달라짐)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;반정규화를 적용하여 성능을 향상하기 위함
    &lt;ul&gt;
      &lt;li&gt;정규화가 우선되어야 하므로 보수적으로 결정 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;목록 안의 개별 값을 분리할 필요가 없는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-교차-테이블-생성&quot;&gt;해법: 교차 테이블 생성&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/contact-mapping-erd.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/contact-mapping-erd.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/contact-mapping-erd.png&quot; class=&quot;zooming&quot; alt=&quot;contact mapping erd&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        contact mapping erd
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account_id&lt;/code&gt; 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;product&lt;/code&gt; 테이블이 아닌 별도의 테이블에 저장&lt;br /&gt;
이렇듯 어떤 테이블이 FK 로 두 테이블을 참조할 때 교차 테이블(조인 테이블, 다대다 테이블, 매핑 테이블) 이라고 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;product&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contact&lt;/code&gt; 테이블을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account&lt;/code&gt; 쉽게 조회 가능&lt;/li&gt;
  &lt;li&gt;제품과 계정에 대한 복잡한 집계 쿼리 가능&lt;/li&gt;
  &lt;li&gt;특정 제품에 대한 계정 변경 쉬움&lt;/li&gt;
  &lt;li&gt;FK 를 사용하여 유효한 계정 검증 가능, 참조 정합성 유지&lt;/li&gt;
  &lt;li&gt;구분자 필요하지 않음, 항목 수 제한 없음&lt;/li&gt;
  &lt;li&gt;인덱스를 활용하여 성능 향상&lt;/li&gt;
  &lt;li&gt;각 항목에 속성 추가 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3장-순진한-트리-계층구조-저장-및-조회&quot;&gt;3장 순진한 트리: 계층구조 저장 및 조회&lt;/h2&gt;

&lt;p&gt;답글을 달 수 있고 답글에 대한 답글을 달 수 있다고 가정&lt;br /&gt;
데이터가 재귀적 관계를 가지고 트리나 계층 구조를 가질 수 있음&lt;br /&gt;
각 항목은 노드라고 부르고 최상위 노드는 뿌리(root) 가장 아래 노드는(leaf)라고 부름&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-항상-부모에-의존&quot;&gt;안티패턴: 항상 부모에 의존&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/adjust-list-comment-table.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/adjust-list-comment-table.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/adjust-list-comment-table.png&quot; class=&quot;zooming&quot; alt=&quot;adjacency list comment table&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        adjacency list comment table
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/adjust-list-comment-erd.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/adjust-list-comment-erd.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/adjust-list-comment-erd.png&quot; class=&quot;zooming&quot; alt=&quot;adjacency list comment erd&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        adjacency list comment erd
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/adjacency-comment-tree-sample.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/adjacency-comment-tree-sample.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/adjacency-comment-tree-sample.png&quot; class=&quot;zooming&quot; alt=&quot;adjacency comment tree sample&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        adjacency comment tree sample
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;이처럼 같은 테이블 안의 다른 글을 참조하는 설계를 인접 목록(adjacency list) 라고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단계가 깊어질 수록 컬럼을 추가하는 방식으로 후손을 포함하게 됨
    &lt;ul&gt;
      &lt;li&gt;계속 본인 테이블의 JOIN 문을 추가해야 함&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COUNT&lt;/code&gt; 같은 집계 수치를 계산하기 어려워짐&lt;/li&gt;
      &lt;li&gt;다른 방법으로 관련 데이터를 모두 조회하여 애플리케이션에서 트리구조를 만들어줄 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;노드를 삭제하기 위해서는 자손을 찾아 가장 아래 단계부터 차례로 삭제 필요
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ON DELETE CASCADE&lt;/code&gt; 로 자동화 가능함&lt;/li&gt;
      &lt;li&gt;트리에서 고아 노드 관리가 필요함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-1&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;계층적 데이터 작업이 많지 않은 경우
    &lt;ul&gt;
      &lt;li&gt;주어진 노드의 부모나 자식을 바로 얻을 수 있음&lt;/li&gt;
      &lt;li&gt;새로운 노드 추가가 쉬움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해결책-대안-트리-모델-사용&quot;&gt;해결책: 대안 트리 모델 사용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;인적 목록 모델 이외에 다른 모델 사용 (처음에는 복잡해보일 수 있음)
    &lt;ul&gt;
      &lt;li&gt;경로 열거(Path Enumeration)&lt;/li&gt;
      &lt;li&gt;중첩 집합(Nested Sets)&lt;/li&gt;
      &lt;li&gt;클로저 테이블(Closure Table)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;경로-열거path-enumeration&quot;&gt;경로 열거(Path Enumeration)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;일련의 조상을 각 노드의 속성으로 저장
    &lt;ul&gt;
      &lt;li&gt;ex) 디렉터리 구조. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/local/lib&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;usr&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;local&lt;/code&gt; 의 부모&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comment&lt;/code&gt; 테이블에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent_id&lt;/code&gt; 컬럼 대신, 긴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VARCHAR&lt;/code&gt; 타입의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; 컬럼 정의&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIKE&lt;/code&gt; 구문을 통해 자손과 후손에 대해 조회 가능&lt;/li&gt;
  &lt;li&gt;다른 노드를 수정하지 않아도 종단이 아닌 중간 노드 삽입 가능
    &lt;ul&gt;
      &lt;li&gt;부모 경로를 복사하고 새 노드의 아이디를 조회하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;breadcrumb&lt;/code&gt;  을 사용자 인터페이스에 보여줄 때 좋음
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;breadcrumb&lt;/code&gt;: 위치를 쉽게 추적, 헨젤과 그레텔의 빵 부스러기에서 유래&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;무단횡단과 비슷한 단점 존재
    &lt;ul&gt;
      &lt;li&gt;데이터 검증 불가&lt;/li&gt;
      &lt;li&gt;문자열 컬럼의 제한으로 트리의 깊이 제한이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;중첩-집합nested-sets&quot;&gt;중첩 집합(Nested Sets)&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/nested-sets-comment-tree-sample.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/nested-sets-comment-tree-sample.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/nested-sets-comment-tree-sample.png&quot; class=&quot;zooming&quot; alt=&quot;nested sets comment tree sample&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        nested sets comment tree sample
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;부모 대신 자손의 집합에 대한 정보 저장
    &lt;ul&gt;
      &lt;li&gt;트리의 각 노드를 두 개의 수로 부호화 가능&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comment_id&lt;/code&gt; 와 상관 없음&lt;/li&gt;
      &lt;li&gt;ex) nsleft 수는 자식 노드의 nsleft 보다 작고, nsright 는 자식의 nsright 보다 큼&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;노드 숫자 사이로 조상 및 자손 조회 가능&lt;/li&gt;
  &lt;li&gt;자식을 가진 노드를 삭제해도 그 자손이 자동으로 삭제된 노드 부모의 자손이 됨
    &lt;ul&gt;
      &lt;li&gt;노드를 삭제하여 숫자 간격이 생겨도 트리구조에 문제가 되지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트리 수정없이 조회를 많이 하는 경우 적합&lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;새로운 노드를 추가하는 경우 모든 노드의 값을 다시 계산해야 함
        &lt;ul&gt;
          &lt;li&gt;트리에 노드를 삽입하는 경우가 많다면 중첩 집합은 적합하지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;직접 적인 부모 찾는 쿼리처럼 일부 쿼리가 복잡해질 수 있음
        &lt;ul&gt;
          &lt;li&gt;대상의 조상 중 부모와 자식 노드 사이에 노드가 없는 경우를 찾아야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;클로저-테이블closure-table&quot;&gt;클로저 테이블(Closure Table)&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/closure-table-comment-tree-sample.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/closure-table-comment-tree-sample.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/closure-table-comment-tree-sample.png&quot; class=&quot;zooming&quot; alt=&quot;closure table comment tree sample&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        closure table comment tree sample
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;계층구조를 저장하는 단순한 방법
    &lt;ul&gt;
      &lt;li&gt;부모-자식 관계 뿐만 아니라 트리의 모든 경로 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트리의 정보를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comment&lt;/code&gt; 테이블이 아닌 트리 구조를 저장하는 새로운 테이블 생성
    &lt;ul&gt;
      &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tree_path&lt;/code&gt; 라는 테이블 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조상이나 자손을 조회하는 쿼리가 직관적임&lt;/li&gt;
  &lt;li&gt;새로운 종말 노드를 추가하려면 자기 자신을 참조하는 행 추가&lt;/li&gt;
  &lt;li&gt;융통성있는 모델이지만 많은 저장 공간을 필요로 함&lt;/li&gt;
  &lt;li&gt;다양한 속성을 추가해 테이블 개선 가능
    &lt;ul&gt;
      &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path_length&lt;/code&gt; 를 추가하여 트리의 깊이 조회 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;모델&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;테이블&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;자식 조회&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;트리 조회&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;삽입&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;삭제&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;참조 정합성&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;인접 목록&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어렵다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;재귀적 쿼리&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;경로 열거&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;불가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;중첩 집합&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어렵다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어렵다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어렵다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;불가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클로저 테이블&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽다&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4장-아이디가-필요해-중복행-방지&quot;&gt;4장 아이디가 필요해: 중복행 방지&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;아무런 의미도 가지지 않는 인위적인 값을 PK 로 사용하는 형태를 &lt;strong&gt;가상키(pseudokey)&lt;/strong&gt; 또는 &lt;strong&gt;대체키(surrogate key)&lt;/strong&gt; 라 함
    &lt;ul&gt;
      &lt;li&gt;대부분의 DBMS 에서는 가상키 값이 유일하게 할당되는 것을 보장하기 위한 메커니즘 제공
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTO_INCREMENT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GENERATOR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDENTITY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROWID&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQUENCE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERIAL&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PK 는 테이블 내의 유일함을 보장
    &lt;ul&gt;
      &lt;li&gt;각 행에 접근하는 논리적 메커니즘&lt;/li&gt;
      &lt;li&gt;중복 행이 저장되는 것을 방지&lt;/li&gt;
      &lt;li&gt;PK 관계를 생성할 때 FK 로부터 참조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;안티패턴-만능키&quot;&gt;안티패턴: 만능키&lt;/h3&gt;

&lt;p&gt;모든 테이블에 다음과 같은 특성의 PK 칼럼 추가&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;칼럼 이름은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;데이터 타입은 32 비트 또는 64비트 정수&lt;/li&gt;
  &lt;li&gt;유일한 값은 자동 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;중복 키 생성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 컬럼을 정의하고 테이블에 UNIQUE 제약조건이 설정된 컬럼을 추가&lt;/li&gt;
      &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 가 있지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug_id&lt;/code&gt; 키 추가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중복 행 허용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;교차 테이블에서는 복합키를 통해 유일한 값을 보장해야 함&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 칼럼을 사용하는 경우 두 칼럼에 제약조건이 적용되지 않음
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNIQUE&lt;/code&gt; 제약조건을 걸어야 한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 칼럼은 불필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모호한 키의 의미&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 라는 의미는 일반적이기 때문에 아무런 의미를 가지지 못함
        &lt;ul&gt;
          &lt;li&gt;어떤 테이블의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 인지 구분이 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug_id&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account_id&lt;/code&gt; 같은 이름이 가독성이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;USING 사용 불가능&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 를 사용하면 이름이 다르기 때문에 불가능&lt;/li&gt;
      &lt;li&gt;두 테이블에서 컬럼 이름이 같다면 간략한 문법 사용 가능
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT * FROM bug JOIN bug_product USING (bug_id);&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어려운 복합키&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 를 사용하지 않으면 복합키 필요&lt;/li&gt;
      &lt;li&gt;복합 PK 를 참조하려면 복합 FK 가 되어야 함
        &lt;ul&gt;
          &lt;li&gt;쿼리가 복잡해짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-2&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 가상키 관례를 따르는 객체-관계 프레임워크를 사용하는 경우
    &lt;ul&gt;
      &lt;li&gt;ex) CoC (Convention over Configuration)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지나치게 긴 자연키를 대체하기 위함
    &lt;ul&gt;
      &lt;li&gt;ex) 파일 경로 - 긴 문자열을 키로 한다면 많은 인덱스 유지 비용 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-상황에-맞추기&quot;&gt;해법: 상황에 맞추기&lt;/h3&gt;

&lt;p&gt;정해진 관례를 무조건 따르지 않고 상황에 맞게 선택&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;있는 그대로 말하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;의미있는 PK 이름 사용 (ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug&lt;/code&gt; 테이블의 PK 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug_id&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;본질을 더 잘 표현 하는 경우, FK 를 PK 이름과 다르게 설정 (ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug&lt;/code&gt; 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reported_by&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;관례에서 벗어나기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용하는 프레임워크의 설정을 변경&lt;/li&gt;
      &lt;li&gt;의미 있는 컬럼 이름 사용하는 것이 중요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자연키와 복합키 포용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;자연키로 적당했던 컬럼이 중복이 허용되도록 변경될 수도 있음&lt;/li&gt;
      &lt;li&gt;복합키가 적절한 경우에 복합키 사용
        &lt;ul&gt;
          &lt;li&gt;참조하는 FK 도 복합키가 되어야 하므로 주의&lt;/li&gt;
          &lt;li&gt;중복된 칼럼 값을 얻을 때 조인을 안해도 되는 장점이 생김&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5장-키가-없는-엔트리-데이터베이스-아키텍처-단순화&quot;&gt;5장 키가 없는 엔트리: 데이터베이스 아키텍처 단순화&lt;/h2&gt;

&lt;p&gt;다음과 같은 상황으로 인해 참조 정합성 제약조건(또는 FK)을 사용하지 말라는 경우가 있음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 업데이트 시 제약조건과 충돌&lt;/li&gt;
  &lt;li&gt;참조 정합성 제약조건 또는 FK 를 지원하지 않는 데이터베이스 설계&lt;/li&gt;
  &lt;li&gt;FK 에 자동 생성되는 인덱스로 인해 성능에 영향을 받음&lt;/li&gt;
  &lt;li&gt;FK 선언을 위해 문법을 찾아봐야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;안티패턴-제약조건-무시&quot;&gt;안티패턴: 제약조건 무시&lt;/h3&gt;

&lt;p&gt;외래 키 제약조건을 생략하면 다른 방식으로 정합성 유지가 필요해짐&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;무결점 코드&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;행을 추가, 삭제할 때마다 값이 존재여부 확인 필요&lt;/li&gt;
      &lt;li&gt;높은 동시성(concurrency)과 확장적응성(scalability)이 필요한 환경에서 제대로 동작하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오류 확인&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;손상된 데이터를 찾기위해 자주 확인 필요&lt;/li&gt;
      &lt;li&gt;오류를 발견해도 어떤 값으로 맞춰야 할 지 바로잡기 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;“내 잘못이 아냐”&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터베이스를 건드리는 모든 코드가 완벽하지 않음&lt;/li&gt;
      &lt;li&gt;코드를 수정해도 모든 경우에 대해 문제가 없는지 확신이 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;진퇴양난 업데이트&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;FK 제약조건을 위반하지 않기 위해 여러 컬럼 실행 필요&lt;/li&gt;
      &lt;li&gt;자식 행이 참조하는 컬럼을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 하는 경우 처리가 어려워짐
        &lt;ul&gt;
          &lt;li&gt;자식 행 업데이트 전 부모 행 업데이트 불가, 부모 행 업데이트 전 자식행 업데이트 불가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-3&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;FK 제약조건을 지원하지 않는 데이터베이스
    &lt;ul&gt;
      &lt;li&gt;품질 제어 스크립트 같은 것으로 보완 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-제약조건-선언하기&quot;&gt;해법: 제약조건 선언하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;FK 사용하여 처음부터 잘못된 데이터가 입력되지 않도록 설정
    &lt;ul&gt;
      &lt;li&gt;불필요한 코드 작성할 필요 없음&lt;/li&gt;
      &lt;li&gt;모든 코드가 동일한 제약조건을 따르는 것을 확신 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;여러-테이블-변경-지원&quot;&gt;여러 테이블 변경 지원&lt;/h4&gt;

&lt;p&gt;단계적 업데이트(cascading update) 기능 지원&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;부모 행을 업데이트 또는 삭제하는 경우 자식 행을 알아서 처리 (진퇴양난 문제 해결)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ON UPDATE&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ON DELETE&lt;/code&gt; 선언 방식에 따라 결과 제어 가능
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CASCADE&lt;/code&gt; : 다른 행에서 대상 행을 참조하고 있으면 함께 변경/삭제 됨&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTRICT&lt;/code&gt;: 다른 행에서 대상 행을 참조하고 있으면 변경/삭제되지 않고 오류 발생&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NO ACTION&lt;/code&gt;: MYSQL 에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTRICT&lt;/code&gt; 와 동일&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SET NULL&lt;/code&gt;: 대상 행에서 대상 행을 참조하고 있으면 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 로 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;오버헤드&quot;&gt;오버헤드&lt;/h4&gt;

&lt;p&gt;약간의 오버헤드가 있을 수 있지만, FK 가 더 효율적&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 확인을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 쿼리 불필요&lt;/li&gt;
  &lt;li&gt;여러 테이블 변경을 위해 테이블 잠금 불필요&lt;/li&gt;
  &lt;li&gt;고아 데이터를 정정하기 위한 품질 제어 스크립트 불필요&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6장-엔티티-속성-값-가변-속성-지원&quot;&gt;6장 엔티티-속성-값: 가변 속성 지원&lt;/h2&gt;

&lt;p&gt;객체지향 프로그래밍 모델에서 데이터 타입을 상속하는 것과 같은 방법으로 관계를 가질 수 있다.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/bug-issue-feature-request-table-erd.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/bug-issue-feature-request-table-erd.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/bug-issue-feature-request-table-erd.png&quot; class=&quot;zooming&quot; alt=&quot;bug issue feature request table erd&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        bug issue feature request table erd
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;버그 데이터베이스로 예를 들어,&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bug&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FeatureRequest&lt;/code&gt; 는 베이스 타입인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Issue&lt;/code&gt; 속성을 공통으로 가지고 각자 다음 속성들을 갖는다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bug&lt;/code&gt;: 제품의 버전, 중요도, 영향도
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FeatureRequest&lt;/code&gt;: 예산을 지원하는 스폰서&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-범용-속성-테이블-사용&quot;&gt;안티패턴: 범용 속성 테이블 사용&lt;/h3&gt;

&lt;p&gt;별도 테이블을 생성해 속성을 행으로 저장하는 방식&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/issue-attribute-table-erd.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/issue-attribute-table-erd.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/issue-attribute-table-erd.png&quot; class=&quot;zooming&quot; alt=&quot;issue attribute table erd&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        issue attribute table erd
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;엔티티 (Entity)
    &lt;ul&gt;
      &lt;li&gt;속성하나의 엔티티에 대해 하나의 행을 가지는 부모 테이블에 대한 FK&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;속성 (Attribute)
    &lt;ul&gt;
      &lt;li&gt;일반 테이블에서의 컬럼 역할&lt;/li&gt;
      &lt;li&gt;속성이 하나씩 들어감&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;값 (Value)
    &lt;ul&gt;
      &lt;li&gt;속성에 대한 값을 가짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 설계는 엔티티-속성-값(Entity-Attribute-Value) 또는 EAV,
오픈 스키마(open schema), 스키마리스(schemaless), 이름-값(name-value pairs) 으로 불리기도 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;두 테이블 모두 적은 컬럼을 가짐&lt;/li&gt;
      &lt;li&gt;새로운 속성을 지원하기 위해 컬럼을 추가할 필요가 없음&lt;/li&gt;
      &lt;li&gt;특정 속성이 필요 없는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 을 채워도 되지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;속성 조회
    &lt;ul&gt;
      &lt;li&gt;문자열로 속성 이름을 지정하여 정보를 조회해야 함&lt;/li&gt;
      &lt;li&gt;일반 조회 쿼리보다 더 복잡하고 명확하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 정합성
    &lt;ul&gt;
      &lt;li&gt;필수 속성(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;) 사용 불가&lt;/li&gt;
      &lt;li&gt;데이터 타입 사용 불가
        &lt;ul&gt;
          &lt;li&gt;타입마다 컬럼을 선언하여 사용할 수도 있지만 쿼리가 더 복잡해짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;참조 정합성 강제 불가&lt;/li&gt;
      &lt;li&gt;속성 이름 강제 불가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;행을 재구성하기
    &lt;ul&gt;
      &lt;li&gt;일반적인 테이블에 저장된 것처럼 하나의 이슈를 조회하려면 각 속성에 대해 조인필요&lt;/li&gt;
      &lt;li&gt;속성 개수가 늘어나면 조인 회수도 늘어나고 쿼리 비용도 지수적으로 증가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-4&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;다루기 어려워지므로 명심해서 사용해야 함&lt;/li&gt;
  &lt;li&gt;비관계형 기술을 사용하는 경우
    &lt;ul&gt;
      &lt;li&gt;Berkeley DB, Cassandra, CouchDB, Hadoop, MongoDB, Redis…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-서브타입-모델링&quot;&gt;해법: 서브타입 모델링&lt;/h3&gt;

&lt;h4 id=&quot;단일-테이블-상속-single-table-inheritance&quot;&gt;단일 테이블 상속 (Single Table Inheritance)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;모든 타입을 하나의 테이블에 저장하고, 각 타입에 있는 모든 속성을 별도의 칼럼으로 저장&lt;/li&gt;
  &lt;li&gt;서브타입을 나타내기 위한 속성 필요 (ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;issue_type&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;해당 속성이 적용되지 않는 객체의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 로 채움&lt;/li&gt;
  &lt;li&gt;새로운 객체 타입이 생기면 해당 타입의 속성도 수용하기 위해 컬럼 추가 필요&lt;/li&gt;
  &lt;li&gt;적용하기 좋은 경우
    &lt;ul&gt;
      &lt;li&gt;서브타입 개수가 적은 경우&lt;/li&gt;
      &lt;li&gt;특정 타입에만 속하는 속성의 개수 적은 경우&lt;/li&gt;
      &lt;li&gt;단일 테이블 데이터베이스 접근 패턴을 사용하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;구체-테이블-상속-concrete-table-inheritance&quot;&gt;구체 테이블 상속 (Concrete Table Inheritance)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;적용되지 않는 속성이 없도록 강제 가능&lt;/li&gt;
  &lt;li&gt;단일 테이블 상속처럼 부가적인 서브타입을 나타내는 속성이 필요 없음&lt;/li&gt;
  &lt;li&gt;공통 속성을 인지하기 어렵고, 공통 속성이 추가되면 모든 서브타입 테이블 변경이 필요&lt;/li&gt;
  &lt;li&gt;모든 서브타입을 조회할 필요가 없는 경우에 적합
    &lt;ul&gt;
      &lt;li&gt;서브타입이 별도 테이블에 저장된 경우, 모든 객체를 보기가 복잡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;클래스-테이블-상속-class-table-inheritance&quot;&gt;클래스 테이블 상속 (Class Table Inheritance)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;객체지향 클래스인 것처럼 생각하여 상속을 흉내
    &lt;ul&gt;
      &lt;li&gt;공통인 속성을 포함하는 베이스 타입을 위한 테이블 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서브타입을 나타내기 위한 속성이 필요 없음&lt;/li&gt;
  &lt;li&gt;모든 서브타입에 대한 조회가 많고 공통 컬럼을 자주 참조하는 경우에 적합&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;반구조적-데이터-semistructured-data&quot;&gt;반구조적 데이터 (Semistructured Data)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;데이터의 속성 이름과 값을 XML 또는 JSON 형태로 저장&lt;/li&gt;
  &lt;li&gt;새로운 속성을 언제든 저장할 수 있기 때문에 확장이 쉬움&lt;/li&gt;
  &lt;li&gt;다른 속성 집합을 가질 수 있어서 각 행마다 서브 타입을 가질 수 있음&lt;/li&gt;
  &lt;li&gt;데이터베이스에서 특정 속성에 대해 지원하지 않는다면 조회가 어렵고, 복호화 코드 필요&lt;/li&gt;
  &lt;li&gt;완전한 유연성이 필요한 경우 적합&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사후-처리&quot;&gt;사후 처리&lt;/h4&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;issue_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attribute_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attribute_value&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;issue_attribute&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;issue_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1234&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;EAV 설계를 사용할 수 밖에 없는 경우&lt;/li&gt;
  &lt;li&gt;단일 행으로 조회하는 것이 아닌, 관련된 속성을 모두 조회하여 애플리케이션 코드에서 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7장-다형성-연관-여러-부모-참조&quot;&gt;7장 다형성 연관: 여러 부모 참조&lt;/h2&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/book/sql-anti-pattern/polymorphism-table-erd.png&quot;&gt;
        &lt;img src=&quot;/images/book/sql-anti-pattern/polymorphism-table-erd.png&quot; data-rjs=&quot;/images/book/sql-anti-pattern/polymorphism-table-erd.png&quot; class=&quot;zooming&quot; alt=&quot;polymorphism table erd&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        polymorphism table erd
        
        (출처: SQL AntiPattern)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;하나의 댓글(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comment&lt;/code&gt;) 테이블에 대해 버그(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug&lt;/code&gt;) 와 기능요청(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;feature_request&lt;/code&gt;) 에 대한 댓글을 저장하고 싶다.
하지만 여러 개의 부모 테이블을 참조하는 FK 를 생성은 불가능하다.&lt;br /&gt;
서브 타입이 아닌 관련 되지 않은 경우에도 이러한 문제는 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;안티패턴-이중-목적의-fk-사용&quot;&gt;안티패턴: 이중 목적의 FK 사용&lt;/h3&gt;

&lt;p&gt;이와 같은 경우, &lt;strong&gt;다형성 연관(polymorphic Associations)&lt;/strong&gt; 또는 &lt;strong&gt;난잡한 연관 (promiscuous associations)&lt;/strong&gt; 이라고도 불리는 해법을 활용한다.&lt;/p&gt;

&lt;h4 id=&quot;다형성-연관-정의&quot;&gt;다형성 연관 정의&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;현재 행이 참조하는 부모 테이블 이름을 저장하는 컬럼 추가 (ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;issue_type&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent_table&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;여러 부모 테이블들의 PK 값을 저장할 수 있는 컬럼 필요 (ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;issue_id&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent_id&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;여러 테이블에 대해 참조하기 때문에 FK 선언 불가&lt;/li&gt;
  &lt;li&gt;조인할 때, 부모 테이블 이름을 정확하게 명시해야 함
    &lt;ul&gt;
      &lt;li&gt;모두 다른 테이블과 연관되어 있는 경우, 테이블 조인이 불가능&lt;/li&gt;
      &lt;li&gt;외부 조인을 하는 쿼리를 활용하면 매칭되지 않는 필드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 로 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-5&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;객체-관계 프로그래밍 프레임워크를 사용하는 경우 (ex. Hibernate)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-관계-단순화&quot;&gt;해법: 관계 단순화&lt;/h3&gt;

&lt;p&gt;관계의 방향성을 거꾸로 하는 &lt;strong&gt;역 참조&lt;/strong&gt; 방법으로 해결&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;교차 테이블 생성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;각 부모에 대해 교차 테이블을 생성하여 여러 개의 FK 사용
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bug_comment&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;feature_request_comment&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;자식 테이블에서 부모 테이블의 타입을 저장하는 컬럼이 필요하지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터 정합성 강제 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;신호등 설치&lt;/strong&gt; - 허용하고 싶지 않은 연관이 생길 수 있는 문제 발생
        &lt;ul&gt;
          &lt;li&gt;자식 테이블의 특정 행이 같은 부모 테이블의 여러 행과 연관되지 않도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNIQUE&lt;/code&gt; 제약조건 추가&lt;/li&gt;
          &lt;li&gt;특정 행이 여러 부모 테이블에 대해 참조되는 것은 방지 불가 (어플리케이션 코드의 책임)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;양쪽 다 보기&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;특정 부모 테이블에 대한 데이터는 교차 테이블을 이용해 간단하게 조회 가능&lt;/li&gt;
          &lt;li&gt;참조 정합성에 의존하여 조회 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;차선 통합&lt;/strong&gt; - 여러 부모 테이블의 결과를 하나의 테이블처럼 보여줘야 하는 경우
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt; 을 통해 결과를 묶을 수 있음&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COALESCE0()&lt;/code&gt; 함수를 사용하여 존재하는 한쪽 부모 테이블의 필드만 나열하여 묶을 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공통 수퍼테이블 생성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;부모 테이블이 상속할 베이스 테이블 생성하여 문제 해결
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;issue&lt;/code&gt; 공통 테이블 생성, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comment&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;issue&lt;/code&gt; 을 참조&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부모 테이블 이름을 저장하는 컬럼이 필요하지 않음&lt;/li&gt;
      &lt;li&gt;FK 제약조건이 직접 연결되어 있지 않아도 정합성을 강제하면서 조인도 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;8장-다중-컬럼-속성-다중-값-속성-저장&quot;&gt;8장 다중 컬럼 속성: 다중 값 속성 저장&lt;/h2&gt;

&lt;p&gt;2장 무단횡단 안티패턴과 동일한 목표&lt;br /&gt;
여러 개의 값을 저장하고 싶은 경우&lt;br /&gt;
ex) 전화번호 - 보조 휴대폰, 사무실, 팩스 번호 등&lt;/p&gt;

&lt;h3 id=&quot;안티패턴--여러-개의-칼럼-생성&quot;&gt;안티패턴 : 여러 개의 칼럼 생성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;각 컬럼에 하나의 값만 저장하기 위해 여러 개의 칼럼을 생성
    &lt;ul&gt;
      &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag3&lt;/code&gt; …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;값 검색&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관련된 컬럼들에 대해 조회가 필요하다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt; 조건을 사용해야 함&lt;/li&gt;
      &lt;li&gt;여러 값에 대해서도 조회가 필요하다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 절이 길어짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;값 추가와 삭제&lt;/strong&gt; - 어느 컬럼이 비어있는지 확인하기 위한 조회 필요
    &lt;ul&gt;
      &lt;li&gt;동시성 문제가 발생될 수 있음 (충돌 또는 덮어쓰기)&lt;/li&gt;
      &lt;li&gt;복잡한 SQL 을 이용하면 한번에 해결도 가능
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULLIF&lt;/code&gt; 함수를 이용하여 동일한 대상 값 삭제 가능&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COALESCE&lt;/code&gt; 함수를 이용하여 빈 칼럼에 값 추가 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유일성 보장 불가&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;값의 수 증가 처리&lt;/strong&gt; - 테이블 변경 필요
    &lt;ul&gt;
      &lt;li&gt;테이블 구조를 변경하려면 잠금 설정하고, 클라이언트 접근 차단 과정 필요&lt;/li&gt;
      &lt;li&gt;예전 테이블에서 모든 데이터를 새로운 테이블로 복사하고, 예전 테이블 삭제하는 과정은 많은 시간 소요&lt;/li&gt;
      &lt;li&gt;컬럼을 추가하면 관련된 모든 SQL 문을 확인해 지원되도록 수정 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-6&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;속성의 개수가 고정되고 선택의 위치나 순서가 중요한 경우&lt;/li&gt;
  &lt;li&gt;각 속성의 사용처가 다른 경우 (논리적으로 다른 속성)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-종속-테이블-생성&quot;&gt;해법: 종속 테이블 생성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;종속 테이블 생성하고 FK 정의&lt;/li&gt;
  &lt;li&gt;주어진 태그에 대한 검색이 직관적&lt;/li&gt;
  &lt;li&gt;행 추가 삭제도 단순해짐&lt;/li&gt;
  &lt;li&gt;중복이 허용되지 않도록 제약조건을 추가하여 유일성 보장&lt;/li&gt;
  &lt;li&gt;제한되지 않은 컬럼 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;9장-메타데이터-트리블-확장-적응성-지원&quot;&gt;9장 메타데이터 트리블: 확장 적응성 지원&lt;/h2&gt;

&lt;p&gt;데이터 양이 늘어나면 쿼리 성능 저하됨&lt;br /&gt;
크기가 늘어나도 쿼리 성능을 향상 시킬 수 있도록 데이터베이스 구성&lt;/p&gt;

&lt;h3 id=&quot;안티패턴--테이블-또는-칼럼-복제&quot;&gt;안티패턴 : 테이블 또는 칼럼 복제&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;많은 행을 가진 큰 테이블을 작은 테이블로 분리
    &lt;ul&gt;
      &lt;li&gt;작은 테이블의 이름을 테이블의 속성 중 하나의 값을 기준으로 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하나의 칼럼을 여러 개의 칼럼으로 분리
    &lt;ul&gt;
      &lt;li&gt;칼럼 이름은 다른 속성의 값을 기준으로 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같이 두 가지의 형태의 안티패턴이 존재 &lt;br /&gt;
이렇게 구성하게 되면 테이블 수나 칼럼 수가 계속 증가하게 됨&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;테이블이 우글우글&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터를 분리해 별도의 테이블에 넣으려면 어떤 테이블로 보낼지 정책 필요&lt;/li&gt;
      &lt;li&gt;나눠지는 정책이나 값이 변경되면 애플리케이션 에러 발생&lt;/li&gt;
      &lt;li&gt;새로운 데이터 값이 들어오면 새로운 메타데이터 객체가 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 정합성 관리&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;조건이 올바르지 않는 데이터가 존재하지 않아야 함&lt;/li&gt;
      &lt;li&gt;테이블 생성 시, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHECK&lt;/code&gt; 제약 조건을 통해 제한 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 동기화&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터를 변경하는 경우, 한 테이블에서 삭제하고 다른 테이블에 삽입해야할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유일성 보장&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;유일성을 보장하기 위해서는 PK 값 생성만을 위한 새로운 테이블 정의 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;여러 테이블에 걸쳐 조회&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 테이블에 걸쳐 조회해야 하는 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt; 으로 묶어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메타데이터 동기화&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;테이블 컬럼을 추가하기 위해서는 모든 테이블에 컬럼 추가 필요&lt;/li&gt;
      &lt;li&gt;와일드카드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;) 사용이 어렵고 이름 지정 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;참조 정합성 관리&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;다른 테이블에서 해당 테이블에 대해 FK 선언 불가&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 되는 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt; 으로 묶어서 조회 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메타데이터 트리블 칼럼 식별하기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컬럼도 동일하게 메타데이터 트리블이 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;사용이-합당한-경우-7&quot;&gt;사용이 합당한 경우&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;현재 데이터와 오래된 데이터를 함께 조회할 필요가 없는 경우
    &lt;ul&gt;
      &lt;li&gt;오래된 데이터를 다른 위치로 옮기고 해당 테이블에서 삭제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해법-파티션과-정규화&quot;&gt;해법: 파티션과 정규화&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;수평 분할(horizontal partitioning) 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;규칙을 정해 행을 여러 파티션으로 분리
        &lt;ul&gt;
          &lt;li&gt;물리적으로 분리되어 있지만, 하나의 테이블처럼 사용 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;별도 스토리지로 분리 가능&lt;/li&gt;
      &lt;li&gt;행이 잘못된 테이블로 들어갈 문제가 없음&lt;/li&gt;
      &lt;li&gt;물리적인 테이블 개수를 직접 지정할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수직 분할(vertical partitioning) 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;크기가 큰 컬럼이나 거의 사용되지 않은 컬럼이 있는 경우 유리
        &lt;ul&gt;
          &lt;li&gt;와일드카드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;)를 사용하면 해당 컬럼도 모두 조회하게 되므로 성능 저하 발생될 수 있음&lt;/li&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BLOB&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TEXT&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;행이 고정 크기인 경우 조회 성능이 좋으므로 가변 길이 컬럼을 별도 테이블로 저장하면 성능 향상
        &lt;ul&gt;
          &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VARCHAR&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메타데이터 트리블 컬럼 고치기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;메타데이터 트리블 컬럼에 대해 종속 테이블 생성&lt;/li&gt;
      &lt;li&gt;함께 조회하는 경우가 드문 경우 사용
        &lt;ul&gt;
          &lt;li&gt;함께 조회하는 경우가 많다면 오히려 성능 저하 발생&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관련 코드는 &lt;a href=&quot;https://github.com/devyonghee/sql-anti-pattern-study&quot;&gt;깃허브&lt;/a&gt; 참고&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SQL AntiPatterns&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="book" /><category term="book" /><category term="sql anti pattern" /><category term="database" /><category term="sql" /><summary type="html">SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다. 1부에서는 데이터베이스 테이블과 컬럼, 관계를 계획하는 방법에 대해 알아본다.</summary></entry><entry><title type="html">[DDD] DDD(Domain Driven Design) 용어 정리</title><link href="https://devyonghee.github.io/theory/2023/01/22/ddd-terms-summary/" rel="alternate" type="text/html" title="[DDD] DDD(Domain Driven Design) 용어 정리" /><published>2023-01-22T00:00:00+00:00</published><updated>2023-01-22T00:00:00+00:00</updated><id>https://devyonghee.github.io/theory/2023/01/22/ddd-terms-summary</id><content type="html" xml:base="https://devyonghee.github.io/theory/2023/01/22/ddd-terms-summary/">&lt;p&gt;DDD(Domain Driven Design, 도메인 주도 설계) 는 도메인을 중심으로 설계하는 방법론이다. &lt;br /&gt;
소프트웨어 개발하면서 방대하고 복잡한 지식으로 인해 어려움이 생기는데, 도메인을 중심으로 설계하면 이 부담을 해소할 수 있다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;도메인-모델-만들기&quot;&gt;도메인 모델 만들기&lt;/h2&gt;

&lt;p&gt;도메인 모델은 도메인과 관련된 지식을 엄격하게 구성하고 선택적으로 추상화 한 것이다. &lt;br /&gt;
적절한 모델을 통해 정보를 이해하고 해결하고자 하는 문제 자체에 집중할 수 있다.&lt;br /&gt;
DDD 에서는 다음과 같은 세 가지 용도에 따라 모델을 선택하게 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;핵심 설계를 위한 도메인 모델
    &lt;ul&gt;
      &lt;li&gt;도메인 모델과 설계 및 구현은 긴밀한 관계를 가짐&lt;/li&gt;
      &lt;li&gt;모델 이해를 근거하여 코드를 해석할 수 있기 때문에 유지보수와 기능 개선에 도움이 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;팀 구성원들의 중추적인 언어를 위한 도메인 모델
    &lt;ul&gt;
      &lt;li&gt;이 모델을 토대로 프로그램 의견을 나눌 수 있음&lt;/li&gt;
      &lt;li&gt;번역 절차가 필요하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지식의 정수만을 추출하기 위한 도메인 모델
    &lt;ul&gt;
      &lt;li&gt;용어를 선택, 개념 분류, 지식들을 연관 시키면서 팀원들의 사고 방식을 담을 수 있음&lt;/li&gt;
      &lt;li&gt;많은 정보를 모델로 만들어서 효과적인 협업 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;domain-도메인&quot;&gt;Domain (도메인)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어로 해결하고자 하는 문제 영역&lt;/li&gt;
  &lt;li&gt;한 도메인은 다시 하위 도메인으로 나누어질 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;domain-model-도메인-모델&quot;&gt;Domain Model (도메인 모델)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;도메인을 개념적으로 표현한 것 (ex. 클래스 다이어그램, 상태 다이어그램, 그래프 등)&lt;/li&gt;
  &lt;li&gt;여러 관계자들이 도메인을 이해하고 공유하는데 도움&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ubiquitous-language보편-언어&quot;&gt;Ubiquitous Language(보편 언어)&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/ubiquitous-language.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/ubiquitous-language.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/ubiquitous-language.png&quot; class=&quot;zooming&quot; alt=&quot;전문 용어 교차 지점에 형성된 ubiquitous language&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        전문 용어 교차 지점에 형성된 ubiquitous language
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;도메인 모델에 따라 모든 팀원 간의 활동을 연계하는데 사용되는 &lt;strong&gt;공통 언어&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;언어가 분열되면 의사소통이 무뎌지고 빈약해지기 때문에 조화가 깨지고, 소프트웨어의 신뢰도가 떨어짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지속적으로 사용하면 모델의 취약점이 드러나고, 개선이 필요한 지점을 찾을 수 있음&lt;/li&gt;
  &lt;li&gt;의사소통과 코드에 끊임없이 동일한 언어를 적용
    &lt;ul&gt;
      &lt;li&gt;도메인 전문가: 도메인을 이해하는데 부자연스럽고 부정확한 용어나 구조에 대해 반대 의사를 표명해야 함&lt;/li&gt;
      &lt;li&gt;개발자: 설계를 어렵게 만드는 모호하거나 불일치 요소를 찾아내야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;모델-주도-설계의-기본-요소&quot;&gt;모델 주도 설계의 기본 요소&lt;/h2&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/ddd-language-navigation-map.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/ddd-language-navigation-map.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/ddd-language-navigation-map.png&quot; class=&quot;zooming&quot; alt=&quot;model-driven design 언어 내비게이션 맵&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        model-driven design 언어 내비게이션 맵
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;내비게이션 맵을 통해 도메인 주도 설계 과정에 사용되는 패턴들이 서로 어떻게 관계를 맺는지 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;layered-architecture계층형-아키텍처&quot;&gt;Layered Architecture(계층형 아키텍처)&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/layered-architecture.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/layered-architecture.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/layered-architecture.png&quot; class=&quot;zooming&quot; alt=&quot;layered architecture&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        layered architecture
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;도메인과 관련된 코드가 관련 없는 코드를 통해 널리 확산된다면 도메인에 대해 추론하기 어려워진다.&lt;br /&gt;
복잡한 작업을 처리하는 소프트웨어를 만들기 위해서는 관심사의 분리를 통해 격리를 시켜야 각 설계 요소에 집중할 수 있다.&lt;/p&gt;

&lt;p&gt;분리하는 많은 방법들 중에서는 Layered Architecture 가 널리 사용되고 있는데, 대다수는 네 가지 개념적 계층으로 나뉘어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;표현 계층(사용자 인터페이스)
    &lt;ul&gt;
      &lt;li&gt;사용자에게 정보를 보여주고 사용자의 명령을 해석하는 계층&lt;/li&gt;
      &lt;li&gt;사람이 아닌 다른 컴퓨터 시스템이 외부 행위자가 될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;응용 계층(애플리케이션)
    &lt;ul&gt;
      &lt;li&gt;소프트웨어가 수행할 작업을 정의하고 도메인 객체가 문제를 해결하는 계층&lt;/li&gt;
      &lt;li&gt;업무상 중요하거나 다른 시스템의 응용 계층과 상호작용&lt;/li&gt;
      &lt;li&gt;업무 규칙이나 지식이 포함되지 않고 얇게 유지되어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도메인 계층
    &lt;ul&gt;
      &lt;li&gt;업무 개념, 업무 상황, 업무 규칙을 표현하는 계층&lt;/li&gt;
      &lt;li&gt;업무용 소프트웨어의 핵심 계층&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인프라스트럭처 계층
    &lt;ul&gt;
      &lt;li&gt;일반화된 기술적 기능 제공 (ex. 메시지 전송, 도메인 영속화, UI 위젯 그리기 등)&lt;/li&gt;
      &lt;li&gt;네 가지 계층에 대한 상호작용 패턴 지원 가능&lt;/li&gt;
      &lt;li&gt;도메인의 구체적인 지식을 포함하지 않아야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;entity엔티티-참조객체&quot;&gt;Entity(엔티티, 참조객체)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;일차적으로 해당 객체의 &lt;strong&gt;식별성&lt;/strong&gt;으로 정의한 객체&lt;/li&gt;
  &lt;li&gt;객체의 생명주기 동안 형태와 내용이 바뀔 수 있지만 &lt;strong&gt;연속성&lt;/strong&gt;은 유지되어야 함&lt;/li&gt;
  &lt;li&gt;클래스 정의를 단순하게 하고 생명주기의 &lt;strong&gt;연속성&lt;/strong&gt;과 &lt;strong&gt;식별성&lt;/strong&gt;에 집중&lt;/li&gt;
  &lt;li&gt;특정 속성보다는 정체성에 대해 초점을 맞춰야 함&lt;/li&gt;
  &lt;li&gt;식별 수단은 모델에서 식별성을 구분하는 방법과 일치해야 함
    &lt;ul&gt;
      &lt;li&gt;특정 규칙에 따라 생성&lt;/li&gt;
      &lt;li&gt;UUID 사용&lt;/li&gt;
      &lt;li&gt;값 직접 입력&lt;/li&gt;
      &lt;li&gt;일련번호 사용(시퀀스나 DB 자동 증가)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;value-object값-객체&quot;&gt;Value Object(값 객체)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;개념적 &lt;strong&gt;식별성을 갖지 않으면서&lt;/strong&gt; 도메인의 서술적 측면을 나타내는 객체
    &lt;ul&gt;
      &lt;li&gt;어떤 요소의 속성에만 관심이 있다면 Value Object 로 구분하고 의미와 관련 기능 부여&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Value Object 가 Entity 를 참조할 수 있음&lt;/li&gt;
  &lt;li&gt;불변적(immutable)으로 다뤄야 함&lt;/li&gt;
  &lt;li&gt;식별성을 부여하면 안 됨&lt;/li&gt;
  &lt;li&gt;Value Object 간의 양방향 연관관계는 제거해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;service서비스&quot;&gt;Service(서비스)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Entity 나 Value Object 에서 구현하지 못하는 &lt;strong&gt;도메인 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Entity 나 Value Object 의 일부를 구성하는 것이 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태를 캡슐화하지 않음&lt;/li&gt;
  &lt;li&gt;연산의 명칭은 Ubiquitous Language 에서 유래되거나 반영되어야 함&lt;/li&gt;
  &lt;li&gt;서비스는 응용, 도메인, 인프라스트럭처로 여러 계층으로 분할 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;module모듈-패키지&quot;&gt;Module(모듈, 패키지)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;모듈화를 통해 해당 모듈의 세부사항을 보거나, 모듈 간의 관계를 확인할 수 있음&lt;/li&gt;
  &lt;li&gt;하나의 의사소통 메커니즘
    &lt;ul&gt;
      &lt;li&gt;Ubiquitous Language 를 구성하는 것으로 모듈 이름 부여&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모듈 간에는 &lt;strong&gt;결합도가 낮아야 함&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사람이 생각할 수 있는 양에 한계가 있음&lt;/li&gt;
      &lt;li&gt;모듈화를 통해 다른 코드로부터 도메인 계층을 분리해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모듈의 내부는 &lt;strong&gt;응집도가 높아야 함&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;일관성이 없는 단편적인 생각은 이해가 어려움&lt;/li&gt;
      &lt;li&gt;하나의 개념적 객체를 구현하는 코드는 모두 같은 모듈에 위치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;aggregate집합체&quot;&gt;Aggregate(집합체)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터 변경의 단위&lt;/strong&gt;로 다루는 연관 객체의 모음
    &lt;ul&gt;
      &lt;li&gt;일관성 규칙의 경계로 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 Aggregate 는 &lt;strong&gt;루트(root)&lt;/strong&gt; 와 &lt;strong&gt;경계(boundary)&lt;/strong&gt; 가 존재&lt;/li&gt;
  &lt;li&gt;루트는 Aggregate 마다 하나만 존재하며, 특정 Entity 를 가리킴&lt;/li&gt;
  &lt;li&gt;경계 바깥쪽의 객체는 &lt;strong&gt;루트를 통해서만 참조&lt;/strong&gt; 가능
    &lt;ul&gt;
      &lt;li&gt;루트를 통해서만 Aggregate 상태 변경 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;루트는 Value Object 복사본을 다른 객체에 전달할 순 있음&lt;/li&gt;
  &lt;li&gt;루트 Entity 는 전역 식별성을 지니며, 불변식 검사 책임이 있음&lt;/li&gt;
  &lt;li&gt;삭제 연산은 Aggregate 경계 안의 모든 요소를 한 번에 제거해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;통찰력을-위한-리팩터링&quot;&gt;통찰력을 위한 리팩터링&lt;/h2&gt;

&lt;p&gt;리팩터링이란 소프트웨어의 기능을 수정하지 않고 설계를 다시 하는 것이다.&lt;br /&gt;
지속적으로 리팩터링을 수행하려면 설계가 유연하고 명확하여 표현할 수 있어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;factory-팩토리&quot;&gt;Factory (팩토리)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;객체나 전체 Aggregate 의 복잡한 생성을 캡슐화&lt;/li&gt;
  &lt;li&gt;설계하는 방법으로 팩토리 메서드(factory method), 추상 팩토리(abstract factory), 빌더(builder) 패턴 등이 존재&lt;/li&gt;
  &lt;li&gt;Entity Factory 와 Value Object Factory
    &lt;ul&gt;
      &lt;li&gt;Entity Factory: 필요한 필수 속성만 받아들이는 경향이 있음&lt;/li&gt;
      &lt;li&gt;Value Object Factory: 불변젹이므로 최정적인 형태로 만들어짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;factory-설계-기본-요건&quot;&gt;Factory 설계 기본 요건&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;생성 방법은 &lt;strong&gt;원자적&lt;/strong&gt;, &lt;strong&gt;불변식&lt;/strong&gt;을 모두 지켜야 함&lt;/li&gt;
  &lt;li&gt;생성하고자 하는 타입으로 추상화 되어야 함 (Factory 패턴)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;repository-리파지터리&quot;&gt;Repository (리파지터리)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;특정 타입의 모든 객체를 개념적 집합 (객체 &lt;strong&gt;컬렉션&lt;/strong&gt;처럼 동작)&lt;/li&gt;
  &lt;li&gt;데이터에 대한 실제 저장소와 질의 기술을 캡슐화하여 모델에 집중할 수 있게 도와줌
    &lt;ul&gt;
      &lt;li&gt;데이터 소스로부터 도메인 설계를 분리&lt;/li&gt;
      &lt;li&gt;저장∙조회∙검색 행위를 캡슐화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;영속 객체는 해당 객체의 속성으로 전역적으로 접근할 수 있어야 함&lt;/li&gt;
  &lt;li&gt;직접 접근 해야하는 &lt;strong&gt;Aggregate 루트&lt;/strong&gt;에 대해서만 Repository 를 제공
    &lt;ul&gt;
      &lt;li&gt;마음대로 데이터베이스 질의를 한다면 도메인 객체와 Aggregate 캡슐화가 깨질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;질의의 수가 많으면 &lt;strong&gt;Specification(명세)&lt;/strong&gt; 기반하여 질의를 수행
    &lt;ul&gt;
      &lt;li&gt;Specification: 특정 조건을 만족하는 객체를 찾는데 사용되는 객체&lt;/li&gt;
      &lt;li&gt;Specification 을 이용하면 유연한 질의를 수행 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;factory-와-repository-차이&quot;&gt;Factory 와 Repository 차이&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/repository-factory-reconstruction.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/repository-factory-reconstruction.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/repository-factory-reconstruction.png&quot; class=&quot;zooming&quot; alt=&quot;Repository 는 Factory 를 이용해 존재하는 객체 재구성&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        Repository 는 Factory 를 이용해 존재하는 객체 재구성
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/repository-factory-new-object-save.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/repository-factory-new-object-save.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/repository-factory-new-object-save.png&quot; class=&quot;zooming&quot; alt=&quot;클라이언트는 Repository 를 이용해 객체 저장&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        클라이언트는 Repository 를 이용해 객체 저장
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Factory: 새로운 객체 생성
    &lt;ul&gt;
      &lt;li&gt;객체 생애의 초기 단계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Repository: 기존 객체 조회
    &lt;ul&gt;
      &lt;li&gt;객체 생애의 중간과 마지막 단계&lt;/li&gt;
      &lt;li&gt;메모리 상에 객체가 존재하고 있는 것처럼 동작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;specification-명세&quot;&gt;Specification (명세)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;객체가 특정 기준을 만족하는지 판단하는 술어&lt;/li&gt;
  &lt;li&gt;특별한 목적을 위해 술어와 비슷한 명시적인 &lt;strong&gt;Value Object&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;규칙을 &lt;strong&gt;도메인 계층&lt;/strong&gt;에 유지할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;specification-용도&quot;&gt;Specification 용도&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;검증(validation)
    &lt;ul&gt;
      &lt;li&gt;Specification 의 개념을 가장 직관적으로 설명해주는 방식&lt;/li&gt;
      &lt;li&gt;특정한 조건에 부합하는지 여부를 판단하기 위해 개별 객체 테스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;선택 (질의)
    &lt;ul&gt;
      &lt;li&gt;특정한 조건을 기반으로 객체 컬렉션의 일부 선택 (필터링)&lt;/li&gt;
      &lt;li&gt;Specification 에 메서드를 추가하여 질의문(query) 을 캡슐화하여 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요청 구축(생성)
    &lt;ul&gt;
      &lt;li&gt;명시된 조건을 만조가는 새로운 객체나 객체 집합을 새로 만들거나 재구성&lt;/li&gt;
      &lt;li&gt;존재하지 않는 객체에 대한 기준을 명시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;유연한-설계를-위한-패턴&quot;&gt;유연한 설계를 위한 패턴&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/flexible-design-pattern.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/flexible-design-pattern.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/flexible-design-pattern.png&quot; class=&quot;zooming&quot; alt=&quot;유연한 설계에 기여하는 패턴&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        유연한 설계에 기여하는 패턴
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;h4 id=&quot;intention-revealing-interface-의도를-드러내는-인터페이스&quot;&gt;Intention-Revealing Interface (의도를 드러내는 인터페이스)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;설계에 포함된 모든 요소(타입, 메서드, 인자 이름)가 인터페이스를 구성하고, 설계 의도를 드러냄&lt;/li&gt;
  &lt;li&gt;수행 방법이 아닌 결과와 목적만을 표현하도록 클래스와 연산의 이름을 부여 (Ubiquitous Language 용어를 따름)&lt;/li&gt;
  &lt;li&gt;연산을 추가하기 전에 행위에 대한 테스트 우선 작성&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;side-effect-free-function-부수효과가-없는-함수&quot;&gt;Side-Effect-Free Function (부수효과가 없는 함수)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;함수(function)는 &lt;strong&gt;부수효과를 일으키지 않고 항상 동일한 값 반환&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;명령과 질의를 엄격하게 분리된 다른 연산으로 유지해야 함
    &lt;ul&gt;
      &lt;li&gt;변경을 발생시키는 메서드는 데이터를 반환하지 않도록 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명령과 질의 분리 대신 불변 객체 Value Object 활용할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assertion-단언&quot;&gt;Assertion (단언)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램이 어느 시점에 지녀야 할 정확한 상태를 나타내는 문장&lt;/li&gt;
  &lt;li&gt;자동화된 테스트나 프로그램 코드에 직접 연산의 사후조건과 클래스 및 Aggregate 의 불변식을 표현&lt;/li&gt;
  &lt;li&gt;Assertion 을 의도적으로 추측할 수 있게 하고 응집도 높은 개념을 포함된 모델을 만들어야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;conceptual-contour-개념적-윤곽&quot;&gt;Conceptual Contour (개념적 윤곽)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;도메인 자체의 근원적인 일관성&lt;/li&gt;
  &lt;li&gt;도메인의 설계 요소(연산, 인터페이스, 클래스, Aggregate) 를 응집력 있는 단위로 분해&lt;/li&gt;
  &lt;li&gt;리팩터링을 통해 변경되는 부분과 변경되지 않는 부분을 중심 축으로 식별하고 분리해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;standalone-class-독립형-클래스&quot;&gt;Standalone Class (독립형 클래스)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;무관한 모든 개념을 제거하여 클래스를 독립적(self-contained)으로 유지해야 함 (낮은 결합도)
    &lt;ul&gt;
      &lt;li&gt;어떤 것도 참조하지 않은 상태에서 이해하고 테스트가 가능한 클래스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의존성이 증가할수록 설계를 파악하기 어려워져 복잡도가 매우 높아짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;closure-of-operation-연산의-닫힘&quot;&gt;Closure Of Operation (연산의 닫힘)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;반환 타입&lt;/strong&gt;과 &lt;strong&gt;인자 타입&lt;/strong&gt;이 동일한 연산
    &lt;ul&gt;
      &lt;li&gt;구현자(implementer)가 연산에 사용된다면 인자, 반환, 구현자의 타입을 동일하게 정의&lt;/li&gt;
      &lt;li&gt;부차적인 개념을 사용하지 않고도 &lt;strong&gt;고수준의 인터페이스 제공&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Value Object 연산을 정의하는데 주로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;전략적-설계&quot;&gt;전략적 설계&lt;/h2&gt;

&lt;p&gt;시스템이 복잡해질수록 커다란 모델을 다루고 이해하기 위한 기법이 필요하다.&lt;br /&gt;
전략적 설계는 프로젝트를 교착상태에 빠지지 않고 시스템의 핵심 개념과 비전을 포착할 수 있어야 한다.&lt;br /&gt;
도메인 주도 설계에서는 이 목표를 다루기 위해 컨텍스트, 디스틸레이션, 대규모 구조를 다룬다.&lt;/p&gt;

&lt;h3 id=&quot;모델의-무결성-유지&quot;&gt;모델의 무결성 유지&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/integrity-pattern-navigation-map.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/integrity-pattern-navigation-map.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/integrity-pattern-navigation-map.png&quot; class=&quot;zooming&quot; alt=&quot;모델 무결성 패턴 네비게이션 맵&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        모델 무결성 패턴 네비게이션 맵
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;모델의 용어는 언제나 의미가 동일하고, 모순되는 규칙도 없도록 일관성(단일화, unification)을 유지해야 한다.&lt;br /&gt;
하지만 대규모 시스템에서 도메인 모델을 단일화하는 것은 어렵기 때문에 의식적으로 전략을 결정하고 따라야 한다.&lt;/p&gt;

&lt;h4 id=&quot;bounded-context-제한된-컨텍스트&quot;&gt;Bounded Context (제한된 컨텍스트)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;사용된 용어를 특정한 의미로 의사소통하기 위한 &lt;strong&gt;조건의 집합&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;다수의 모델이 한데 섞이면 신뢰성이 떨어지고 이해하기 힘들어짐 (중복된 개념, 허위 동적 언어)&lt;/li&gt;
      &lt;li&gt;특정 모델에 포함된 범위가 정해진 컨텍스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨텍스트의 경계를 물리적인 형태(조직, 코드 기반, 데이터베이스 스키마 등)의 관점에서 명시적으로 설정
    &lt;ul&gt;
      &lt;li&gt;컨텍스트 경계는 대개 팀 조직의 윤곽을 따라 정해짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;경계 내에서는 모델을 일관된 상태로 유지하고 경계 바깥으로 인해 혼란이 생기지 않아야 함
    &lt;ul&gt;
      &lt;li&gt;Bounded Context 간에는 코드를 재사용하지 않아야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;continuous-integration-지속적인-통합&quot;&gt;Continuous Integration (지속적인 통합)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;내부적인 균열을 빠르게 포착하고 정정할 수 있도록 컨텍스트 내의 모든 작업을 병합해서 &lt;strong&gt;일관성을 유지&lt;/strong&gt;하는 것&lt;/li&gt;
  &lt;li&gt;하나의 Bounded Context 내에서만 필수적&lt;/li&gt;
  &lt;li&gt;모델 개념의 통합 (통합 방법이 용이해짐)
    &lt;ul&gt;
      &lt;li&gt;변화하는 모델을 함께 이해하고 발전하면서 Ubiquitous Language 유지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현 수준에서의 통합 (유효성과 일관성 입증, 균열 포착)
    &lt;ul&gt;
      &lt;li&gt;단계적이고 재생 가능한 병합/빌드&lt;/li&gt;
      &lt;li&gt;자동화된 테스트 스위트&lt;/li&gt;
      &lt;li&gt;수정사항이 통합되지 않은 상태로 존재할 수 있는 시간을 적당히 짧게 유지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;context-map-컨텍스트-맵&quot;&gt;Context Map (컨텍스트 맵)&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/context-map.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/context-map.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/context-map.png&quot; class=&quot;zooming&quot; alt=&quot;컨텍스트 맵&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        컨텍스트 맵
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;서로 다른 컨텍스트 간의 관계를 정의하고 모든 모델 컨텍스트를 아우르는 &lt;strong&gt;전체적인 뷰&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컨텍스트 간의 번역&lt;/strong&gt;에 대한 윤곽을 명확하게 하고 만나는 경계 지점에 대한 공유 정보 강조 필요
    &lt;ul&gt;
      &lt;li&gt;Bounded Context 의 명확한 이름을 제공하고 경계 지점의 특성을 명확하게 표현해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다이어그램들이 맵을 가시화하고 의사소통하는 데 유용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shared-kernel-공유-커널&quot;&gt;Shared Kernel (공유 커널)&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/shared-kernel.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/shared-kernel.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/shared-kernel.png&quot; class=&quot;zooming&quot; alt=&quot;공유 커널&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        공유 커널
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;공유하기로 한 &lt;strong&gt;도메인 모델의 부분집합&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모델 요소, 연관 코드, 데이터베이스 설계 등이 포함&lt;/li&gt;
      &lt;li&gt;core domain, generic subdomain 의 일부인 경우가 대부분&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변경하기 위해서는 다른 팀과의 협업이 필요&lt;/li&gt;
  &lt;li&gt;기능 시스템을 통합할 때는 양 팀에서 작성한 테스트 모두 실행 필요&lt;/li&gt;
  &lt;li&gt;일반적으로 각 팀은 별도의 Kernel 복사본을 변경하고 다른 팀과 통합&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;customersupplier-development고객공급자-개발-팀&quot;&gt;Customer/Supplier development(고객/공급자 개발 팀)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;두 팀 간에 고객/공급자 관계를 확립 필요
    &lt;ul&gt;
      &lt;li&gt;하류 팀이 상류 팀에 대한 고객 역할&lt;/li&gt;
      &lt;li&gt;고객의 요구사항이 가장 중요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인터페이스를 검증하는 인수 테스트 작성 필요
    &lt;ul&gt;
      &lt;li&gt;테스트 스위트에 추가하여 상류팀은 자유롭게 코드 변경 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;conformist-준수자&quot;&gt;Conformist (준수자)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;연결되는 지점에서 &lt;strong&gt;상류팀의 도메인 모델&lt;/strong&gt;을 그대로 따르는(준수하는) 모델
    &lt;ul&gt;
      &lt;li&gt;상류팀의 모델을 준수하여 하류 팀의 설계 형식이 상류 팀에 속박 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이상적인 모델을 만드는 것은 어렵지만 &lt;strong&gt;통합은 단순&lt;/strong&gt;해짐&lt;/li&gt;
  &lt;li&gt;모델을 공유한다는 점이 shared kernel 과 유사
    &lt;ul&gt;
      &lt;li&gt;shared kernel: 밀접하게 조율하는 두 팀 간의 협력관계를 다룸&lt;/li&gt;
      &lt;li&gt;conformist: 협력에 관심 없는 팀과의 통합 문제를 다룸&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;anticorruption-layer-오류-방지-계층&quot;&gt;Anticorruption Layer (오류 방지 계층)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트 도메인 모델 측면에서 기능을 제공하는 &lt;strong&gt;격리 계층&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;다른 시스템과 상호작용하는 모델로 인해 도메인 모델의 의도가 매몰되는 것을 방지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체와 행위를 다른 모델과 프로토콜로 변환하기 위한 메커니즘&lt;/li&gt;
  &lt;li&gt;공용 인터페이스는 보통 Service (간혹 Entity) 의 집합으로 표현&lt;/li&gt;
  &lt;li&gt;두 Bounded Context 를 잇는 수단&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;anticorruption-layer-구현&quot;&gt;Anticorruption Layer 구현&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/anticorruption-layer.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/anticorruption-layer.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/anticorruption-layer.png&quot; class=&quot;zooming&quot; alt=&quot;공유 커널&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        공유 커널
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;통신 및 전송 메커니즘, Facade, Adapter, 번역기 조합으로 설계&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Facade
    &lt;ul&gt;
      &lt;li&gt;한쪽 모델에서 다른 모델로 번역하는 것을 담당&lt;/li&gt;
      &lt;li&gt;하위 시스템에 대한 &lt;strong&gt;클라이언트 접근을 단순&lt;/strong&gt;화하는 &lt;strong&gt;인터페이스&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;다른 시스템 모델에 따라 엄격하게 작성해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Adapter
    &lt;ul&gt;
      &lt;li&gt;클라이언트에서 구현된 행위를 사용할 수 있게 해주는 &lt;strong&gt;래퍼(wrapper)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Facade 에 상응하는 요청을 수행하는 &lt;strong&gt;행위를 구현&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;번역기
    &lt;ul&gt;
      &lt;li&gt;개념 객체나 데이터의 변환&lt;/li&gt;
      &lt;li&gt;Adapter 에 속하는 요소로 상태가 필요 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;separate-ways-각자의-길&quot;&gt;Separate Ways (각자의 길)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Bounded Context 가 &lt;strong&gt;다른 것과 관계를 맺지 않도록 선언&lt;/strong&gt;하여 범위 내에서 해결책을 찾음
    &lt;ul&gt;
      &lt;li&gt;통합에도 큰 비용이 발생되기 때문에 관계를 끊을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;통합이 필요해진다면 번역 계층이 필요해질 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;published-language-공표된-언어&quot;&gt;Published Language (공표된 언어)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Bounded Context &lt;strong&gt;모델 간에 소통되는 공통의 언어&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;필요한 도메인 정보를 표현하는 공유 언어를 공통의 의사소통 매개체로 사용 또는 번역
    &lt;ul&gt;
      &lt;li&gt;기존 모델을 직접 번역하면 복잡하고 문서화가 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시스템 간의 상호작용이 많아지면 Published Language 를 갖추고 관계 공식화가 필요&lt;/li&gt;
  &lt;li&gt;Published Language 는 안정적이어야 함
    &lt;ul&gt;
      &lt;li&gt;호스트 모델은 리팩토링하면서 자유로이 변경할 수 있어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;distillation-디스틸레이션&quot;&gt;Distillation (디스틸레이션)&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/distillation.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/distillation.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/distillation.png&quot; class=&quot;zooming&quot; alt=&quot;디스틸레이션 내비게이션 맵&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        디스틸레이션 내비게이션 맵
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;혼합된 요소를 분리하여 본질을 더 값지고 유용한 형태로 뽑아내는 과정
    &lt;ul&gt;
      &lt;li&gt;도메인 지식과 중요한 우선순위를 추상화&lt;/li&gt;
      &lt;li&gt;모델의 산만한 요소를 없애고 중요한 부분에 집중하게 만듦&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;core-domain-핵심-도메인&quot;&gt;Core Domain (핵심 도메인)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션의 목적에 특유하고 &lt;strong&gt;중심적인 모델&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모델을 요약하고 가치 있고 전문화된 개념을 부각&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;심층 모델을 찾고 유연한 설계를 개발할 수 있어야 함
    &lt;ul&gt;
      &lt;li&gt;Core 는 작게 유지해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;generic-subdomain-일반-하위-도메인&quot;&gt;Generic Subdomain (일반 하위 도메인)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;응집력 있는 하위 도메인을 식별하여 별도 module 로 분리
    &lt;ul&gt;
      &lt;li&gt;전문지식을 전달하지 않고 복잡성을 더하는 &lt;strong&gt;부수적인 요소&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;core domain 보다 낮은 우선 순위 부여&lt;/li&gt;
  &lt;li&gt;재사용을 목표로 설계하지 않아도 일반적인 개념의 범위 내에서 설계를 유지하는 것은 엄격해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;domain-vision-statement-도메인-비전-선언문&quot;&gt;Domain Vision Statement (도메인 비전 선언문)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Core Domain 을 짧게 기술하고 해당 모델이 가져올 &lt;strong&gt;가치에 대해 작성한 선언문&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;약 한페이지 분량이 적당&lt;/li&gt;
      &lt;li&gt;새로운 통찰력을 얻을 때마다 개정 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스틸레이션 과정에서 공통적인 방향으로 향하는 이정표가 될 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;highlighted-core-강조된-핵심&quot;&gt;Highlighted Core (강조된 핵심)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;핵심적인 부분&lt;/strong&gt;을 쉽게 파악할 수 있도록 Core Domain 을 더 잘 보이게끔 만드는 과정&lt;/li&gt;
  &lt;li&gt;디스틸레이션 문서 작성 기법
    &lt;ul&gt;
      &lt;li&gt;Core Domain 과 Core 의 구성요소 사이에 일어나는 상호작용 기술&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;표시된 Core 기법
    &lt;ul&gt;
      &lt;li&gt;모델 주요 저장소안에 있는 Core Domain 구성 요소에 대해 역할 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cohesive-mechanism-응집력-있는-메커니즘&quot;&gt;Cohesive Mechanism (응집력 있는 메커니즘)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;응집력이 있는 부분을 뽑아 별도의 경량 프레임워크로 분할해야 함
    &lt;ul&gt;
      &lt;li&gt;프레임워크 기능은 Intention-Revealing Interface 로 노출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Generic Subdomain 과 비슷할 수 있지만 도메인 모델과 섞이지 않아야 함
    &lt;ul&gt;
      &lt;li&gt;Generic Subdomain: 도메인의 일부 측면을 표현하는 모델 (덜 중요한 Core domain)&lt;/li&gt;
      &lt;li&gt;Cohesive Mechanism: 도메인을 나타내지 않고 일부 문제 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;segregated-core-분리된-핵심&quot;&gt;Segregated Core (분리된 핵심)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;보조적인 역할&lt;/strong&gt;로부터 Core의 개념을 분리한 모델&lt;/li&gt;
  &lt;li&gt;일반적이거나 보조적인 역할의 구성요소는 다른 객체로 추출하여 다른 패키지에 배치&lt;/li&gt;
  &lt;li&gt;Core와 다른 코드의 결합도는 감소하고 응집력은 강화됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;abstract-core-추상화된-핵심&quot;&gt;Abstract Core (추상화된 핵심)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;모델의 &lt;strong&gt;근본적인 개념을 식별&lt;/strong&gt;하여 클래스, 추상 클래스, 인터페이스로 추출
    &lt;ul&gt;
      &lt;li&gt;하위 도메인 간에 참조나 상호작용이 많으면 수평적으로 자르는 것을 고려&lt;/li&gt;
      &lt;li&gt;추상 모델은 컴포넌트 간에 발생하는 상호작용을 표현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추상적이고 전체적인 모델은 자체적인 모듈에 배치&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대규모-구조&quot;&gt;대규모 구조&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/large-scale-structure.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/large-scale-structure.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/large-scale-structure.png&quot; class=&quot;zooming&quot; alt=&quot;대규모 구조의 패턴&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        대규모 구조의 패턴
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;시스템을 깊게 파악하지 않아도 각 부분이 담당하는 역할에 대해 이해할 수 있어야 한다.&lt;br /&gt;
대규모 구조는 시스템을 넓은 시각으로 이해하게끔 돕는 언어로  &lt;br /&gt;
전체적인 관점에서 각 부분을 이해하기 위한 규칙이나 패턴을 고려해본다.&lt;/p&gt;

&lt;h4 id=&quot;evolving-order-발전하는-질서&quot;&gt;Evolving Order (발전하는 질서)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;발전 과정에서 전혀 다른 구조로도 유연하게 변화할 수 있어야 함
    &lt;ul&gt;
      &lt;li&gt;설계 및 모델과 관련된 의사결정이 제약되어서는 안됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대규모 구조는 어떤 모델을 개발하는데 부자연스러운 제약조건 없이 명확한 시스템을 만들 수 있을 때 적용해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;system-metaphor-시스템-은유&quot;&gt;System Metaphor (시스템 은유)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;전체 설계의 중심 주제를 전달하고 이해하는 공유할 수 있는 &lt;strong&gt;은유&lt;/strong&gt; (ex. 방화벽)&lt;/li&gt;
  &lt;li&gt;객체 패러다임과 조화를 이루고, 쉽게 이해할 수 있는 대규모 구조&lt;/li&gt;
  &lt;li&gt;구체적인 비유가 유용한 사고를 이끌어 낸다면 대규모 구조로 채택할 수 있음
    &lt;ul&gt;
      &lt;li&gt;의사소통 및 개발 촉진&lt;/li&gt;
      &lt;li&gt;Ubiquitous language 로 흡수될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;responsibility-layer-책임-계층&quot;&gt;Responsibility Layer (책임 계층)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;책임 주도 설계&lt;/strong&gt;와 &lt;strong&gt;계층화&lt;/strong&gt; 원칙이 합쳐친 개념적 계층&lt;/li&gt;
  &lt;li&gt;각 도메인 객체의 책임이 한 계층의 책임안에서 이뤄지는 구조
    &lt;ul&gt;
      &lt;li&gt;응집력 강화&lt;/li&gt;
      &lt;li&gt;모듈의 책임을 쉽게 이해할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;knowledge-level-지식-수준&quot;&gt;Knowledge Level (지식 수준)&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/theory/ddd-terms-summary/knowledge-level.png&quot;&gt;
        &lt;img src=&quot;/images/theory/ddd-terms-summary/knowledge-level.png&quot; data-rjs=&quot;/images/theory/ddd-terms-summary/knowledge-level.png&quot; class=&quot;zooming&quot; alt=&quot;지식 수준&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        지식 수준
        
        (출처: 도메인 주도 설계)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;모델의 &lt;strong&gt;구조와 행위를 서술하고 제약&lt;/strong&gt;하는 데 쓸 수 있는 객체 집합
    &lt;ul&gt;
      &lt;li&gt;Knowledge Level 은 일반 객체로 만들어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델의 특정 부분을 클라이언트에게 제공할 때 생기는 문제를 해결&lt;/li&gt;
  &lt;li&gt;모델에서 자기 규정적(self-defining) 측면을 분리하여 제약 조건을 명시적으로 만듦&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pluggable-component-framework-착탈식-컴포넌트-프레임워크&quot;&gt;Pluggable Component Framework (착탈식 컴포넌트 프레임워크)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;인터페이스와 상호작용에 대한 Abstract Core 를 정제하고 구현을 자유롭게 대체할 수 있는 프레임워크&lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;심층적인 모델이 필요하므로 적용이 힘든 패턴&lt;/li&gt;
      &lt;li&gt;컴포넌트의 프로토콜을 변경하지 않고 Abstract Core 변경 불가 (심층적인 리팩터링이 어려움)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;도메인 주도 설계 소프트웨어의 복잡성을 다루는 지혜 / Eric Evans&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="theory" /><category term="ddd" /><category term="domain-driven-design" /><category term="theory" /><summary type="html">DDD(Domain Driven Design, 도메인 주도 설계) 는 도메인을 중심으로 설계하는 방법론이다. 소프트웨어 개발하면서 방대하고 복잡한 지식으로 인해 어려움이 생기는데, 도메인을 중심으로 설계하면 이 부담을 해소할 수 있다.</summary></entry><entry><title type="html">[Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장</title><link href="https://devyonghee.github.io/study/2022/12/05/operation-system-three-easy-pieces-35-40/" rel="alternate" type="text/html" title="[Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장" /><published>2022-12-05T00:00:00+00:00</published><updated>2022-12-05T00:00:00+00:00</updated><id>https://devyonghee.github.io/study/2022/12/05/operation-system-three-easy-pieces-35-40</id><content type="html" xml:base="https://devyonghee.github.io/study/2022/12/05/operation-system-three-easy-pieces-35-40/">&lt;p&gt;운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.&lt;br /&gt;
이 글에서는 영속성에 대해 다룬 35장부터 40장까지의 내용을 정리한다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;35장-영속성에-관한-대화&quot;&gt;35장. 영속성에 관한 대화&lt;/h2&gt;

&lt;p&gt;컴퓨터가 멈추고 디스크가 고장나고 전원이 꺼져도 정보를 그대로 유지해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;36장-io-장치&quot;&gt;36장. I/O 장치&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;입력/출력 장치(I/O)&lt;/strong&gt; 의 개념과 이 장치가 운영체제와 상호 작용하는 방법을 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;361-시스템-구조&quot;&gt;36.1 시스템 구조&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/simple-system-structure.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/simple-system-structure.png&quot; data-rjs=&quot;/images/study/operating-system/simple-system-structure.png&quot; class=&quot;zooming&quot; alt=&quot;시스템 구조 모형&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        시스템 구조 모형
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;CPU 와 주메모리는 메모리 버스로 연결되어 있다.&lt;br /&gt;
몇몇 장치들은 범용 &lt;strong&gt;I/O 버스&lt;/strong&gt; 에 연결되어 있는데, 현대 시스템에서는 &lt;strong&gt;PCI&lt;/strong&gt; 를 사용한다.
그 아래에는 SCSI, SATA(Serial ATA), USB 와 같은 &lt;strong&gt;주변 장치용 버스&lt;/strong&gt; 가 있고 이를 통해 디스크, 마우스, 키보드 같은 장치가 연결된다.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/modern-system-structure.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/modern-system-structure.png&quot; data-rjs=&quot;/images/study/operating-system/modern-system-structure.png&quot; class=&quot;zooming&quot; alt=&quot;현대식 시스템 구조&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        현대식 시스템 구조
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;현대식 시스템은 칩셋들과 점대점 연결 방식을 늘리고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DMI(Direct Media Interface)
    &lt;ul&gt;
      &lt;li&gt;CPU가 이 기술로 I/O 칩에 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;eSATA(external SATA)
    &lt;ul&gt;
      &lt;li&gt;하드 디스크들이 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ATA(AT attachment, 고급 기술 결합)&lt;/li&gt;
  &lt;li&gt;SATA(Serial ATA)&lt;/li&gt;
  &lt;li&gt;PCIe(Peripheral Component Interconnect Express, 주변 장치 연결 익스프레스)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;362-표준-장치&quot;&gt;36.2 표준 장치&lt;/h3&gt;

&lt;p&gt;가상의 표준 장치를 효율적 활용하기 위한 두 가지 요소가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드웨어 인터페이스 (레지스터 상태, 명령, 데이터)
    &lt;ul&gt;
      &lt;li&gt;인터페이스를 제공하여 시스템 소프트웨어가 동작을 제어할 수 있도록 해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 구조(CPU, 메모리, 하드웨어에 특화된 칩)
    &lt;ul&gt;
      &lt;li&gt;장치의 기능을 추상화하여 시스템 제공하에 목적에 맞게 동작 해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;363-표준-방식&quot;&gt;36.3 표준 방식&lt;/h3&gt;

&lt;p&gt;장치의 인터페이스는 세 개의 레지스터로 구성되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상태(status)&lt;/strong&gt; 레지스터
    &lt;ul&gt;
      &lt;li&gt;장치의 현재 상태를 읽음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명령(command)&lt;/strong&gt; 레지스터
    &lt;ul&gt;
      &lt;li&gt;장치가 데이터를 보내거나 받거나 할 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터(data)&lt;/strong&gt; 레지스터
    &lt;ul&gt;
      &lt;li&gt;장치에 데이터를 보내거나 받거나 할 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장치가 동작을 할 때 다음과 같은 방식을 따른다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;While&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 장치가 바쁜 상태가 아닐 때까지 대기&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;데이터를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;레지스터에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;쓰기&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;명령어를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COMMAND&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;레지스터에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;쓰기&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;장치가&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명령어&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;실행&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;While&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATUS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUSY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 요청을 완료할 때까지 대기        &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;반복적으로 상태 레지스터를 읽어서 명령의 수신 여부 판단 (&lt;strong&gt;polling&lt;/strong&gt; 방식, 비효율적)&lt;/li&gt;
  &lt;li&gt;운영체제가 데이터 레지스터에 데이터 전달 (데이터 전송에 메인 CPU 가 관여하게 되면 &lt;strong&gt;programmed I/O&lt;/strong&gt; 라고 함)&lt;/li&gt;
  &lt;li&gt;운영체제가 명령 레지스터에 명령어 기록&lt;/li&gt;
  &lt;li&gt;디바이스가 처리 완료되었는지 폴링하면서 대기&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;364-인터럽트를-이용한-cpu-오버헤드-개선&quot;&gt;36.4 인터럽트를 이용한 CPU 오버헤드 개선&lt;/h3&gt;

&lt;p&gt;폴링 대신 입출력 작업을 요청한 프로세스를 블록시키고 CPU 를 다른 프로세스에게 양도한다.&lt;br /&gt;
장치가 작업을 끝마치고 나면 하드웨어 인터럽트를 발생시키고 
CPU 는 &lt;strong&gt;인터럽트 서비스 루틴(interrupt service routine, ISR)&lt;/strong&gt; 또는 &lt;strong&gt;인터럽트 핸들러(interrupt handler)&lt;/strong&gt; 를 실행한다.&lt;/p&gt;

&lt;h4 id=&quot;단점&quot;&gt;단점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;문맥 교환 비용 또한 비싸기 때문에 폴링이 빠른 장치라면 폴링 방식이 더 좋을 수 있음
    &lt;ul&gt;
      &lt;li&gt;장치 속도를 모른다면 짧은 시간동안만 폴링 하다가 인터럽트를 사용하는 &lt;strong&gt;하이브리드 방식&lt;/strong&gt; 을 사용하는 것이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인터럽트만 처리하다가 프로세스 요청을 처리할 수 없도록 &lt;strong&gt;무한반복(livelock)&lt;/strong&gt; 에 빠질 수 있음
    &lt;ul&gt;
      &lt;li&gt;폴링을 사용하면 보다 효율적으로 제어할 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;병합(coalescing)&lt;/strong&gt; 기법으로 잠시 기다렸다가 한번만 인터럽트를 발생시키는 방법으로 처리할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;365-dma를-이용한-효율적인-데이터-이동&quot;&gt;36.5 DMA를 이용한 효율적인 데이터 이동&lt;/h3&gt;

&lt;p&gt;많은 양의 데이터를 디스크로 전달하기 위해 prodgrammed I/O(PIO) 를 사용하면 CPU 를 이용하기 때문에 비효율적이다.&lt;br /&gt;
&lt;strong&gt;직접 메모리 접근 방식(Direct Memory Access, DMA)&lt;/strong&gt; 을 사용하면 CPU 간섭없이 메모리와 장치 간에 전송할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;동작-과정&quot;&gt;동작 과정&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;데이터를 장치로 전송한다고 하면 DMA 엔진에 메모리상의 데이터 위치와 전송할 데이터의 크기와 대상 장치를 프로그램&lt;/li&gt;
  &lt;li&gt;이 시점에 운영체제는 다른 작업을 수행&lt;/li&gt;
  &lt;li&gt;DMA 동작이 끝나면 DMA 컨트롤러가 인터럽트를 발생시켜 완료되었다고 알림&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;366-디바이스와-상호작용하는-방법&quot;&gt;36.6 디바이스와 상호작용하는 방법&lt;/h3&gt;

&lt;p&gt;장치와 운영체제가 정보를 교환하는 기본적인 방법 두 가지를 알아본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;I/O&lt;/strong&gt; 명령을 명시적으로 사용
    &lt;ul&gt;
      &lt;li&gt;운영체제가 특정 장치 레지스터에 데이터 전송할 수 있음&lt;/li&gt;
      &lt;li&gt;대부분이 &lt;strong&gt;특권(privileged)&lt;/strong&gt; 명령어 운영체제가 장치를 제어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;맵 입출력(memory mapped I/O)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;장치의 레지스터들이 메모리 상에 존재하는 것처럼 만듦&lt;/li&gt;
      &lt;li&gt;load/store 명령어가 주 메모리 대신 장치로 연결되도록 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;367-운영체제에-연결하기-디바이스-드라이버&quot;&gt;36.7 운영체제에 연결하기: 디바이스 드라이버&lt;/h3&gt;

&lt;p&gt;서로 다른 인터페이스를 가진 장치들과 운영체제를 연결시키는 방법으로 &lt;strong&gt;추상화(abstraction)&lt;/strong&gt; 가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;디바이스 드라이버(device driver)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;장치의 동작 방식을 알고 있는 운영체제 최하위 계층의 일부 소프트웨어&lt;/li&gt;
      &lt;li&gt;자세한 상호작용은 내부에 있음&lt;/li&gt;
      &lt;li&gt;어떤 장치에도 필요하기 때문에 커널 코드의 대부분을 차지함&lt;/li&gt;
      &lt;li&gt;특정 장치의 특별한 기능을 사용할 수 없을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;37장-하드-디스크-드라이브&quot;&gt;37장. 하드 디스크 드라이브&lt;/h2&gt;

&lt;p&gt;시스템의 영구적인 데이터 저장소로 사용되는 하드 디스크 드라이브에 대해 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;371-인터페이스&quot;&gt;37.1 인터페이스&lt;/h3&gt;

&lt;p&gt;드라이브는 읽고 쓸 수 있는 많은 수의 섹터(512byte 블럭)들로 이루어져있다.&lt;br /&gt;
그래서 디스크를 섹터들의 배열로 볼 수 있으며 드라이브의 &lt;strong&gt;주소 공간&lt;/strong&gt;이 된다.&lt;/p&gt;

&lt;p&gt;많은 파일 시스템들은 한번에 4KB 를 읽거나 쓸 수 있지만,
드라이브는 512byte 쓰기만 &lt;strong&gt;원자성&lt;/strong&gt; 을 보장하기 때문에 일부만 작성될 수 있다. (&lt;strong&gt;찢어 쓰기(torn write)&lt;/strong&gt;)&lt;/p&gt;

&lt;h3 id=&quot;372-기본-구조&quot;&gt;37.2 기본 구조&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;플래터(platter)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;원형의 딱딱한 표면&lt;/li&gt;
      &lt;li&gt;자기적 성질을 변형하여 데이터 지속&lt;/li&gt;
      &lt;li&gt;디스크는 하나 또는 여러 개의 플래터를 갖고 있으며 각각은 2개의 표면(surface) 를 가짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;회전축(spindle)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;플래터들을 고정&lt;/li&gt;
      &lt;li&gt;모터와 연결되어 있어서 플래터를 회전&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;분당 회전수(rotation per minute, RPM)&lt;/strong&gt; 로 측정 되며 보통 7,200 ~ 15,000RPM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트랙(track)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;표면에 동심원을 따라 섹터들 위에 데이터가 부호화되는데 이 동심원 하나를 트랙이라고 함&lt;/li&gt;
      &lt;li&gt;표면에 트랙들이촘촘하게 붙어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디스크 헤드(disk head)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;디스크의 자기적 패턴을 감지하거나 변형을 유도하는 장치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디스크 암(disk arm)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;디스크 헤드를 트랙 위로 움직이는 장치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;373-간단한-디스크-드라이브&quot;&gt;37.3 간단한 디스크 드라이브&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/one-track-disk.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/one-track-disk.png&quot; data-rjs=&quot;/images/study/operating-system/one-track-disk.png&quot; class=&quot;zooming&quot; alt=&quot;트랙 하나와 헤드&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        트랙 하나와 헤드
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;이 트랙에는 12개의 섹터가 있고 각 섹터는 512 byte 크기를 갖고 있다.&lt;br /&gt;
주소 영역은 0 부터 11까지(0 ~ n-1)로 이루어져 있다.&lt;/p&gt;

&lt;h4 id=&quot;단일-트랙-지연-시간-회전-지연&quot;&gt;단일 트랙 지연 시간: 회전 지연&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;회전형 지연(rotational delay)&lt;/strong&gt; 또는 &lt;strong&gt;회전 지연(rotation delay)&lt;/strong&gt; 은 디스크 헤드 아래에 원하는 섹터가 위치할 때까지 기다리는 것을 의미한다.&lt;/p&gt;

&lt;h4 id=&quot;멀티-트랙-탐색-시간&quot;&gt;멀티 트랙: 탐색 시간&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/disk-track-seek.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/disk-track-seek.png&quot; data-rjs=&quot;/images/study/operating-system/disk-track-seek.png&quot; class=&quot;zooming&quot; alt=&quot;탐색을 포함한 트랙과 헤드&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        탐색을 포함한 트랙과 헤드
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;탐색(seek)&lt;/strong&gt; 은 읽기 요청을 처리하기 위해 드라이브를 디스크 암을 올바른 트랙 위에 위치시키는 과정니다.
탐색은 여러 단계로 이루어져 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가속 단계: 디스크의 암이 움직이기 시작&lt;/li&gt;
  &lt;li&gt;활주 단계: 디스크 암이 최고 속도로 움직이는 단계&lt;/li&gt;
  &lt;li&gt;감속 단계: 디스크 암의 속도가 줄어드는 단계&lt;/li&gt;
  &lt;li&gt;안정화 단계: 정확한 트랙 위에 위치하는 단계 (&lt;strong&gt;안정화 시간(settling time)&lt;/strong&gt; 이 중요, 보통 0.5 ~ 2msec)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;그-외의-세부사항&quot;&gt;그 외의 세부사항&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/disk-track-skew.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/disk-track-skew.png&quot; data-rjs=&quot;/images/study/operating-system/disk-track-skew.png&quot; class=&quot;zooming&quot; alt=&quot;트랙 스큐&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        트랙 스큐
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;트랙 비틀림(track skew)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;트랙의 경계를 지나 순차적으로 존재하는 섹터들을 읽을 수 있는 기술&lt;/li&gt;
      &lt;li&gt;트랙으로 넘어갈 때 읽어야 할 블럭을 놓치지 않고 읽을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;멀티 구역(multi-zoned)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;디스크 드라이브는 바깥 측 트랙들이 안쪽 트랙들보다 많은 섹터들이 있는 트랙&lt;/li&gt;
      &lt;li&gt;여러 구역으로 나뉘어 있으며 한 구역은 연속적으로 존재하는 트랙들의 집합&lt;/li&gt;
      &lt;li&gt;각 구역 내의 트랙은 같은 수의 섹터들을 포함하고 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;캐시(cache)&lt;/strong&gt; 또는 &lt;strong&gt;트랙 버퍼(track buffer)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;일반적으로 8 또는 16MB 정도 크기의 메모리&lt;/li&gt;
      &lt;li&gt;드라이브가 디스크에서 읽거나 쓴 데이터를 보관하는 데 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쓰기 요청의 완료 보고
    &lt;ul&gt;
      &lt;li&gt;write-back 캐싱(즉시 보고(immediate reporting)): 메모리에 데이터가 기록된 시점에 쓰기가 완료되었다고 보고
        &lt;ul&gt;
          &lt;li&gt;빠르게 보일 수 있지만 위험할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;write-through: 디스크에 실제로 기록된 시점에 쓰기가 완료되었다고 보고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;374-io-시간-계산&quot;&gt;37.4 I/O 시간 계산&lt;/h3&gt;

&lt;p&gt;I/O 시간을 나타내는 식&lt;/p&gt;

&lt;p&gt;T&lt;sub&gt;I/O&lt;/sub&gt; = T&lt;sub&gt;seek&lt;/sub&gt; + T&lt;sub&gt;rotation&lt;/sub&gt; + T&lt;sub&gt;transfer&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;I/O 속도(rate, R&lt;sub&gt;I/O&lt;/sub&gt;)를 나타내는 식&lt;/p&gt;

&lt;p&gt;R&lt;sub&gt;I/O&lt;/sub&gt; = Size&lt;sub&gt;Transfer&lt;/sub&gt; / T&lt;sub&gt;I/O&lt;/sub&gt;&lt;/p&gt;

&lt;h3 id=&quot;375-디스크-스케줄링&quot;&gt;37.5 디스크 스케줄링&lt;/h3&gt;

&lt;p&gt;운영체제가 디스크에게 I/O 요청을 하면 &lt;strong&gt;디스크 스케줄러&lt;/strong&gt;는 다음에 어떤 I/O를 처리할 지 결정한다.&lt;br /&gt;
디스크 스케줄링은 요청 작업이 얼마나 길지 예측이 가능하기 때문에 &lt;strong&gt;SFJ(shotest job first, 짧은 작업 우선)&lt;/strong&gt; 원칙을 따르려고 한다.&lt;/p&gt;

&lt;h4 id=&quot;sstf-최단-탐색-시간-우선&quot;&gt;SSTF: 최단 탐색 시간 우선&lt;/h4&gt;

&lt;p&gt;초기 디스크 스케줄링은 &lt;strong&gt;최단 탐색 시간 우선(shortest seek time first, SSTF)&lt;/strong&gt; (또는 &lt;strong&gt;최단 탐색 우선(shortest-seek-first, SSF)&lt;/strong&gt; 이라고도 불림) 을 사용했다.&lt;br /&gt;
SSTF 는 트랙을 기준으로 I/O 요청 큐를 정렬하여 가까운 트랙의 요청을 먼저 처리한다.&lt;/p&gt;

&lt;h6 id=&quot;문제점&quot;&gt;문제점&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;드라이브의 구조는 호스트 운영체제에게 공개되어 있지 않고 운영체제는 블럭들의 배열로 인식하는 문제
    &lt;ul&gt;
      &lt;li&gt;이 문제를 해결하기 위해 운영체제는 SSTF 대신 &lt;strong&gt;가장 가까운 블럭 우선(Nearest-block-first, NBF)&lt;/strong&gt; 방식을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기아 현상(starvation)
    &lt;ul&gt;
      &lt;li&gt;다른 트랙에 있는 요청들이 무시될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;엘리베이터scan-또는-c-scan-이라고-함&quot;&gt;엘리베이터(SCAN 또는 C-SCAN 이라고 함)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SCAN&lt;/strong&gt; 알고리즘
    &lt;ul&gt;
      &lt;li&gt;트랙의 순서에 따라 디스크를 앞뒤로 가로지르며(스위프(sweep)) 요청을 서비스&lt;/li&gt;
      &lt;li&gt;가까운 층이 아닌 위, 아래로 이동하는 엘리페이터와 같다하여 엘리페이터 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;F-SCAN&lt;/strong&gt; 알고리즘
    &lt;ul&gt;
      &lt;li&gt;스위프하는 동안에 큐를 동결&lt;/li&gt;
      &lt;li&gt;늦게 도착한 요청들의 처리를 지연시켜 요청에 대한 기아 현상을 없앰&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;C-SCAN&lt;/strong&gt; 알고리즘 (Circular SCAN)
    &lt;ul&gt;
      &lt;li&gt;스위프하는 방향이 양 방향이 아닌, 밖에서 안으로만 스위프&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;문제점-1&quot;&gt;문제점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;SJF 원칙을 지키기 위해 최선을 다하지 않음 (회전 무시)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sptf-최단-위치-잡기-우선&quot;&gt;SPTF: 최단 위치 잡기 우선&lt;/h4&gt;

&lt;p&gt;디스크 회전 비용을 고려하기 위해
&lt;strong&gt;최단 위치 잡기 우선(shortest positioning time first, SPTF)&lt;/strong&gt; (또는 &lt;strong&gt;최단 접근 시간 우선(shortest access time first, SATF)&lt;/strong&gt;) 을 이용한다.&lt;/p&gt;

&lt;p&gt;탐색과 회전에 걸리는 시간이 다르기 때문에 상황에 따라 다음 차례가 달라진다.&lt;br /&gt;
SPTF가 유용하고 성능을 개선할 수 있다. &lt;br /&gt;
하지만 운영체제가 트랙의 경계 또는 디스크 헤드가 어디있는지 알 수 없기 때문에 드라이브 내부에서 실행된다.&lt;/p&gt;

&lt;h4 id=&quot;다른-스케줄링-쟁점들&quot;&gt;다른 스케줄링 쟁점들&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;디스크는 상세한 트랙 배치 정보와 헤드의 위치 정보로 최선의 순서(SPTF)로 정렬&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;I/O 병합(I/O merging)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;디스크로 내려보내는 요청의 개수를 줄여 오버헤드 감소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;작업 보전(work-conserving)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;디스크가 유휴 상태가 되지 않도록 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;작업 비보전(non-work-conserving)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;예측 디스크 스케줄링(anticipatory disk scheduling)&lt;/strong&gt; 으로 잠시 기다리는 것이 더 좋을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;38장-redundant-array-of-inexpensive-disks-raid&quot;&gt;38장. Redundant Array of Inexpensive Disks (RAID)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redundant Array of Inexpensive Disks&lt;/strong&gt; 또는 RAID 로 알려진 기술에 대해 알아본다.&lt;br /&gt;
이 기술은 고속이면서 대용량의 디스크 시스템을 만든다.&lt;/p&gt;

&lt;p&gt;RAID 는 하나의 디스크처럼 보이지만 내부에는 여러 개의 디스크와 메모리, 시스템을 관리하기 위한 프로세서들로 이루어져있다.&lt;br /&gt;
RAID 하드웨어는 컴퓨터 시스템과 유사하며 디스크의 그룹을 관리하기 위한 시스템이다.&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;p&gt;RAID 는 장점들을 투명하게 제공하여 확산력(deployability)을 개선 시켰다.&lt;br /&gt;
사용자와 관리자가 소프트웨어 호환성을 걱정하지 않고 사용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;디스크 여러 개를 병렬적으로 사용하여 I/O 시간 개선&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;용량
    &lt;ul&gt;
      &lt;li&gt;많은 디스크 공간으로 데이터 양이 많음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신뢰성
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;데이터 중복 기술(redundancy)&lt;/strong&gt; 으로 디스크 한 개의 고장 감내 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;381-인터페이스와-raid-의-내부&quot;&gt;38.1 인터페이스와 RAID 의 내부&lt;/h3&gt;

&lt;p&gt;RAID 도 선형적인 블럭들의 배열로 보이며 파일 시스템이 각 블럭을 읽거나 쓸 수 있다.&lt;br /&gt;
파일 시스템이 논리적 I/O 요청을 하면 내부에서 요청 가능한 디스크를 계산하고 물리적으로 I/O 를 발생시킨다. (2개의 복사본을 유지한다면 두 번 물리적 I/O 실행)&lt;/p&gt;

&lt;h3 id=&quot;382-결함-모델&quot;&gt;38.2 결함 모델&lt;/h3&gt;

&lt;p&gt;RAID 는 특정 종류의 결함을 파악하고 복구하도록 설계되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;고장시 멈춤(fail-stop)&lt;/strong&gt; 결함 모델
    &lt;ul&gt;
      &lt;li&gt;“정상 작동” 이거나 “멈춤” 상태로 있다고 가정&lt;/li&gt;
      &lt;li&gt;동작 중인 디스크에 모든 블럭을 읽거나 쓸 수 있음&lt;/li&gt;
      &lt;li&gt;멈춤 상태의 디스크는 완전히 사용 불가능&lt;/li&gt;
      &lt;li&gt;디스크가 고장나면 쉽게 파악할 수 있다고 가정한다는 것이 단점&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;383-raid-의-평가-방법&quot;&gt;38.3 RAID 의 평가 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;용량
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 사용할 수 있는 유효 용량 평가&lt;/li&gt;
      &lt;li&gt;중복 저장이 없다면 N*B&lt;/li&gt;
      &lt;li&gt;두 개의 복사본을 갖는다면 (N*B)/2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신뢰성
    &lt;ul&gt;
      &lt;li&gt;몇 개의 디스크 결함을 감내할 수 있는지 평가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;워크로드에 따라 크게 달라지기 때문에 평가가 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;384-raid-레벨-0-스트라이핑&quot;&gt;38.4 RAID 레벨 0: 스트라이핑&lt;/h3&gt;

&lt;p&gt;RAID 레벨 0 또는 &lt;strong&gt;스트라이핑(striping)&lt;/strong&gt; 방식은 성능과 용량에 대한 훌륭한 상한 기준을 나타낸다.&lt;br /&gt;
이 방식은 블럭들을 여러 디스크에 걸쳐 줄을 긋는 것 처럼 저장한다. (중복 저장을 하지 않음)&lt;/p&gt;

&lt;p&gt;디스크 배열의 블럭들을 라운드 로빈 방식으로 디스크를 가로질러 펼친다.&lt;br /&gt;
연속적인 청크에 대해 요청을 받았을 때 병렬성을 가장 잘 활용하도록 설계되었다.&lt;br /&gt;
같은 행에 있는 블럭들은 &lt;strong&gt;스트라이프(stripe)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크0&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;청크-크기&quot;&gt;청크 크기&lt;/h4&gt;

&lt;p&gt;청크 크기는 RAID 성능에 영향을 준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;작은 청크 크기
    &lt;ul&gt;
      &lt;li&gt;많은 파일들이 여러 디스크에 걸쳐 스트라이프 되어 병렬성이 증가&lt;/li&gt;
      &lt;li&gt;여러 디스크에서 찾아 블럭 위치를 찾아야 하므로 찾는데 오래 걸림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;큰 청크 크기
    &lt;ul&gt;
      &lt;li&gt;병렬성이 감소되어 처리 성능을 높이기 위해서는 여러 요청을 병행하게 실행해야 함&lt;/li&gt;
      &lt;li&gt;위치 찾는 시간 감소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;raid-0-분석으로-돌아가서&quot;&gt;RAID-0 분석으로 돌아가서&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;유효 용량
    &lt;ul&gt;
      &lt;li&gt;B 개의 블럭을 갖는 N개의 디스크라면 N*B 만큼의 유효 용량&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신뢰성
    &lt;ul&gt;
      &lt;li&gt;어느 디스크라도 고장나면 전체 디스크 손실&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;병렬로 사용자 I/O 요청 처리가 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;raid-0-의-성능&quot;&gt;RAID-0 의 성능&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;단일 요청의 지연시간
    &lt;ul&gt;
      &lt;li&gt;한 블럭과 디스크에 대한 요청의 지연 시간은 거의 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RAID 의 정상 상태(steady state) 에서의 처리 성능(throughput)
    &lt;ul&gt;
      &lt;li&gt;최대 대역폭 기대 가능&lt;/li&gt;
      &lt;li&gt;처리성능은 N(디스크 수) * S(디스크 하나의 순차 접근 대역폭) 와 같음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;385-raid-레벨-1-미러링&quot;&gt;38.5 RAID 레벨 1: 미러링&lt;/h3&gt;

&lt;p&gt;첫 번째 RAID 레벨은 RAID 레벨 1 또는 미러링으로 불린다.&lt;br /&gt;
각 블럭에 대해 하나 이상의 사본을 둬서 디스크 고장에 대처한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크0&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 방식은 일반적으로 미러링(RAID-1)을 스트라이핑(RAID-0) 하기 때문에 RAID-10 또는 RAID 1+0 이라고 한다.&lt;/p&gt;

&lt;h4 id=&quot;raid-1-분석&quot;&gt;RAID-1 분석&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;용량
    &lt;ul&gt;
      &lt;li&gt;비용이 많이 듦&lt;/li&gt;
      &lt;li&gt;미러링 레벨이 2라면 최대 사용 가능한 용량의 반만 사용 가능 (N*B)/2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신뢰성
    &lt;ul&gt;
      &lt;li&gt;디스크 중 고장이 발생해도 감내 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;단일 읽기는 단일 디스크에서 읽는 요청의 지연 시간과 동일&lt;/li&gt;
      &lt;li&gt;쓰기의 경우 병렬적으로 이루어지지만, 물리적으로 두 개의 쓰기가 연산되어야 하므로 최악의 탐색과 회전 지연시간에 의해 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;처리 성능
    &lt;ul&gt;
      &lt;li&gt;순차 쓰기의 경우 N/2 * S 또는 최대 대역폭의 절반의 대역폭&lt;/li&gt;
      &lt;li&gt;순차 읽기 상황도 N/2 * S 으로 동일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;386-raid-레벨-4-패리티를-이용한-공간-절약&quot;&gt;38.6 RAID 레벨 4: 패리티를 이용한 공간 절약&lt;/h4&gt;

&lt;p&gt;패리티 기반의 접근 방법은 저장 공간을 적게 사용하여 미러링 기반 시스템의 공간 낭비를 극복하고자 한다.&lt;br /&gt;
하지만 성능 저하가 발생될 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크0&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;스트라이프마다 중복 정보를 담고 있는 패리티 블럭을 추가한다.
블럭 P1 은 블럭 4,5,6 과 7번으로부터 계산된 중복 정보를 가지고 있다.&lt;br /&gt;
고장난 디스크로부터 데이터를 복구하기 위해서는 스 행의 모든 값을 읽은 후 패리티를 통해 올바른 값을 &lt;strong&gt;다시 계산&lt;/strong&gt; 한다.&lt;/p&gt;

&lt;h4 id=&quot;raid-4-분석&quot;&gt;RAID-4 분석&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;용량
    &lt;ul&gt;
      &lt;li&gt;디스크 하나를 패리티 정보 저장에 사용하기 때문에 (N-1)*B&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신뢰성
    &lt;ul&gt;
      &lt;li&gt;하나만의 디스크 고장 감내 가능&lt;/li&gt;
      &lt;li&gt;두 개 이상의 고장은 복원 불가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;순차 읽기의 경우 최대 유효한 대역폭은 (N-1)*S MB/s&lt;/li&gt;
      &lt;li&gt;순차 쓰기의 경우 스프라이프 전부 쓰기가 가장 효율적인 방법이므로 (N-1)*S MB/s&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;특정-블럭과-함께-패리티-블럭을-갱신하는-정확하고-효율적인-두-가지-방법&quot;&gt;특정 블럭과 함께 패리티 블럭을 갱신하는 정확하고 효율적인 두 가지 방법&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가산적 패리티(additive parity)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;스트라이프 내의 다른 모든 블록을 병렬로 읽고 새로운 블럭과 함께 갱신&lt;/li&gt;
      &lt;li&gt;디스크의 개수에 따라 계산의 양이 다르기 때문에 많은 수의 읽기 연산이 필요해질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;감산적 패리티(subtractive parity)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;갱신 하고자 하는 블록과 패리티 값을 읽음 (동일하면 그대로 유지)&lt;/li&gt;
      &lt;li&gt;이전의 패리티 비트를 현재 상태의 반대 값으로 뒤집어서 처리&lt;/li&gt;
      &lt;li&gt;P&lt;sub&gt;new&lt;/sub&gt; = (C&lt;sub&gt;old&lt;/sub&gt; ⊕ C&lt;sub&gt;new&lt;/sub&gt;) ⊕ P&lt;sub&gt;old&lt;/sub&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;문제점-2&quot;&gt;문제점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;small-write 문제&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쓰기가 동시에 요청되면 패리티 디스크는 병목으로 작용&lt;/li&gt;
      &lt;li&gt;패리티 디스크로 인해 순차적으로 실행되어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;387-raid-레벨-5-순환-패리티&quot;&gt;38.7 RAID 레벨 5: 순환 패리티&lt;/h3&gt;

&lt;p&gt;RAID-5 는 RAID-4 와 거의 동일하게 동작하지만 패리티 블럭을 &lt;strong&gt;순환(rotate)&lt;/strong&gt; 하여 small-write 문제를 해결한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크0&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크2&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크3&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;디스크4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;17&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;18&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;raid-5-분석&quot;&gt;RAID-5 분석&lt;/h4&gt;

&lt;p&gt;많은 부분은 RAID-4와 동일하다.&lt;br /&gt;
모든 디스크를 활용할 수 있기 때문에 랜덤 읽기 성능이 약간 더 좋다.&lt;br /&gt;
RAID-5 성능이 거의 RAID-4와 동일하기 때문에 RAID-5로 완전히 대체되었다.&lt;/p&gt;

&lt;h3 id=&quot;385-raid-비교-정리&quot;&gt;38.5 RAID 비교: 정리&lt;/h3&gt;

&lt;p&gt;성능만을 원하고 신뢰성을 고려하지 않는다면 스트라이핑&lt;br /&gt;
임의 I/O 성능과 신뢰성을 원한다면 미러링&lt;br /&gt;
순차 I/O 만 사용하거나 용량과 신뢰성이 목적이라면 RAID-5&lt;/p&gt;

&lt;h3 id=&quot;389-raid-와-관련된-다른-흥미로운-주제들&quot;&gt;38.9 RAID 와 관련된 다른 흥미로운 주제들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;디스크가 고장났을 때 &lt;strong&gt;대체용 스페어(hot spare)&lt;/strong&gt; 로 고장난 디스크를 대신하는 방법도 있음&lt;/li&gt;
  &lt;li&gt;잠재된 섹터 오류(latent sector error) 또는 블럭 훼손(block corruption) 을 고려한 모델들도 있음&lt;/li&gt;
  &lt;li&gt;소프트웨어 레이어로 RAID(&lt;strong&gt;소프트웨어 RAID&lt;/strong&gt;) 구성도 가능.
    &lt;ul&gt;
      &lt;li&gt;저렴하지만 일관성-유지 등의 문제 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;39장-막간-파일과-디렉터리&quot;&gt;39장. 막간: 파일과 디렉터리&lt;/h2&gt;

&lt;p&gt;이번 장에서는 &lt;strong&gt;하드 디스크 드라이브&lt;/strong&gt; 또는 &lt;strong&gt;솔리드 스테이트 드라이브(Solid-state storage, SSD)&lt;/strong&gt; 와 같은 &lt;strong&gt;영속 저장 장치(persistent storage)&lt;/strong&gt; 개념을 다룬다.&lt;br /&gt;
영속 보존 장치는 전원 공급이 차단되어도 데이터를 그대로 보존한다.&lt;/p&gt;

&lt;h3 id=&quot;391-파일과-디렉터리&quot;&gt;39.1 파일과 디렉터리&lt;/h3&gt;

&lt;h4 id=&quot;파일&quot;&gt;파일&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;읽거나 쓸 수 있는 순차적인 바이트의 배열&lt;/li&gt;
  &lt;li&gt;각 파일은 &lt;strong&gt;저수준 이름(low-level name)&lt;/strong&gt; 을 가지고 있음&lt;/li&gt;
  &lt;li&gt;저수준 이름을 &lt;strong&gt;아이노드 번호(inode number)&lt;/strong&gt;  라고 함&lt;/li&gt;
  &lt;li&gt;각 파일은 아이노드 번호와 연결되어 있음&lt;/li&gt;
  &lt;li&gt;운영 체제는 파일의 구조를 모르고 파일 시스템이 데이터를 디스크에 저장하고 돌려주는 역할을 함&lt;/li&gt;
  &lt;li&gt;파일의 종류를 나타내는 확장자는 &lt;strong&gt;관용적(convention)&lt;/strong&gt; 일뿐 반드시 지킬 필요는 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;디렉터리&quot;&gt;디렉터리&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;파일와 마찬가지로 저수준의 이름(아이노 번호드)를 가짐&lt;/li&gt;
  &lt;li&gt;&amp;lt;사용자가 읽을 수 있는 이름, 저수준의 이름&amp;gt; 쌍으로 이루어진 목록을 가짐
    &lt;ul&gt;
      &lt;li&gt;각 항목은 파일 또는 다른 디렉터리를 가리킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디렉터리내에 디렉터리를 포함하여, &lt;strong&gt;디렉터리 트리(directory tree&lt;/strong&gt;, 또는 &lt;strong&gt;디렉터리 계층(directory hierarchy)&lt;/strong&gt;) 구성&lt;/li&gt;
  &lt;li&gt;디렉터리 계층은 &lt;strong&gt;루트 디렉터리(root directory)&lt;/strong&gt; 부터 시작&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구분자(separator)&lt;/strong&gt; 를 사용하여 &lt;strong&gt;하위 디렉터리&lt;/strong&gt; 명시&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/directory-tree.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/directory-tree.png&quot; data-rjs=&quot;/images/study/operating-system/directory-tree.png&quot; class=&quot;zooming&quot; alt=&quot;디렉터리 트리의 예제&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        디렉터리 트리의 예제
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;h3 id=&quot;392-파일-시스템-인터페이스&quot;&gt;39.2 파일 시스템 인터페이스&lt;/h3&gt;

&lt;p&gt;파일의 생성, 접근, 삭제 등의 인터페이스를 다뤄본다.&lt;/p&gt;

&lt;h3 id=&quot;393-파일의-생성&quot;&gt;39.3 파일의 생성&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_CREATE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_WRONLY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_TRUNC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_IRUSR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_IWUSR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open&lt;/code&gt; 시스템 콜로 파일 생성할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O_CREATE&lt;/code&gt;: 파일이 없으면 생성&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O_WRONLY&lt;/code&gt;: 쓰기 전용&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O_TRUNC&lt;/code&gt;: 파일의 크기를 0byte 줄여서 내용 삭제&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_IRUSR | S_IWUSR&lt;/code&gt;: 소유자만 읽기, 쓰기 권한 설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일 디스크립터(file descriptor)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt; 의 반환 값&lt;/li&gt;
      &lt;li&gt;프로세스마다 존재하는 정수로 파일을 접근하는 데 사용 (권한 필요)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 등의 메소드로 파일 접근 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;394-파일의-읽기와-쓰기&quot;&gt;39.4 파일의 읽기와 쓰기&lt;/h3&gt;

&lt;p&gt;프로그램이 호출하는 시스템 콜을 추적하는 Linux 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace&lt;/code&gt; 를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt; 동작을 살펴본다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일을 읽기 전용으로 열기 (표준 입력(0), 출력(1), 에러 파일(2) 디스크립터가 열기기 때문에 반환값이 3)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 시스템 콜로 파일에서 반복적으로 읽음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 시스템 콜에서 표준 출력(STDOUT) 하기 위해 파일 디스크립터 1 사용 (화면 출력)&lt;/li&gt;
  &lt;li&gt;파일 내용을 더 읽으려고 시도 (남은 바이트가 없어서 0 반환)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 로 파일 할 일 끝남&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prompt&amp;gt; strace &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;foo
...
open&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;, O_RDONLY | O_LARGEFILE&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 3
&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3, &lt;span class=&quot;s2&quot;&gt;&quot;hello&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, 4096&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 6
write&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1, &lt;span class=&quot;s2&quot;&gt;&quot;hello&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, 6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 6
hello
&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3, &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;, 4096&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
close&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;395-비-순차적-읽기와-쓰기&quot;&gt;39.5 비 순차적 읽기와 쓰기&lt;/h3&gt;

&lt;p&gt;파일의 임의의 오프셋부터 읽거나 써야 할 때가 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lseek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fildes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fildes&lt;/code&gt;: 파일 디스크립터&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset&lt;/code&gt;: 오프셋&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whence&lt;/code&gt;: 탐색 방식 결정
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEEK_SET&lt;/code&gt;: 오프셋은 offset 바이트로 설정&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEEK_CUR&lt;/code&gt;: 현재 위치에 offset 바이트를 더한 값으로 설정&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEEK_END&lt;/code&gt;: 파일의 크기에 offset 바이트를 더한 값으로 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;396-공유하는-파일-테이블의-요소들-fork-와-dup&quot;&gt;39.6 공유하는 파일 테이블의 요소들: fork() 와 dup()&lt;/h3&gt;

&lt;p&gt;각 프로세스는 개별적인 열린 파일 테이블의 요소를 다룬다.&lt;br /&gt;
같은 파일에 대한 논리적 읽기와 쓰기는 독립적이며 개별적인 현재 오프셋을 관리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;부모 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 으로 자식 프로세스를 생성하면 파일 테이블은 공유&lt;/li&gt;
      &lt;li&gt;파일 테이블의 요소가 공유되면 &lt;strong&gt;참조 횟수(reference count)&lt;/strong&gt; 가 증가&lt;/li&gt;
      &lt;li&gt;부모 자식 프로세스가 모두 종료되어야 요소들 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dup()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;이미 열려있는 파일의 디스크립터를 참조하는 새로운 파일 디스크립터 생성&lt;/li&gt;
      &lt;li&gt;유닉스 쉘과 출력 재지향하는 경우에 유용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;397-fsync-를-이용한-즉시-기록&quot;&gt;39.7 fsync() 를 이용한 즉시 기록&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;영속 저장 장치에 기록 해달라고 파일 시스템에 요청&lt;/li&gt;
      &lt;li&gt;파일 시스템에서 성능을 위해 메모리에 모은 후 (버퍼링) 처리&lt;/li&gt;
      &lt;li&gt;데이터가 유실되는 경우가 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;파일 시스템이 지정된 파일의 &lt;strong&gt;더티(갱신된)&lt;/strong&gt; 데이터를 디스크에 강제로 기록&lt;/li&gt;
      &lt;li&gt;쓰기들이 처리되면 리턴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;398-파일-이름-생성&quot;&gt;39.8 파일 이름 생성&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;rename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;시스템 크래시에 대해 &lt;strong&gt;원자적&lt;/strong&gt; 으로 구현되어 있음 (중간 상태가 없음)&lt;/p&gt;

&lt;h3 id=&quot;399-파일-정보-추출&quot;&gt;39.9 파일 정보 추출&lt;/h3&gt;

&lt;p&gt;파일에 대한 정보를 &lt;strong&gt;메타데이터(metadata)&lt;/strong&gt; 라고 한다.
메타데이터를 보려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stat()&lt;/code&gt; 이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fstat()&lt;/code&gt; 를 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dev_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 파일이 있는 장치의 ID&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ino_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_ino&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 아이노드 번호&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mode_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 보호&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nlink_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_nlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 하드링크 수&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_uid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 소유자의 사용자 ID&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_gid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 소유자의 그룹 ID&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dev_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_rdev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 장치 ID (특수 파일인 경우)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 파일 크기 (바이트)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;blksize_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_blksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 파일 시스템 입출력의 블록 크기&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;blkcnt_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_blocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 할당된 블록 수&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;time_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_atime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 최종 접근 시간&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;time_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_mtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 최종 갱신 시간&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;time_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 최종 상태 변경 시간&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3910-파일-삭제&quot;&gt;39.10 파일 삭제&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prompt&amp;gt; strace &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;foo
...
&lt;span class=&quot;nb&quot;&gt;unlink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlink()&lt;/code&gt; 시스템 콜에서는 파일 이름을 인자로 받아서 성공하면 0 리턴&lt;/p&gt;

&lt;h3 id=&quot;3911-디렉터리-생성&quot;&gt;39.11 디렉터리 생성&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mkdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;0777&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkdir()&lt;/code&gt; 시스템 콜로 디렉터리 생성한다.
디렉터리에는 자신을 나타내는 “.”(dot) 디렉터리, 부모 디렉터리를 가리키는 “..”(dot-dot) 디렉터리가 있다.&lt;/p&gt;

&lt;h3 id=&quot;3912-디렉터리-읽기&quot;&gt;39.12 디렉터리 읽기&lt;/h3&gt;

&lt;p&gt;디렉터리를 읽는 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt; 프로그램이다.&lt;br /&gt;
이 프로그램은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opendir()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readdir()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closedir()&lt;/code&gt; 시스템콜을 사용한다.&lt;br /&gt;
반복문으로 디렉터리 항목을 읽고 이름과 아이노드 번호를 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-l&lt;/code&gt; 플래그를 추가하면 파일 크기 같은 추가 정보를 얻기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stat()&lt;/code&gt; 을 호출한다.&lt;/p&gt;

&lt;h3 id=&quot;3913-디렉터리-삭제하기&quot;&gt;39.13 디렉터리 삭제하기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmdir()&lt;/code&gt; 시스템 콜로 디렉터리를 삭제한다.&lt;br /&gt;
비어있지 않은 디렉터리에 대해 호출하면 실패한다.&lt;/p&gt;

&lt;h3 id=&quot;3914-하드-링크&quot;&gt;39.14 하드 링크&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;link()&lt;/code&gt; 시스템 콜은 원래의 경로명과 새로운 경로명을 인자로 받는다.&lt;br /&gt;
원래 파일 이름에 새로운 이름을 link 하면 동일한 파일을 접근할 수 있는 새로운 방법을 만든다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;hello &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file
prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file
hello
prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;ln &lt;/span&gt;file file2
prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file2
hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 하드 링크를 생성하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file2&lt;/code&gt; 으로 읽을 수 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;link()&lt;/code&gt; 는 새롭게 링크하려는 이름 항목을 디렉터리에 생성하고, 원래 파일과 같은 아이노드 번호를 가리킨다. (복사되지 않음)
여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlink()&lt;/code&gt; 로 한 파일을 삭제해도 다른 이름으로 파일 접근이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlink()&lt;/code&gt; 는 아이노드 번호의 &lt;strong&gt;참조 횟수(reference count)&lt;/strong&gt; 를 검사하고 참조 횟수를 줄이는데,  &lt;br /&gt;
참조 횟수가 0 되면 파일 시스템은 데이터 블럭을 해제하여 파일을 진정으로 삭제한다.&lt;/p&gt;

&lt;h3 id=&quot;3915-심볼릭-링크&quot;&gt;39.15 심볼릭 링크&lt;/h3&gt;

&lt;p&gt;하드 링크는 디렉터리에 대해 사용 불가, 다른 디스크 파티션에 있는 파일 링크 불가 등의 제한이 있다.&lt;br /&gt;
&lt;strong&gt;심볼릭 링크(symbolic link)&lt;/strong&gt; 또는 &lt;strong&gt;소프트 링크(soft link)&lt;/strong&gt; 는 이런 경우 유용하게 사용할 수 있는 링크다.&lt;br /&gt;
심볼릭 링크를 생성하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln&lt;/code&gt; 프로그램에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-s&lt;/code&gt; 플래그를 추가하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;hello &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file
prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; file file2
prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file2
hello

prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-al&lt;/span&gt;
drwxr-x---  2 remzi remzi   29 May 3 19:10 ./
drwxr-x--- 27 remzi remzi 4096 May 3 19:10 ../
&lt;span class=&quot;nt&quot;&gt;-rw-r-----&lt;/span&gt;  1 remzi remzi    6 May 3 19:10 file
lrwxr-x---  1 remzi remzi    4 May 3 19:10 file2 -&amp;gt; file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file2&lt;/code&gt; 모두 접근이 가능하다.  &lt;br /&gt;
하드 링크와 유사해보이지만 다음과 같은 차이가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;심볼릭 링크는 다른 형식의 독립된 파일 (파일, 디렉터리와 다름)
    &lt;ul&gt;
      &lt;li&gt;소프트 링크 가장 왼쪽에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; 이 표시&lt;/li&gt;
      &lt;li&gt;링크한 대상의 파일이 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;심볼릭 링크의 크기는 파일의 경로명 길이&lt;/li&gt;
  &lt;li&gt;원래 파일을 삭제하면 심볼릭 링크가 가리키는 실제 파일도 삭제됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3916-권한-비트와-접근-제어-목록&quot;&gt;39.16 권한 비트와 접근 제어 목록&lt;/h3&gt;

&lt;p&gt;파일 시스템은 디스크에 대한 가상화를 제공하여 디스크상의 블럭들을 파일과 디렉터리로 변환한다.&lt;br /&gt;
하지만 파일은 다수의 사용나자 프로세스들이 공유하므로 파일 시스템은 공유범위를 한정하는 기법들도 제공한다.&lt;/p&gt;

&lt;h4 id=&quot;권한-비트permisision-bits&quot;&gt;권한 비트(permisision bits)&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prompt&amp;gt; &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; foo.txt
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 remzi remzi 0 May 3 19:10 foo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-rw-r--r--&lt;/code&gt; 은 에서 첫 번째 글자는 파일의 종류를 의미한다.  &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; 일반 파일, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 디렉터리, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; 심볼릭 링크를 나타낸다.&lt;/p&gt;

&lt;p&gt;그 이후의 아홉 개 글자는 &lt;strong&gt;소유자(owner)&lt;/strong&gt;, &lt;strong&gt;그룹(group)&lt;/strong&gt;, &lt;strong&gt;나머지 사용자(other)&lt;/strong&gt; 으로 세 개의 그룹으로 나누어진 권한을 의미한다.&lt;br /&gt;
이 그룹들이 할 수 있는 일은 읽기(r), 쓰기(w), 실행하기(x) 다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;파일 모드(file moe)&lt;/strong&gt; 를 변경하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chomod&lt;/code&gt; 명령으로 권한의 설정을 변경할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;접근-제어-목록access-control-list&quot;&gt;접근 제어 목록(access control list)&lt;/h4&gt;

&lt;p&gt;AFS와 같은 분산 파일 시스템을 포함하는 다른 파일 시스템의 경우 디렉터리마다 &lt;strong&gt;접근 제어 목록(access control list, ACL)&lt;/strong&gt; 을 가지고 있다.&lt;br /&gt;
접근 제어 목록은 누가 특정 자원을 접근할 수 있는지 명확하게 표현한다.&lt;/p&gt;

&lt;h3 id=&quot;3917-파일-시스템-생성과-마운트&quot;&gt;39.17 파일 시스템 생성과 마운트&lt;/h3&gt;

&lt;p&gt;다수의 파일 시스템 파티션들이 존재할 때는 마운트를 통해 단일 디렉터리 트리 구성이 가능하다.&lt;/p&gt;

&lt;p&gt;많은 파일 시스템에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkfs&lt;/code&gt; 로 파일 시스템을 생성할 수 있다.&lt;br /&gt;
이 새로운 파일 시스템을 루트 디렉터리에서 시작하는 기존의 디렉터리 구성으로 접근할 수 있도록 하는 작업을 마운트라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mount&lt;/code&gt; 프로그램으로 기존의 디렉터리 중 하나를 &lt;strong&gt;마운트 지점(mount point)&lt;/strong&gt; 으로 지정하여 새로운 파일 시스템을 붙여 넣는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;40장-파일-시스템-구현&quot;&gt;40장. 파일 시스템 구현&lt;/h2&gt;

&lt;p&gt;이번 장에서 &lt;strong&gt;vsfs(Very Simple File System)&lt;/strong&gt; 라는 간단한 파일 시스템에 대해 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;401-생각하는-방법&quot;&gt;40.1 생각하는 방법&lt;/h3&gt;

&lt;p&gt;파일 시스템의 두 가지 측면에 대해 알아본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;자료 구조&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;간단한 파일 시스템은 블럭과 다른 객체들을 배열과 같은 간단한 자료 구조&lt;/li&gt;
      &lt;li&gt;다른 파일 시스템은 복잡한 트리 기반의 자료 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;접근 방법(access method)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스가 호출하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 등의 시스템콜을 실핼할 때 어떻게 동작하는지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;402-전체-구성&quot;&gt;40.2 전체 구성&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/file-system-data-structure&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/file-system-data-structure&quot; data-rjs=&quot;/images/study/operating-system/file-system-data-structure&quot; class=&quot;zooming&quot; alt=&quot;파일 시스템의 자료구조&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        파일 시스템의 자료구조
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;vsfs 파일 시스템의 자료 구조에 대해 디스크를 &lt;strong&gt;블럭(block)&lt;/strong&gt; 들로 나누어 알아본다.
4KB 블럭이 64개 나열된 작은 디스크를 가정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터 영역(data region)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용자 데이터가 있는 디스크 공간&lt;/li&gt;
      &lt;li&gt;데이터 블럭(D)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;아이노드(inode)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;파일에 대한 &lt;strong&gt;메타데이터(metadata)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;파일 크기, 소유자, 접근 권한, 접근과 변경 시간 등과 같은 정&lt;/li&gt;
      &lt;li&gt;아이노드 블럭(I)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;아이노드 테이블(inode table)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;아이노드들의 저장을 위한 디스크 공간&lt;/li&gt;
      &lt;li&gt;아이노드들이 배열형태로 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;슈퍼블럭(superblock)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;파일 시스템 전체에 대한 정보 (아이노드와 데이터 블럭 개수, 아이노드 테이블 시작 위치 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각 블럭이 현재 사용 중인지 아닌지는 &lt;strong&gt;할당 구조(allocation structure)&lt;/strong&gt; 로 표현해야 한다.
사용 여부를 표현하는 데에는 다양한 방법이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프리 리스트(free list)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용 중이 아닌 블럭들을 링크드 리스트 형태로 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비트맵(bitmap)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;데이터 비트맵(data bitmap)&lt;/strong&gt;: 데이터 영역에 있는 블럭들의 사용여부 표시 (d)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;아이노드 비트맵(inode bitmap)&lt;/strong&gt;: 아이노드 테이블에 있는 아이노드들의 사용여부 표시 (i)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;403-파일-구성-아이노드&quot;&gt;40.3 파일 구성: 아이노드&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;아이노드(inode)&lt;/strong&gt; 는 &lt;strong&gt;인덱스 노드(index node)&lt;/strong&gt; 의 줄임말로 디스크 자료 구조 중 가장 중요하다.&lt;br /&gt;
각 아이노드는 &lt;strong&gt;아이-넘버(i-number)&lt;/strong&gt; 라는 숫자로 표현되는데 이를 &lt;strong&gt;저수준 이름(low-level name)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;p&gt;아이노드에는 파일의 종류, 크기, 할당된 블럭 수, 보호 정보, 시간 정보, 데이터 블록의 디스크 위치 등과 같은 &lt;strong&gt;메타데이터(metadata)&lt;/strong&gt; 가 저장되어 있다.&lt;br /&gt;
데이터 블럭의 위치를 표현하는 가장 간단한 방법은 &lt;strong&gt;직접 포인터(direct pointer)&lt;/strong&gt; 를 두는 것이지만 파일 크기의 제한이 있다.&lt;/p&gt;

&lt;h4 id=&quot;멀티-레벨-인덱스&quot;&gt;멀티 레벨 인덱스&lt;/h4&gt;

&lt;p&gt;큰 파일을 지원하기 위한 일반적인 방법은 아이노드 내에 &lt;strong&gt;간접 포인터(indirect pointer)&lt;/strong&gt; 를 두는 것이다.&lt;br /&gt;
간접 포인터는 데이터 블럭의 위치를 가리키지 않고 데이터 블럭을 가리키는 포인터들이 저장된다.&lt;br /&gt;
더 큰 파일을 저장하고 싶으면 &lt;strong&gt;이중 간접 포인터(double indirect pointer)&lt;/strong&gt;, &lt;strong&gt;삼중 간접 포인터(triple indirect pointer)&lt;/strong&gt; 등을 둘 수 있다.&lt;br /&gt;
이러한 구성 방식을 멀티 레벨 인덱스 기법이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;404-디렉터리-구조&quot;&gt;40.4 디렉터리 구조&lt;/h3&gt;

&lt;p&gt;디렉터리의 데이터 블럭에는 문자열과 숫자가 쌍으로 존재하며 문자열 길이에 대한 정보도 있다.&lt;br /&gt;
대부분의 파일 시스템에서는 디렉터리들을 특수한 종류의 파일로 간주한다.&lt;br /&gt;
디렉터리는 자신의 아이노드를 가지며, 아이노드의 type 필드에 디렉터리 라고 명시되어 잇다.&lt;/p&gt;

&lt;h3 id=&quot;405-빈공간의-관리&quot;&gt;40.5 빈공간의 관리&lt;/h3&gt;

&lt;p&gt;파일 시스템은 아이노드와 데이터 블럭 사용 여부를 관리하는 &lt;strong&gt;빈 공간 관리(free space management)&lt;/strong&gt; 로 파일이나 디렉터리를 할당할 공간을 찾는다.  &lt;br /&gt;
파일 시스템은 &lt;strong&gt;선할당(pre-allocation)&lt;/strong&gt; 정책으로 연속된 블럭들이 비어있는 공간 할당하여 파일에 대한 입출력 성능을 개선한다.&lt;/p&gt;

&lt;h3 id=&quot;406-실행-흐름-읽기와-쓰기&quot;&gt;40.6 실행 흐름: 읽기와 쓰기&lt;/h3&gt;

&lt;p&gt;파일 시스템 동작을 이해하기 위해 &lt;strong&gt;실행 과정(access path)&lt;/strong&gt; 에 대해 알아본다.&lt;/p&gt;

&lt;h4 id=&quot;디스크에서-파일-읽기&quot;&gt;디스크에서 파일 읽기&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open(&quot;foo/bar&quot;, O_RDONLY)&lt;/code&gt; 호출&lt;/li&gt;
  &lt;li&gt;항상 &lt;strong&gt;루트 디렉터리(root directory)&lt;/strong&gt; 에서 시작하여 루트 디렉터리의 아이노드 읽음&lt;/li&gt;
  &lt;li&gt;아이노드에서 데이터 블럭의 포인터 추출 하여 디렉터리 정보 읽기&lt;/li&gt;
  &lt;li&gt;디렉터리 정보를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 항목 찾기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 의 아이노드 블럭과 데이터를 읽은 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bar&lt;/code&gt; 아이노드 번호 찾기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bar&lt;/code&gt; 에 대한 아이노드를 메모리로 읽어 들임&lt;/li&gt;
  &lt;li&gt;파일에 대한 접근 권한을 확인하고 파일 디스크립터를 할당받아 사용자에게 리턴&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 를 통해 파일 읽기&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;디스크에-파일-쓰기&quot;&gt;디스크에 파일 쓰기&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;파일을 열기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 를 호출하여 새로운 내용으로 파일 갱신&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;407-캐싱과-버퍼링&quot;&gt;40.7 캐싱과 버퍼링&lt;/h3&gt;

&lt;p&gt;대부분의 파일 시스템들은 자주 사용되는 블럭들을 메모리(DRAM)에 캐싱한다.&lt;br /&gt;
캐싱을 하지 않으면 아이노드와 디렉터리 데이터 읽기로 최소 두번의 읽기가 필요하다.&lt;/p&gt;

&lt;p&gt;초기 시스템은 고정 크기의 캐시(전체 메모리의 약 10%)를 가지고 캐시 교체 정책들로 어떤 블럭들을 남길지 결정했다.&lt;/p&gt;

&lt;p&gt;현대 시스템은 동적 파티션 방식을 사용한다.&lt;br /&gt;
가상 메모리 페이지와 파일 시스템 페이지들을 통합하여 &lt;strong&gt;일원화된 페이지 캐시(unified page cache)&lt;/strong&gt; 를 사용한다.&lt;br /&gt;
이를 통해 파일 시스템과 가상 메모리에 융통성있게 메모리를 할당할 수 있다.&lt;/p&gt;

&lt;p&gt;캐시를 이용하면 쓰기의 경우 &lt;strong&gt;쓰기 버퍼링(write buffering)&lt;/strong&gt; 이 가능하여 &lt;strong&gt;일괄처리(batch)&lt;/strong&gt; 가 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째 갱신에 대한 쓰기를 연기하여 두 번째 연산과 병합 가능 (I/O 줄임)&lt;/li&gt;
  &lt;li&gt;쓰기 요청들을 모아 I/O 들을 스케줄하여 성능 개선&lt;/li&gt;
  &lt;li&gt;쓰기 자체 회피 가능 (생성 후 즉시 삭제한다면 생성할 필요가 없음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터가 유실되지 않도록 강제적으로 기록하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync()&lt;/code&gt; 를 사용한다.&lt;/p&gt;</content><author><name></name></author><category term="study" /><category term="study" /><category term="book" /><category term="operation-system" /><summary type="html">운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다. 이 글에서는 영속성에 대해 다룬 35장부터 40장까지의 내용을 정리한다.</summary></entry><entry><title type="html">[Study] 운영체제 아주 쉬운 세가지 이야기 29장~34장</title><link href="https://devyonghee.github.io/study/2022/11/29/operation-system-three-easy-pieces-29-34/" rel="alternate" type="text/html" title="[Study] 운영체제 아주 쉬운 세가지 이야기 29장~34장" /><published>2022-11-29T00:00:00+00:00</published><updated>2022-11-29T00:00:00+00:00</updated><id>https://devyonghee.github.io/study/2022/11/29/operation-system-three-easy-pieces-29-34</id><content type="html" xml:base="https://devyonghee.github.io/study/2022/11/29/operation-system-three-easy-pieces-29-34/">&lt;p&gt;운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.&lt;br /&gt;
이 글에서는 병행성에 대해 다룬 29장부터 34장까지의 내용을 정리한다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;29장-락-기반의-병행-자료-구조&quot;&gt;29장. 락 기반의 병행 자료 구조&lt;/h2&gt;

&lt;p&gt;자료 구조에 락을 추가하면 경쟁조건으로 부터 안전한 &lt;strong&gt;쓰레드 안전(thread safe)&lt;/strong&gt; 자료 구조로 만들 수 있다.&lt;br /&gt;
어떤 방식으로 병행 자료 구조를 다뤄야하는지 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;291-병행-카운터&quot;&gt;29.1 병행 카운터&lt;/h3&gt;

&lt;p&gt;카운터는 보편적으로 사용되면서 가장 간단한 자료 구조이다.&lt;/p&gt;

&lt;h4 id=&quot;간단하지만-확장성이-없음&quot;&gt;간단하지만 확장성이 없음&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__counter_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decrement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;간단하지만 정확하게 동작, 병행 자료 구조의 보편적인 디자인 패턴&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모니터(monitor)&lt;/strong&gt; 를 사용하여 만든 자료구조와 유사&lt;/li&gt;
  &lt;li&gt;쓰레드 개수가 늘어날 수록 성능이 나빠짐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;완벽한 확장성(perfect scaling)&lt;/strong&gt; 이 보장된 환경에서는 작업양이 CPU 개수에 비례해서 증가해도 전체 완료 시간이 늘어나지 않는다.&lt;/p&gt;

&lt;h4 id=&quot;확장성-있는-카운팅&quot;&gt;확장성 있는 카운팅&lt;/h4&gt;

&lt;p&gt;확장성 있는 카운터를 만들기 위해 &lt;strong&gt;근사 카운터(approximate counter)&lt;/strong&gt; 기법을 사용한다.&lt;br /&gt;
근사 카운터는 하나의 논리적 카운터로 표현되는데 CPU 코어마다 하나의 물리적인 &lt;strong&gt;지역 카운터&lt;/strong&gt;와 하나의 &lt;strong&gt;전역 카운터&lt;/strong&gt;로 구성되어있다.&lt;/p&gt;

&lt;p&gt;쓰레드는 지역 카운터를 증가시켜 지역 락으로 보호한다.&lt;br /&gt;
CPU 마다 지역 카운터를 갖기 때문에 CPU 들에 분산된 쓰레드들은 지역 카운터를 경쟁 없이 갱신할 수 있다. (확장성)&lt;/p&gt;

&lt;p&gt;주기적으로 지역 카운터 값을 전역 카운터에 반영하고 쓰레드는 전역 카운터를 읽어 카운터 값을 판단한다.&lt;br /&gt;
전역 락을 사용하면 지역 카운터의 값을 전역 카운터 값에 더하고, 지역 카운터의 값은 0으로 초기화 한다.&lt;/p&gt;

&lt;h2 id=&quot;292-병행-연결-리스트&quot;&gt;29.2 병행 연결 리스트&lt;/h2&gt;

&lt;p&gt;연결 리스트를 병행적으로 다루기 위해 삽입 연산을 시작하기 전에 락을 획득하고 리턴 직전에 해제한다.&lt;/p&gt;

&lt;h3 id=&quot;확장성-있는-연결리스트&quot;&gt;확장성 있는 연결리스트&lt;/h3&gt;

&lt;p&gt;병행 가능한 연결 리스트는 확장성이 좋지 않다.&lt;br /&gt;
이를 개선하기 위해 hand-over-hand locking (또는 lock coupling) 기법 개발&lt;/p&gt;

&lt;p&gt;전체 리스트에 하나의 락이 아니라 노드마다 락을 추가하는 것이다.&lt;br /&gt;
리스트를 순회하면서 다음 노드의 락을 획득하고 지금 노드의 락을 해제한다.&lt;br /&gt;
하지만 락을 획득하고 해제하는 오버헤드가 크기 때문에 속도 개선이 쉽지 않다.&lt;/p&gt;

&lt;h2 id=&quot;293-병행-큐&quot;&gt;29.3 병행 큐&lt;/h2&gt;

&lt;p&gt;병행 큐는 큐의 헤드와 테일에 락을 사용한다.&lt;br /&gt;
큐에 삽입과 추출 연산에 병행성을 부여하는 것이다.&lt;/p&gt;

&lt;p&gt;하지만 이 락만 존재하는 큐는 쓰레드가 대기하는 기능이 없기 때문에 실제로 사용할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;294-병행-해시-테이블&quot;&gt;29.4 병행 해시 테이블&lt;/h2&gt;

&lt;p&gt;병행 해시 테이블은 전체 자료 구조에 하나의 락이 아닌 해시 버켓마다 락을 사용했기 때문에 병행 리스트에 비해 병행성이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;295-요약&quot;&gt;29.5 요약&lt;/h3&gt;

&lt;p&gt;카운터, 리스트, 큐 해시 테이블 병행 자료 구조들을 소개했다.&lt;br /&gt;
락 획득과 해제 코드에 대해 주의를 기울여야 하는데, &lt;br /&gt;
성능 개선은 &lt;strong&gt;미숙한 최적화(premature optimization)&lt;/strong&gt; 를 피하기 위해 성능에 문제가 생길 경우에만 고려해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;30장-컨디션-변수&quot;&gt;30장. 컨디션 변수&lt;/h2&gt;

&lt;p&gt;병행 프로그램을 제작하는데 락 이외에도 특정 &lt;strong&gt;조건&lt;/strong&gt; 의 만족 여부를 검사하는 기법도 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;301-컨디션-변수의-개념과-관련-루틴&quot;&gt;30.1 컨디션 변수의 개념과 관련 루틴&lt;/h3&gt;

&lt;p&gt;쓰레드 실행 시, 특정 조건이 만족될 때까지 대기를 위해 &lt;strong&gt;컨디션 변수(conditional variable)&lt;/strong&gt; 를 사용할 수 있다.&lt;br /&gt;
컨디션 변수는 쓰레드 실행에서 특정 조건이 만족되기를 대기하는 큐 자료 구조다.&lt;/p&gt;

&lt;p&gt;슬립에서 깨어난 프로세스는 리턴하기 전에 락을 재획득 해야 한다.&lt;br /&gt;
대기상태에서 깨어났어도 락 획득에 실패하면 다시 sleep 상태로 들어간다.&lt;/p&gt;

&lt;h2 id=&quot;302-생산자소비자유한-버퍼-문제&quot;&gt;30.2 생산자/소비자(유한 버퍼) 문제&lt;/h2&gt;

&lt;p&gt;동기화 문제인 &lt;strong&gt;생산자/소비자(producer/consumer)&lt;/strong&gt; 또는 &lt;strong&gt;유한 버퍼(bounded 버퍼)&lt;/strong&gt; 문제에 대해 살펴본다.&lt;br /&gt;
생산자 쓰레드는 데이터 만들어 버퍼에 넣고, 소비자 쓰레드는 버퍼에서 데이터를 꺼내 사용한다.&lt;/p&gt;

&lt;p&gt;유한 버퍼는 공유 자원으로 경쟁 조건이 발생되지 않도록 동기화가 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;303-포함-조건covering-condition&quot;&gt;30.3 포함 조건(Covering Condition)&lt;/h2&gt;

&lt;p&gt;다수의 쓰레드가 메모리 공간의 발생을 대기하고 있는 경우 어떤 쓰레드를 깨워야할지 선택해야 한다.&lt;br /&gt;
이 문제를 해결하기 위해 대기 중인 모든 쓰레드에게 시그널을 보내 대기상태에서 준비상태로 전이하여 모든 쓰레드를 깨워서 실행한다.&lt;br /&gt;
깨어난 쓰레드들은 조건을 검사하고 만족하지 않으면 다시 대기모드로 들어가고 만족하면 실행을 계속한다.&lt;br /&gt;
이러한 방식을 &lt;strong&gt;포함 조건(Covering Condition)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;p&gt;하지만 불필요하게 많은 쓰레드를 깨우기 때문에 불필요한 문맥 전환이 발생될 수 있다는 것이 단점이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31장-세마포어&quot;&gt;31장. 세마포어&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;세마포어(semaphore)&lt;/strong&gt; 는 락과 컨디션 변수로 모두 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;311-세마포어-정의&quot;&gt;31.1 세마포어: 정의&lt;/h2&gt;

&lt;p&gt;세마포어는 정수 값을 갖는 객체로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_wait()&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_post()&lt;/code&gt; 루틴으로 조작할 수 있다.&lt;br /&gt;
세마포어는 초기값에 의해 동작이 결정되기 때문에 사용하기 전에 초기화를 해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_wait()&lt;/code&gt; 함수는 즉시 리턴하거나, 세마포어 값이 1이상이 될 때까지 호출자를 대기(spin or sleep)시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_post()&lt;/code&gt; 함수는 대기하지 않고 세마포어 값을 증가시키고 쓰레드 하나를 깨운다&lt;/li&gt;
  &lt;li&gt;세마포어가 음수라면 그 값은 현재 대기 중인 쓰레드의 갯수와 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;312-이진-세마포어락&quot;&gt;31.2 이진 세마포어(락)&lt;/h2&gt;

&lt;p&gt;세마포어를 락에 적용해본다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_wait()&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_post()&lt;/code&gt; 쌍으로 임계 영역 부분을 둘러싼다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sem_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sem_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// X 로 초기화, 초기 값은 1이 되어야 함&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//임계 영역&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;sem_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;세마 포어를 락으로 사용할 수 있는데, &lt;br /&gt;
락은 두 개의 상태(사용 가능, 사용중)만 존재하므로 &lt;strong&gt;이진 세마포어(binary semaphore)&lt;/strong&gt; 라고도 한다.&lt;/p&gt;

&lt;h3 id=&quot;313-순서-보장을-위한-세마포어&quot;&gt;31.3 순서 보장을 위한 세마포어&lt;/h3&gt;

&lt;p&gt;세마포어는 사건들의 순서를 정하는데도 유용하다.&lt;br /&gt;
컨디션 변수를 사용했던 것과 유사하게 세마포어를 순서를 위한 도구로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;부모 프로세스에서 자식 프로세스를 생성 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_wait()&lt;/code&gt; 를 호출하여 자식 종료를 대기하고, &lt;br /&gt;
자식에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_post()&lt;/code&gt; 호출하여 종료를 알리면 된다. &lt;br /&gt;
여기서 세마포어 초기값은 0으로 설정하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;314-생산자소비자-유한-버퍼-문제&quot;&gt;31.4 생산자/소비자 (유한 버퍼) 문제&lt;/h3&gt;

&lt;p&gt;다수의 생산자 쓰레드나 소비자 쓰레드가 존재할 경우 교착 상태가 발생되지 않도록 세심한 주의가 필요하다. &lt;br /&gt;
교착 상태 문제를 해결하기 위해서는 락의 범위(scope)를 줄여야 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;315-reader-writer-락&quot;&gt;31.5 Reader-Writer 락&lt;/h3&gt;

&lt;p&gt;다수의 쓰레드가 연렬 리스트에 노드를 삽입하고 검색하는 상황을 가정한다.&lt;br /&gt;
이를 위해 만들어진 락이 &lt;strong&gt;reader-writer 락&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt;이 기법에서는 자료구조를 갱신하려면 배타적 접근권한을 갖는 락을 사용하도록 한다.&lt;br /&gt;
하지만 쓰기 쓰레드에게 기아 현상이 발생하기 쉬워 공정성에 문제가 있는데,&lt;br /&gt;
이는 쓰기 쓰레드가 대기중일 때 읽기 쓰레드가 락을 획득하지 못하도록 해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;316-식사하는-철학자&quot;&gt;31.6 식사하는 철학자&lt;/h3&gt;

&lt;p&gt;다섯명의 철학자가 식탁 주위를 둘러 앉았고, 총 다섯 개의 포크가 철학자 사이에 하나씩 놓여있는 문제다.&lt;br /&gt;
철학자는 양쪽의 포크를 들어야 식사를 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_forks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;317-쓰레드-제어&quot;&gt;31.7 쓰레드 제어&lt;/h3&gt;

&lt;p&gt;과하게 많은 쓰레드가 동시에 수행되면 효율이 나빠진다.&lt;br /&gt;
이 현상을 방지하기 위해 세마포어를 사용하여 쓰레드 개수를 제한한다. &lt;br /&gt;
이러한 접근법을 &lt;strong&gt;제어(throttling)&lt;/strong&gt; 이라 하며 &lt;strong&gt;수락 제어&lt;/strong&gt;의 한 형태로 간주한다.&lt;/p&gt;

&lt;p&gt;세마포어의 값을 메모리-집약 영역에 동시에 들어갈 수 있는 최대 쓰레드 개수로 초기화하고,&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_wait()&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem_post()&lt;/code&gt;를 각각 추가하면서 쓰레드 개수를 통제한다.&lt;/p&gt;

&lt;h3 id=&quot;318-세마포어-구현&quot;&gt;31.8 세마포어 구현&lt;/h3&gt;

&lt;p&gt;락과 컨디션 변수를 사용하여 세마포어인 제마포어(Zemaphore) 를 구현해본다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__Zem_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Zem_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Zem_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zem_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Cond_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Mutex_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Zem_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zem_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Cond_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Zem_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zem_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Cond_signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;319-요약&quot;&gt;31.9 요약&lt;/h3&gt;

&lt;p&gt;세마포어는 병행 프로그램 작성을 위한 강력하고 유연한 기법이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;32장-병행성-관련-버그&quot;&gt;32장. 병행성 관련 버그&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;교착 상태(deadlock)&lt;/strong&gt; 를 비롯한 병행성 관련 오류를 자세하게 알아본다.&lt;/p&gt;

&lt;h3 id=&quot;321-오류의-종류&quot;&gt;32.1 오류의 종류&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/program-error-count.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/program-error-count.png&quot; data-rjs=&quot;/images/study/operating-system/program-error-count.png&quot; class=&quot;zooming&quot; alt=&quot;현대 응용 프로그램들의 오류들&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        현대 응용 프로그램들의 오류들
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;h3 id=&quot;322-비-교착-상태-오류&quot;&gt;32.2 비 교착 상태 오류&lt;/h3&gt;

&lt;p&gt;비 교착 상태 오류는 대표적으로 &lt;strong&gt;원자성 위반(atomicity violation)&lt;/strong&gt; 오류와 &lt;strong&gt;순서 위반(order violation)&lt;/strong&gt; 이 있다.&lt;/p&gt;

&lt;h4 id=&quot;원자성-위반-오류&quot;&gt;원자성 위반 오류&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;thd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫번째 쓰레드에서 값을 검사한 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fputs()&lt;/code&gt; 호출하기 전에 두 번째 쓰레드가 실행되면 NULL 포인터 참조 오류가 발생한다.&lt;br /&gt;
공유 변수 참조 앞 뒤에 락을 추가하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proc_info&lt;/code&gt; 필드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 검사와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fputs()&lt;/code&gt; 호출이 원자적으로 수행되어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;순서-위반-오류&quot;&gt;순서 위반 오류&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PR_CreateThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;쓰레드 2의 코드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mThread&lt;/code&gt; 변수가 이미 초기화 된 것을 가정하지만,&lt;br /&gt;
쓰레드 1이 먼저 실행되지 않으면 NULL 포인터 참조 오류가 발생한다.&lt;/p&gt;

&lt;p&gt;이러한 오류는 &lt;strong&gt;컨디션 변수&lt;/strong&gt; 를 활용하여 순서를 강제해야 한다.&lt;/p&gt;

&lt;h4 id=&quot;비-교착-상태-오류-정리&quot;&gt;비 교착 상태 오류: 정리&lt;/h4&gt;

&lt;p&gt;비 교착 상태 오류가 전체 오류 분포에서 많은 비중을 차지하기 때문에,&lt;br /&gt;
이러한 오류에 대해 초점을 맞춰야 한다.&lt;/p&gt;

&lt;h3 id=&quot;323-교착-상태-오류&quot;&gt;32.3 교착 상태 오류&lt;/h3&gt;

&lt;p&gt;많은 병행 시스템에서는 &lt;strong&gt;교착 상태(deadlock)&lt;/strong&gt; 문제가 발생된다.&lt;br /&gt;
아래 그래프에서 &lt;strong&gt;사이클(cycle)&lt;/strong&gt; 의 존재는 교착 상태 발생 가능성을 의미한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/deadlock-dependency-graph.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/deadlock-dependency-graph.png&quot; data-rjs=&quot;/images/study/operating-system/deadlock-dependency-graph.png&quot; class=&quot;zooming&quot; alt=&quot;교착 상태 의존성 그래프&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        교착 상태 의존성 그래프
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;h4 id=&quot;교착-상태는-왜-발생하는가&quot;&gt;교착 상태는 왜 발생하는가&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;구성 요소 간에 복잡한 의존성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;캡슐화(encapsulation)&lt;/strong&gt; 의 성질
    &lt;ul&gt;
      &lt;li&gt;모듈화와 락은 잘 조화되지 않음&lt;/li&gt;
      &lt;li&gt;호출한 응용 프로그램은 모르게 교착 상태 발생 될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;교착-상태-발생-조건&quot;&gt;교착 상태 발생 조건&lt;/h4&gt;

&lt;p&gt;교착 상태가 발생하기 위해서는 아래 네 가지 조건이 모두 충족되어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상호 배제(Mutual Exclusion)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권 주장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;점유 및 대기(Hold-and-wait)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;쓰레드가 자신에게 할당된 자원을 점유한 채로 다른 자원을 대기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비 선점(No preemption)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;락을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;환형 대기(Circular wait)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 락을 갖고 있는 쓰레드들의 순환 고리 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;교착-상태의-예방&quot;&gt;교착 상태의 예방&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;순환 대기(Circular Wait)
    &lt;ul&gt;
      &lt;li&gt;순환 대기가 발생하지 않도록 락 획득을 하는 &lt;strong&gt;전체 순서(total ordering)&lt;/strong&gt; 을 정함&lt;/li&gt;
      &lt;li&gt;교착 상태를 피하기 위해 &lt;strong&gt;부분 순서(partial ordering)&lt;/strong&gt; 만 정의할 수도 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;점유 및 대기(Hold-and-Wait)
    &lt;ul&gt;
      &lt;li&gt;원자적으로 모든 락을 단번에 획득하도록 하여 예방&lt;/li&gt;
      &lt;li&gt;캡슐화로 인해 필요한 락들을 정확하게 파악하고 획득해야 하는 문제가 있음 (병행성 저하)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비선점(No Preemption)
    &lt;ul&gt;
      &lt;li&gt;다른 쓰레드에서 락이 점유되었다면 다시 획득을 시도하는 유연한 인터페이스 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;무한반복(livelock)&lt;/strong&gt; 이라는 문제가 발생 됨 (두 쓰레드 모두 락을 획득하지 못하여 진척이 안되는 경우)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상호 배제(Mutual Exclusion)
    &lt;ul&gt;
      &lt;li&gt;상호 배제를 없애기 위해 &lt;strong&gt;락이 없는(lock-free)&lt;/strong&gt; 자교 구조 접근법&lt;/li&gt;
      &lt;li&gt;여러 쓰레드에 의해 동시에 호출 되면 경쟁 조건이 발생됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스케줄링으로 교착 상태 회피하기
    &lt;ul&gt;
      &lt;li&gt;교착 상태를 예방하는 대신 회피가 더 유용할 수 있음&lt;/li&gt;
      &lt;li&gt;여러 쓰레드가 어떤 락을 획득할 것인지 파악하고 쓰레드들을 스케줄링하여 교착 상태가 발생되지 않도록 보장 필요&lt;/li&gt;
      &lt;li&gt;병행성에 제약이 생길 수 있음 (보편적인 방법은 아님)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;발견 및 복구
    &lt;ul&gt;
      &lt;li&gt;교착 상태 발생을 허용하고 복구하는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;324-요약&quot;&gt;32.4 요약&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;비 교착 상태 오류
    &lt;ul&gt;
      &lt;li&gt;흔하지만 대체적으로 고치기 쉬운 오류들&lt;/li&gt;
      &lt;li&gt;원자성 위반, 순서 위반 오류 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;교착 상태 오류
    &lt;ul&gt;
      &lt;li&gt;락 획득 순서를 정해서 애초에 교착 상태가 발생하지 않도록 예방 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;33장-이벤트-기반의-병행성고급&quot;&gt;33장. 이벤트 기반의 병행성(고급)&lt;/h2&gt;

&lt;p&gt;병행 프로그램을 제작하는 도구로 쓰레드뿐만 아니라 &lt;strong&gt;이벤트 기반의 병행성(event-based concurrency)&lt;/strong&gt; 스타일도 있다. (&lt;strong&gt;node.js&lt;/strong&gt; 서버 프레이뭐크에서 사용)
이벤트 기반의 프로그래밍으로 쓰레드 기반의 병령 프로그래밍의 두가지 문제를 해결할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;멀티 쓰레드 기반 프로그래밍은 어려움
    &lt;ul&gt;
      &lt;li&gt;락 보호, 교착 상태 등 문제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발자가 쓰레드 스케줄링에 대한 제어권이 없음
    &lt;ul&gt;
      &lt;li&gt;운영체제가 합리적으로 쓰레드들의 실행 순서를 결정하기만을 기대해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;331-기본-개념-이벤트-루프&quot;&gt;33.1 기본 개념: 이벤트 루프&lt;/h3&gt;

&lt;p&gt;이벤트 기반의 병행성 접근 방법은 다음과 같다.&lt;br /&gt;
이벤트의 발생 대기 → 이벤트가 종류 파악 → I/O 요청 또는 추후 처리를 위한 다른 이벤트 발생 등의 작업&lt;/p&gt;

&lt;p&gt;이벤트 기반의 서버는 &lt;strong&gt;이벤트 루프(event loop)&lt;/strong&gt; 라는 단순한 구조를 갖는다. &lt;br /&gt;
루프내에서 이벤트 발생을 하나씩 처리하는데 이 처리하는 코드를 &lt;strong&gt;이벤트 핸들러(event handler)&lt;/strong&gt; 라고 부른다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getEvents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;processEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;332-중요-api-select-또는-poll&quot;&gt;33.2 중요 API: select() (또는 poll())&lt;/h3&gt;

&lt;p&gt;이벤트 발생은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select()&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll()&lt;/code&gt; 시스템 콜을 통해 감지한다.&lt;br /&gt;
이 인터페이스들은 처리가 필요한 것들이 있는지 검사한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;전체 집합에서 준비된 디스크립터(descriptor)들의 총 개수를 반환&lt;/li&gt;
      &lt;li&gt;디스크립터에 대한 읽기 또는 쓰기 가능여부 파악 가능&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 디스크립터에 상태가 변경할 때까지 무한정 대기하거나 즉시 리턴하도록 설정 가능 (널리 0 으로 설정하여 즉시 리턴)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select()&lt;/code&gt; 시스템 콜과 유사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;333-select-의-사용&quot;&gt;33.3 select() 의 사용&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// fd_set 를 모두 0으로 초기화&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readFDs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;FD_ZERO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readFDs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 서버가 관심 있어 하는 디스크립터들의 bit 설정&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minFD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxFD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;FD_SET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readFDs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 선택&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxFD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readFDs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// FD_ISSET() 를 사용하여 실제 데이터 사용 여부 검사&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minFD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxFD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FD_ISSET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readFDs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;processFD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;334-왜-간단한가-락이-필요-없음&quot;&gt;33.4 왜 간단한가? 락이 필요 없음&lt;/h3&gt;

&lt;p&gt;쓰레드 기반 병행 프로그램의 문제점들이 발생되지 않음&lt;br /&gt;
한번에 하나의 이벤트만 처리하기 때문에 락 획득, 해제가 필요 없음 (단일 쓰레드 구성)&lt;/p&gt;

&lt;h3 id=&quot;335-문제점-블로킹-시스템-콜blocking-system-call&quot;&gt;33.5 문제점: 블로킹 시스템 콜(Blocking System Call)&lt;/h3&gt;

&lt;p&gt;이벤트 기반의 접근법에서는 쓰레드가 없고 이벤트 루프만 존재한다.&lt;br /&gt;
이벤트 핸들러가 블로킹 콜을 호출하면 서버 전체가 그 일을 처리하기 위해 정지된다. (자원 낭비)&lt;/p&gt;

&lt;h3 id=&quot;336-해법-비동기-io&quot;&gt;33.6 해법: 비동기 I/O&lt;/h3&gt;

&lt;p&gt;이벤트 기반 서버의 한계를 극복하기 위해 &lt;strong&gt;비동기 I/O(asynchronous I/O)&lt;/strong&gt; 방법 개발  &lt;br /&gt;
&lt;strong&gt;폴링(poll)&lt;/strong&gt; 또는 인터럽트 기반의 시스템에서 &lt;strong&gt;시그널(signal)&lt;/strong&gt; 을 사용하여 I/O 가 완료되었다고 프로그램에게 알린다.&lt;/p&gt;

&lt;h3 id=&quot;337-또-다른-문제점-상태관리&quot;&gt;33.7 또 다른 문제점: 상태관리&lt;/h3&gt;

&lt;p&gt;이벤트 기반 접근법은 이벤트 핸들러가 비동기 I/O 를 발생시킬 때 프로그램 상태를 관리해야 하기 때문에 일반적으로 쓰레드 기반 코드보다 복잡하다.&lt;br /&gt;
쓰레드 기반 프로그램에는 쓰레드 스택에 정보들이 들어있는데 이벤트 기반 프로그램에서는 이 정보들을 관리해야 한다. &lt;br /&gt;
이를 &lt;strong&gt;수동 스택 관리(manual stack management)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;p&gt;이벤트 기반 서버에서는 &lt;strong&gt;continuation&lt;/strong&gt; 개념을 사용하여,&lt;br /&gt;
이벤트 종료하는 데에 필요한 자료들을 한곳에 저장해두고 이벤트가 발생하면 이벤트를 처리한다.&lt;/p&gt;

&lt;h3 id=&quot;338-이벤트-사용의-어려움&quot;&gt;33.8 이벤트 사용의 어려움&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;멀티 CPU&lt;/strong&gt; 의 경우 복잡해짐
    &lt;ul&gt;
      &lt;li&gt;다수의 CPU 를 활용하기 위해 다수의 이벤트 핸들러를 병렬 실행&lt;/li&gt;
      &lt;li&gt;동기화 문제 발생하여 락과 같은 기법 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;페이징(paging)&lt;/strong&gt; 같은 시스템 작업과 조화롭게 실행 불가능
    &lt;ul&gt;
      &lt;li&gt;운영체제 내부적으로 발생하는 페이지 폴트 같은 경우에는 이벤트 서버가 블럭&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;루틴들의 &lt;strong&gt;작동 방식&lt;/strong&gt; 변화
    &lt;ul&gt;
      &lt;li&gt;소프트웨어가 개성되고 갱신되면 루틴들의 특성이 변경될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비동기 디스크 I/O 의 사용가능 여부
    &lt;ul&gt;
      &lt;li&gt;아직까지도 비동기 I/O 는 일관성 있게 적용되어 있지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;34장-병랭성을-정리하는-대화&quot;&gt;34장. 병랭성을 정리하는 대화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;병행성은 가능하다면 피해야 함
    &lt;ul&gt;
      &lt;li&gt;어설프게 최적화된 프로그램은 더 좋지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="study" /><category term="study" /><category term="book" /><category term="operation-system" /><summary type="html">운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다. 이 글에서는 병행성에 대해 다룬 29장부터 34장까지의 내용을 정리한다.</summary></entry><entry><title type="html">[Study] 운영체제 아주 쉬운 세가지 이야기 25장~28장</title><link href="https://devyonghee.github.io/study/2022/11/25/operation-system-three-easy-pieces-25-28/" rel="alternate" type="text/html" title="[Study] 운영체제 아주 쉬운 세가지 이야기 25장~28장" /><published>2022-11-25T00:00:00+00:00</published><updated>2022-11-25T00:00:00+00:00</updated><id>https://devyonghee.github.io/study/2022/11/25/operation-system-three-easy-pieces-25-28</id><content type="html" xml:base="https://devyonghee.github.io/study/2022/11/25/operation-system-three-easy-pieces-25-28/">&lt;p&gt;운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.&lt;br /&gt;
이 글에서는 병행성에 대해 다룬 25장부터 28장까지의 내용을 정리한다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;25장-병행성에-관한-대화&quot;&gt;25장. 병행성에 관한 대화&lt;/h2&gt;

&lt;p&gt;멀티쓰레드 프로그램에서 각 쓰레드는 독립된 객체로 프로그램을 대신하여 일을 한다.&lt;br /&gt;
쓰레드들은 동시에 메모리에 접근하게 되는데 이를 조정하지 않으면 예상치 못한 문제가 발생될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;운영체제와-병행성&quot;&gt;운영체제와 병행성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;락(lock)&lt;/strong&gt; 과 &lt;strong&gt;컨디션 변수(conditional variable)&lt;/strong&gt; 같은 기본 동작으로 멀티 쓰레드 프로그램을 지원해야 함&lt;/li&gt;
  &lt;li&gt;운영체제 역시 최초의 동시 프로그램 (메모리 영역도 조심스럽게 접근 필요)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;26장-병행성-개요&quot;&gt;26장. 병행성: 개요&lt;/h2&gt;

&lt;p&gt;멀티 쓰레드 프로그램은 하나 이상의 실행 지점을 가지고 있다.&lt;br /&gt;
&lt;strong&gt;쓰레드(Thread)&lt;/strong&gt; 들은 주소 공간을 공유하기 때문에 동일한 값에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;쓰레드의 상태는 프로세스와 유사하며, 명령어를 가져오는 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가지고 있다. &lt;br /&gt;
두 쓰레드가 하나의 프로세서에서 실행중이라면 &lt;strong&gt;문맥 교환(context switch)&lt;/strong&gt; 를 통해 실행중인 쓰레드와 교체된다.&lt;br /&gt;
여기서 교환되는 상태를 &lt;strong&gt;프로세스 제어 블럭(process control block, PCB)&lt;/strong&gt; 에 저장하듯이 &lt;strong&gt;쓰레드 제어 블럭(thread control block, TCB)&lt;/strong&gt; 을 사용한다.&lt;br /&gt;
프로세스와 달리 쓰레드간의 문맥 교환은 주소 공간(페이지 테이블)을 그대로 사용한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/single-multi-thread-address-space.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/single-multi-thread-address-space.png&quot; data-rjs=&quot;/images/study/operating-system/single-multi-thread-address-space.png&quot; class=&quot;zooming&quot; alt=&quot;단일 쓰레드와 멀티 쓰레드의 주소 공간&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        단일 쓰레드와 멀티 쓰레드의 주소 공간
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;멀티 쓰레드 프로세스의 경우, 주소 공간에 쓰레드마다 스택이 할당되어 있다.&lt;br /&gt;
로컬 변수, 매개변수, 리턴 값, 그외 스택에 넣는 것들은 해당 쓰레드의 스택인 &lt;strong&gt;쓰레드-로컬 저장소(thread-local storage)&lt;/strong&gt; 에 저장된다.&lt;/p&gt;

&lt;h3 id=&quot;261-왜-쓰레드를-사용하는가&quot;&gt;26.1 왜 쓰레드를 사용하는가?&lt;/h3&gt;

&lt;p&gt;쓰레드를 사용해야 하는 이유 2가지&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;병렬 처리(parallelism)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;단일 쓰레드(single-threaded) 프로그램을 멀티프로세서 프로그램으로 변환하는 작업을 &lt;strong&gt;병렬화(parallelization)&lt;/strong&gt; 라고 함&lt;/li&gt;
      &lt;li&gt;작업의 일부분을 나눠서 실행하여 실행 속도를 높일 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;I/O 로 인해 프로그램 실행이 멈추지 않도록 함
    &lt;ul&gt;
      &lt;li&gt;하나의 쓰레드가 대기하는 동안 다른 쓰레드로 전환 가능&lt;/li&gt;
      &lt;li&gt;쓰레딩은 하나의 프로그램 안에서 다른 작업이 중첩(overlap) 될 수 있게 함 (멀티 프로그래밍과 비슷)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;262-예제-쓰레드-생성&quot;&gt;26.2 예제: 쓰레드 생성&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mythread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main: begin&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mythread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mythread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대기 중인 쓰레드 병합&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main: end&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/thread-creation-code-execute.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/thread-creation-code-execute.png&quot; data-rjs=&quot;/images/study/operating-system/thread-creation-code-execute.png&quot; class=&quot;zooming&quot; alt=&quot;쓰레드 실행 추적&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        쓰레드 실행 추적
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;실행 가능 순서는 유일하지 않다.&lt;br /&gt;
다음에 실행될 쓰레드는 &lt;strong&gt;OS 스케줄러(scheduler)&lt;/strong&gt; 에 의해 결정된다.&lt;br /&gt;
하지만 어떤 쓰레드가 언제 실행되는지 알기 어렵기 때문에 병행성이 더 어려워진다.&lt;/p&gt;

&lt;h3 id=&quot;263-훨씬-더-어려운-이유-데이터-공유&quot;&gt;26.3 훨씬 더 어려운 이유: 데이터 공유&lt;/h3&gt;

&lt;p&gt;각 쓰레드에서 공유 변수에 접근하여 수정하게 된다면 예상치 못한 결과가 나온다.&lt;br /&gt;
예를 들어, 두 쓰레드에서 공유 변수에 +1 하는 과정을 10000번을 반복한다면 20000 이 나오지 않는 문제가 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;264-문제의-핵심-제어-없는-스케줄링&quot;&gt;26.4 문제의 핵심: 제어 없는 스케줄링&lt;/h3&gt;

&lt;p&gt;위 문제처럼 명령어의 실행 순서에 따라 결과가 달라지는 상황을 &lt;strong&gt;경쟁 조건(race condition)&lt;/strong&gt; 또는 &lt;strong&gt;데이터 경쟁(data race)&lt;/strong&gt; 이라고 한다.&lt;br /&gt;
문맥 교환이 적절하게 실행되지 않으면 잘못된 결과가 나온다.&lt;br /&gt;
이처럼 실행할 때마다 결과가 다른 경우를 &lt;strong&gt;비결정적(indeterminate)&lt;/strong&gt; 인 결과라고 한다.&lt;/p&gt;

&lt;p&gt;공유 변수를 접근하고 하나 이상의 쓰레드에서 동시에 실행되면 안 되는 코드를 &lt;strong&gt;임계 영역(critical section)&lt;/strong&gt; 이라고 한다.  &lt;br /&gt;
이러한 코드에서는 &lt;strong&gt;상호 배제(mutual exclusion)&lt;/strong&gt; 속성이 필요하다.&lt;br /&gt;
한 쓰레드에서 임계 영역 내의 코드를 실행 중일 때 다른 쓰레드가 실행할 수 없도록 보장하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;265-원자성에-대한-바람&quot;&gt;26.5 원자성에 대한 바람&lt;/h3&gt;

&lt;p&gt;임계 영역 문제 해결 방법 중 하나로 원자적으로 실행되는 명령어 한개를 수행하여, 수행 도중에 인터럽트 발생 가능성을 차단하는 것이다.
따라서 하드웨어에 &lt;strong&gt;동기화 함수(synchronization primitives)&lt;/strong&gt; 구현에 필요한 명령어를 요청한다.  &lt;br /&gt;
하드웨어 지원을 사용하고 운영체제의 도움을 받아 하나의 쓰레드만 임계 영역에서 실행해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;266-또-다른-문제-상대-기다리기&quot;&gt;26.6 또 다른 문제: 상대 기다리기&lt;/h3&gt;

&lt;p&gt;하나의 쓰레드가 다른 쓰레드의 동작이 끝날 때까지 대기해야 하는 상황도 발생한다.&lt;br /&gt;
디스크 I/O 로 요청으로 인해 잠든 경우, I/O 완료 후 쓰레드가 일어나 이후의 작업을 진행하도록 해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;267-정리-왜-운영체제에서&quot;&gt;26.7 정리: 왜 운영체제에서?&lt;/h3&gt;

&lt;p&gt;운영체제는 최초의 병행 프로그램으로 운영체제 내에서 사용하기 위해 이러한 기법들이 생성되었다.&lt;br /&gt;
멀티 쓰레드 프로그램이 등장하면서 응용 프로그래머들도 비슷한 문제를 고민하게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;주요-용어&quot;&gt;주요 용어&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;임계 영역(critical section)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;변수나 자료 구조와 같은 공유 자원을 접하는 코드의 일부분&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;경쟁 조건(race condition)&lt;/strong&gt; 혹은 &lt;strong&gt;데이터 경쟁(data race)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;멀티 쓰레드가 동시에 임계 영역을 실행하려고 할 때 발생&lt;/li&gt;
      &lt;li&gt;공유 자료 구조에 대해 동시에 접근하면 예상치 못한 결과 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비결정적(indeterminate)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램의 실행 결과가 실행할 때마다 다름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상호 배제(mutual exclusion)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;임계 영역에 대해 한 번에 하나의 쓰레드만 접근할 수 있도록 보장&lt;/li&gt;
      &lt;li&gt;경쟁을 피할 수 있고 실행결과를 결정론적으로 얻을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;27장-막간-쓰레드-api&quot;&gt;27장. 막간: 쓰레드 API&lt;/h2&gt;

&lt;p&gt;쓰레드 API 의 주요 부분을 다룬다.&lt;/p&gt;

&lt;h3 id=&quot;271-쓰레드-생성&quot;&gt;27.1 쓰레드 생성&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;pthread_create&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
                &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_attr_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_routine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; 
                &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;                 &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthread_t&lt;/code&gt; 타입 구조체를 가리키는 포인터&lt;/li&gt;
      &lt;li&gt;이 구조체가 쓰레드와 상호작용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attr&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;쓰레드의 속성 지정 (스택의 크기와 쓰레드의 스케줄링 우선순위 같은 정보)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; 로 지정하면 기본값 사용 (대부분 기본값으로 충분)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_routine&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;쓰레드가 시작할 때 실행할 함수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arg&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;실행할 함수에게 전달할 인자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;272-쓰레드-종료&quot;&gt;27.2 쓰레드 종료&lt;/h3&gt;

&lt;p&gt;쓰레드의 완료를 기다리기 위한 함수&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pthread_join&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthread_t thread&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;어떤 쓰레드를 기다리는지 명시 (쓰레드 생성 루틴에 의해 초기화)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value_ptr&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;반환 값에 대한 포인터&lt;/li&gt;
      &lt;li&gt;전달된 인자의 값을 변경하기 때문에 포인터를 전달&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;273-락&quot;&gt;27.3 락&lt;/h3&gt;

&lt;p&gt;쓰레드 라이브러리에서는 &lt;strong&gt;락(lock)&lt;/strong&gt; 함수를 통해 임계 영역에 대한 상호 배제 기법을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pthread_mutext_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pthread_mutext_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutext_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_MUTEX_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// int rc = pthread_mutext_init(&amp;amp;lock, NULL); 이 방식으로도 초기화 가능&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_mutext_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_mutext_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthread_mutext_lock&lt;/code&gt; 가 호출되었을 때 다른 쓰레드도 락을 가지고 있지 않다면 락을 얻어 임계 영역에 진입&lt;/li&gt;
  &lt;li&gt;다른 쓰레드가 락을 가지고 있으면 락을 얻을 때까지 호출에서 리턴하지 않음&lt;/li&gt;
  &lt;li&gt;락을 획득한 쓰레드가 언락을 호출해야 함&lt;/li&gt;
  &lt;li&gt;락과 언락을 호출할 때 에러 코드 확인 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;274-컨디션-변수&quot;&gt;27.4 컨디션 변수&lt;/h3&gt;

&lt;p&gt;한 쓰레드가 계속 진행하기 전에 다른 쓰레드가 작업을 기다리는 일종의 쓰레드 간에 시그널 교환할 수 있는 &lt;strong&gt;컨디션 변수(condition variable)&lt;/strong&gt; 을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pthread_cond_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pthread_cond_signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt; 는 호출 쓰레드를 수면(sleep) 상태로 만들고 다른 쓰레드로부터 시그널을 대기한다.
수면중인 쓰레드가 관심있는 사항이 변경되면 시그널을 보낸다.&lt;/p&gt;

&lt;p&gt;또한, 컨디션 변수를 사용하려면 연결된 락이 반드시 필요하다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutext_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_MUTEX_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_COND_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Pthread_cond_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시그널을 보내고 전역 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ready&lt;/code&gt; 를 수정할 때 락을 가지고 있어야 함&lt;/li&gt;
  &lt;li&gt;시그널 보내기 함수에서는 조건만을 인자로 받는 것에 유의해야 함&lt;/li&gt;
  &lt;li&gt;대기하는 쓰레드가 조건을 검사할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 문 사용해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;275-컴파일과-실행&quot;&gt;27.5 컴파일과 실행&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-pthread&lt;/code&gt; 플래그를 추가하여 pthread 라이브러리와 링크해야 함&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prompt&amp;gt; gcc -o main main.c -Wall -pthread
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;28장-락&quot;&gt;28장. 락&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;락(lock)&lt;/strong&gt; 을 이용하여 병행 프로그램의 근본적인 문제를 다룬다.&lt;br /&gt;
임계 영역을 락으로 둘러서 하나의 원자 단위 명령어인 것처럼 실행되도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;281-락-기본-개념&quot;&gt;28.1 락: 기본 개념&lt;/h3&gt;

&lt;p&gt;락은 일종의 변수로 사용하기 위해 락 변수를 먼저 선언해야 한다.&lt;br /&gt;
두 개의 상태가 있는데 &lt;strong&gt;사용가능 상태(available, unlocked, free)&lt;/strong&gt; 상태와 &lt;strong&gt;사용 중(acquired)&lt;/strong&gt; 상태가 존재한다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock()&lt;/code&gt; 루틴 호출을 통해 락 획득을 시도하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlock()&lt;/code&gt; 호출을 하면 락은 다시 사용 가능한 상태로 된다.&lt;/p&gt;

&lt;p&gt;락을 획득한 쓰레드는 락 &lt;strong&gt;소유자(owner)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;282-pthread-락&quot;&gt;28.2 Pthread 락&lt;/h3&gt;

&lt;p&gt;쓰레드 간에 &lt;strong&gt;상호 배제(mutual exclusion)&lt;/strong&gt; 기능을 제공하기 때문에 POSIX 라이브러리는 락을 &lt;strong&gt;mutex&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_MUTEX_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Phtread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 변수를 보호하기 위해 다른 락을 사용할 수도 있다.&lt;br /&gt;
하나의 락으로 모든 임계 영역들을 보호하는 것은 &lt;strong&gt;coarse-grained&lt;/strong&gt; 락 사용 전략,&lt;br /&gt;
다수의 쓰레드가 서로 다른 락으로 보호된 코드를 실행하는 것은 &lt;strong&gt;미세(fine-grained)&lt;/strong&gt; 락 사용 전략이라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;283-락의-구현&quot;&gt;28.3 락의 구현&lt;/h3&gt;

&lt;p&gt;사용 가능한 락을 만들기 위해서는 하드웨어와 운영체제 도움이 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;284-락의-평가&quot;&gt;28.4 락의 평가&lt;/h3&gt;

&lt;p&gt;락 설계시, 정상동작 여부 판단을 위해 판단 기준이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상호 배제&lt;/strong&gt; 를 제대로 지원하는가
    &lt;ul&gt;
      &lt;li&gt;임계 영역 내로 다수의 쓰레드가 진입을 막을 수 있는가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공정성(fairness)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;락 획득에 대한 공정한 기회가 주어지는가&lt;/li&gt;
      &lt;li&gt;락을 획득하지 못하는 굶주리는(starve) 경우가 발생하는가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능(performance)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;경쟁이 전혀 없는 경우의 성능&lt;/li&gt;
      &lt;li&gt;단일 CPU 상에서 락을 획득하려고 경쟁할 때 성능&lt;/li&gt;
      &lt;li&gt;멀티 CPU 상황에서 락 경쟁 시의 성능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;285-인터럽트-제어&quot;&gt;28.5 인터럽트 제어&lt;/h3&gt;

&lt;p&gt;초창기 단일 프로세스 시스템에서는 임계 영역 내에서는 인터럽트를 비활성화화여 상호 배제를 지원했다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DisableInterrupts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EnableInterrupts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;장점&quot;&gt;장점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;단순&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점&quot;&gt;단점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;쓰레드가 인터럽트를 활성/비활성화하는 &lt;strong&gt;특권(privileged)&lt;/strong&gt; 연산을 실행할 수 있도록 허가 필요
    &lt;ul&gt;
      &lt;li&gt;악의적인 프로그램이 독점하거나 무한 반복문에 빠질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;멀티프로세서에서 적용 불가능
    &lt;ul&gt;
      &lt;li&gt;특정 프로세서의 인터럽트 비활성화는 다른 프로세서에 영향을 주지 않음 (임계 영역 진입 가능)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장시간동안 인터럽트를 중지하면 중요한 시점을 놓칠 수 있음&lt;/li&gt;
  &lt;li&gt;최신의 CPU 들에서는 느리게 실행되는 경향이 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;286-실패한-시도-오직-loadstore-명령어만-사용하기&quot;&gt;28.6 실패한 시도: 오직 load/store 명령어만 사용하기&lt;/h3&gt;

&lt;p&gt;load/store 명령어만으로는 락의 구현이 불가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상호 배제 제공 실패
    &lt;ul&gt;
      &lt;li&gt;적시에 인터럽트가 발생하면 두 쓰레드 모두 플래그가 예상치 못한 값으로 설정되어 임계 영역에 두 쓰레드가 진입 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능 저하
    &lt;ul&gt;
      &lt;li&gt;다른 쓰레드가 락을 해제할 때까지 시낭 낭비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;287-test-and-set-을-사용하여-작동하는-스핀-락-구현하기&quot;&gt;28.7 Test-And-Set 을 사용하여 작동하는 스핀 락 구현하기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;test-and-set&lt;/strong&gt; 명령어 또는 &lt;strong&gt;원자적 교체(atomic exchange)&lt;/strong&gt; 명령어가 락 지원을 위한 하드웨어 기법 중 가장 기본이다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// old_ptr 의 이전 값 가져옴&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// old_ptr 에 new 값 설정&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestAndSet&lt;/code&gt; 명령어는 이전 값을 &lt;strong&gt;검사(test)&lt;/strong&gt; 하면서 메모리에 새로운 값을 &lt;strong&gt;설정(set)&lt;/strong&gt; 하기 때문에 원자적으로 수행된다.&lt;br /&gt;
이 명령어만으로 &lt;strong&gt;스핀 락(spin lock)&lt;/strong&gt; 을 만들 수 있다.&lt;br /&gt;
스핀 락은 가장 기초적인 형태의 락으로, 락을 획득할 때까지 CPU 사이클을 소모하면서 회전한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//do nothing&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unlcok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;288-스핀-락-평가&quot;&gt;28.8 스핀 락 평가&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;상호 배제의 정확성
    &lt;ul&gt;
      &lt;li&gt;임의의 시간에 단 하나의 쓰레드만이 임계 영역에 진입할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공정성 보장하지 못함
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 문을 회전 중인 쓰레드는 경쟁에 밀려 그 상태에 남아있을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;단일 CPU 의 경우 오버헤드가 클 수 있음 (CPU 사이클 낭비)&lt;/li&gt;
      &lt;li&gt;다중 CPU 의 경우 합리적으로 동작 (다른 CPU 에서 대기)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;289-compare-and-swap&quot;&gt;28.9 Compare-And-Swap&lt;/h3&gt;

&lt;p&gt;다른 하드웨어 기법으로는 SPARC 의 &lt;strong&gt;Compare-And-Swap&lt;/strong&gt;, x86 에서는 &lt;strong&gt;Compare-And-Exchange&lt;/strong&gt; 가 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CompareAndSwap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;original&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;original&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;original&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 기법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptr&lt;/code&gt; 이 가리키고 있는 주소의 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extected&lt;/code&gt; 변수와 일치하는지 검사하는 것이다.&lt;br /&gt;
&lt;strong&gt;Compare-And-Swap&lt;/strong&gt; 명령어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestAndSet&lt;/code&gt; 명령어보다 더 강력하고 &lt;strong&gt;대기 없는 동기화(wait-free synchronization)&lt;/strong&gt; 를 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;2810-load-linked-그리고-store-conditional&quot;&gt;28.10 Load-Linked 그리고 Store-Conditional&lt;/h3&gt;

&lt;p&gt;MIPS 구조에서는 &lt;strong&gt;load-linked&lt;/strong&gt; 와 &lt;strong&gt;store-conditional&lt;/strong&gt; 명령어를 사용하여 락이나 병행 연산을 위한 자료구조를 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadLinked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StoreConditional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;updat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;since&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoadLinked&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 성공&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 갱신 실패&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadLinked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StoreConditional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 회전&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2811-fetch-and-add&quot;&gt;28.11 Fetch-And-Add&lt;/h3&gt;

&lt;p&gt;이 기법은 Fetch-And-Add 명령어로 원자적으로 특정 주소의 예전 값을 반환하면서 값을 증가시킨다. &lt;br /&gt;
모든 쓰레드들이 각자의 순서에 따라 진행&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FetchAndAdd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2812-요약-과도한-스핀&quot;&gt;28.12 요약: 과도한 스핀&lt;/h3&gt;

&lt;p&gt;위에서 소개한 하드웨어 기반의 락은 간단하고 잘 동작한다.&lt;br /&gt;
하지만 쓰레드가 스핀 구문을 실행하면서 변경되기를 기다리며 시간을 낭비한다.&lt;br /&gt;
쓰레드가 경쟁하게 되면 상황은 더 심해진다.&lt;/p&gt;

&lt;h3 id=&quot;2813-간단한-접근법-조건-없는-양보&quot;&gt;28.13 간단한 접근법: 조건 없는 양보!&lt;/h3&gt;

&lt;p&gt;다른 쓰레드에서 락을 획득한 상태라서 스핀만 무한히 하는 경우에 대한 해결책 알아본다. &lt;br /&gt;
락이 해제되기를 기다려야 할 경우 CPU 를 다른 쓰레드에게 양보하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 다른 쓰레드에게 CPU 양보&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;쓰레드는 실행중(running), 준비(ready), 막힘(blocked) 세 가지 상태가 있다.&lt;br /&gt;
&lt;strong&gt;양보(yield)&lt;/strong&gt; 시스템 콜은 실행 중(running) 상태에서 준비(ready) 상태로 변환하여 다른 쓰레드가 실행 중 상태로 전이하도록 한다.&lt;br /&gt;
하지만 이 기법은 문맥 교환 비용이 상당하며 낭비가 많다.&lt;/p&gt;

&lt;h3 id=&quot;2814-큐의-사용-스핀-대신-잠자기&quot;&gt;28.14 큐의 사용: 스핀 대신 잠자기&lt;/h3&gt;

&lt;p&gt;다수의 쓰레드가 대기하는 경우 명시적으로 쓰레드를 선택할 수 있도록 운영체제의 지원과 큐를 이용한 대기 쓰레드 관리가 필요하다.&lt;br /&gt;
Solaris 방식에서는 쓰레드를 잠재우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;park()&lt;/code&gt;, 깨우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unpark(threadID)&lt;/code&gt; 함수가 있다.&lt;/p&gt;

&lt;p&gt;락 대기자 전용 큐를 사용하여 락을 더 효율적이고 기아 현상을 피할 수 있도록 구현한다.&lt;br /&gt;
이 방식은 스핀 대기 시간이 상당히 짧아 오버헤드가 작다.&lt;/p&gt;

&lt;p&gt;하지만 쓰레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;park()&lt;/code&gt; 호출 직전에 다른 쓰레드에서 락을 해제하면 블럭 상태(&lt;strong&gt;wakeup/waiting race&lt;/strong&gt; 문제)가 되기 때문에 경쟁 조건이 발생할 수 있다.  &lt;br /&gt;
이 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setpark()&lt;/code&gt; 를 추가하면서 해결했다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 회전하면서 guard 락 획득&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 락 획득&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gettid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;park&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 회전하면서 guard 락 획득&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; 
         &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 락 포기&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;unpark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue_remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 락 획득&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2815-다른-운영체제-다른-지원&quot;&gt;28.15 다른 운영체제, 다른 지원&lt;/h3&gt;

&lt;p&gt;Linux 의 경우 &lt;strong&gt;futex&lt;/strong&gt; 를 지원한다. &lt;br /&gt;
futex 는 특정 물리 메모리 주소 그리고 커널에 정의된 큐를 갖고 있다.
쓰레드를 블럭시키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futex_wait(address, expected)&lt;/code&gt; , 큐에서 대기하고 있는 쓰레드를 깨우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futext_wake(address)&lt;/code&gt; 명령어가 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;2816-2단계-락&quot;&gt;28.16 2단계 락&lt;/h3&gt;

&lt;p&gt;Linux의 락은 &lt;strong&gt;2단계(two-phase lock)&lt;/strong&gt; 이라고 불린다.&lt;br /&gt;
첫 번째 단계에서는 회전하며 대기하고, 획득하지 못했다면 두 번째 단계에서 호출자는 차단된다.&lt;br /&gt;
락 해제시 블럭된 쓰레드중 하나를 깨웩 된다.&lt;/p&gt;</content><author><name></name></author><category term="study" /><category term="study" /><category term="book" /><category term="operation-system" /><summary type="html">운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다. 이 글에서는 병행성에 대해 다룬 25장부터 28장까지의 내용을 정리한다.</summary></entry><entry><title type="html">[Study] 운영체제 아주 쉬운 세가지 이야기 20장~24장</title><link href="https://devyonghee.github.io/study/2022/11/24/operation-system-three-easy-pieces-20-24/" rel="alternate" type="text/html" title="[Study] 운영체제 아주 쉬운 세가지 이야기 20장~24장" /><published>2022-11-24T00:00:00+00:00</published><updated>2022-11-24T00:00:00+00:00</updated><id>https://devyonghee.github.io/study/2022/11/24/operation-system-three-easy-pieces-20-24</id><content type="html" xml:base="https://devyonghee.github.io/study/2022/11/24/operation-system-three-easy-pieces-20-24/">&lt;p&gt;운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.&lt;br /&gt;
이 글에서는 20장부터 24장까지의 내용을 정리한다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;20장-페이징-더-작은-테이블&quot;&gt;20장. 페이징: 더 작은 테이블&lt;/h2&gt;

&lt;p&gt;페이징의 두번째 문제는 &lt;strong&gt;페이지 테이블의 크기&lt;/strong&gt;다.&lt;br /&gt;
페이지 테이블이 크면 많은 메모리 공간을 차지한다.&lt;/p&gt;

&lt;h3 id=&quot;201-간단한-해법-더-큰-페이지&quot;&gt;20.1 간단한 해법: 더 큰 페이지&lt;/h3&gt;

&lt;p&gt;페이지 크기를 증가시키면 페이지 테이블의 크기를 줄일 수 있다.&lt;br /&gt;
페이지 크기가 4배 증가되면 페이지 테이블의 크기는 1/4로 줄어든다.&lt;/p&gt;

&lt;p&gt;하지만 부작용으로 &lt;strong&gt;내부 단편화(internal fragmentation)&lt;/strong&gt; 가 발생한다.&lt;br /&gt;
페이지 내부의 낭비 공간이 증가하는 것이다.&lt;br /&gt;
할당받은 페이지의 일부분만 사용하게 되기 때문에 메모리가 금방 고갈되는 현상이 발생된다.&lt;/p&gt;

&lt;h3 id=&quot;202-하이브리드-접근-방법-페이징과-세그멘트&quot;&gt;20.2 하이브리드 접근 방법: 페이징과 세그멘트&lt;/h3&gt;

&lt;p&gt;페이징과 세그멘트 방법을 조합하는 것을 &lt;strong&gt;하이브리드(hybrid)&lt;/strong&gt; 라고 한다.&lt;br /&gt;
두 방법을 결합하여 테이블 크기를 줄이는 것이다.&lt;/p&gt;

&lt;p&gt;프로세스의 전체 주소 공간을 위한 페이지 테이블 대신, 논리 세그멘트마다 따로 페이지 테이블을 둔다.&lt;br /&gt;
세그멘테이션은 물리 주속 시작 위치를 나타내는 &lt;strong&gt;베이스(base)&lt;/strong&gt; 레지스터, 크기를 나타내는 &lt;strong&gt;바운드(bound)&lt;/strong&gt; 또는 &lt;strong&gt;리미트(limit)&lt;/strong&gt; 레지스터가 존재한다.&lt;br /&gt;
여기서 베이스 레지스터는 세그먼트 시작 주소가 아니라 &lt;strong&gt;세그멘트의 페이지 테이블의 시작 주소&lt;/strong&gt;를 갖는다.&lt;/p&gt;

&lt;p&gt;TLB 미스가 발생한 경우 다음과 같이 동작한다. (하드웨어 기반으로 가정)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;하드웨어가 세그멘트 비트(SN) 을 사용하여 어떤 베이스와 바운드 쌍을 사용할지 결정&lt;/li&gt;
  &lt;li&gt;레지스터에 있는 물리 주소를 VPN과 페이지 테이블 항목(PTE) 주소 획득&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SN           = (VirtualAddress &amp;amp; SEG_MASK) &amp;gt;&amp;gt; SN_SHIFT
VPN          = (VirtualAddress &amp;amp; VPN_MASK) &amp;gt;&amp;gt; VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;문제점&quot;&gt;문제점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;세그멘테이션을 사용
    &lt;ul&gt;
      &lt;li&gt;빈 공간이 많은 힙의 경우 페이지 테이블의 낭비를 면치 못함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;외부 단편화 유발
    &lt;ul&gt;
      &lt;li&gt;페이지 테이블 크기에 제한이 없어 다양한 크기를 가짐&lt;/li&gt;
      &lt;li&gt;메모리상에서 테이블용 공간을 확보하는 것이 복잡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;203-멀티-레벨-페이지-테이블&quot;&gt;20.3 멀티 레벨 페이지 테이블&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/multi-level-page-table.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/multi-level-page-table.png&quot; data-rjs=&quot;/images/study/operating-system/multi-level-page-table.png&quot; class=&quot;zooming&quot; alt=&quot;선형(좌)과 멀티 레벨(우) 페이지 테이블&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        선형(좌)과 멀티 레벨(우) 페이지 테이블
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;세그멘테이션을 사용하지 않고 페이지 테이블 크기를 줄이는 또 다른 방법은 &lt;strong&gt;멀티 레벨 페이지 테이블(multi-level page table)&lt;/strong&gt; 이다.&lt;br /&gt;
멀티 레벨 페이지 테이블에서는 선형 페이지 테이블을 트리 구조로 표현한다.&lt;/p&gt;

&lt;p&gt;멀티 레벨 페이지 테이블 개념은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 테이블을 페이지 크기의 단위로 나눈다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;페이지 디렉터리(page directory)&lt;/strong&gt; 자료 구조로 각 페이지의 할당 여부와 위치 파악
    &lt;ul&gt;
      &lt;li&gt;페이지 디렉터리에는 페이지 테이블의 구성요소인 각 페이지의 존재 여부와 위치 정보를 가지고 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이지 디렉터리는 &lt;strong&gt;페이지 디렉터리 항목(page directory entries, PDE)&lt;/strong&gt; 들로 구성, 페이지 테이블의 한 페이지 표현
    &lt;ul&gt;
      &lt;li&gt;PDE 의 구성은 PTE 와 유사, &lt;strong&gt;유효 비트(valid)&lt;/strong&gt; 와 &lt;strong&gt;페이지 프레임 번호(page frame number, PFN)&lt;/strong&gt; 를 가짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/multi-level-page-table-virtual-address-space.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/multi-level-page-table-virtual-address-space.png&quot; data-rjs=&quot;/images/study/operating-system/multi-level-page-table-virtual-address-space.png&quot; class=&quot;zooming&quot; alt=&quot;멀티 레벨 페이지 테이블 가상 주소 공간&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        멀티 레벨 페이지 테이블 가상 주소 공간
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;VPN 에서 페이지-디렉터리 인덱스(page-directory index, PDIndex) 추출하여 PDE 주소 찾음
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PDEAddr = PageDirBase + (PDIndex * sizeof(PDE))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PDE 가 유효하다면 VPN 나머지 주소로 &lt;strong&gt;페이지-테이블 인덱스 (page-table index, PTIndex)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PTEAddr = (PDE.PFN &amp;lt;&amp;lt; SHIFT) + (PTIndex * sizeof(PTE))&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PhysAddr = (PTE.PFN &amp;lt;&amp;lt; SHIFT) + offset&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2단계 이상인 경우 페이지 디렉터리가 추가되면서 가상 주소가 새로운 PD Index 로 추가 분할&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;장점&quot;&gt;장점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간 할당
    &lt;ul&gt;
      &lt;li&gt;작은 크기의 페이지 테이블로 주소 공간 표현 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이지 테이블을 페이지 크기로 분할하여 메모리 관리 용이
    &lt;ul&gt;
      &lt;li&gt;페이지 테이블이 산재해 있어도 페이지 디렉터리로 위치 파악이 가능하므로 공간 할당이 유연&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;문제점-1&quot;&gt;문제점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;추가 비용 발생
    &lt;ul&gt;
      &lt;li&gt;TLB 미스 시, 주소 변환을 위해 두 번의 메모리 로드 발생 (페이지 디렉터리 와 PTE 접근)&lt;/li&gt;
      &lt;li&gt;TLB 히트 시 성능은 동일, TLB 미스 시 두 배의 시간 소요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡도
    &lt;ul&gt;
      &lt;li&gt;메모리 자원 절약을 위해, 페이지 테이블 검색이 복잡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;204-역-페이지-테이블&quot;&gt;20.4 역 페이지 테이블&lt;/h3&gt;

&lt;p&gt;또 다른 공간 절약 방법으로 &lt;strong&gt;역 페이지 테이블(inverted page table)&lt;/strong&gt; 이 존재한다.  &lt;br /&gt;
여러 개의 페이지 테이블(프로세스당 하나씩) 대신 시스템에 단 하나의 페이지를 두는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;물리 페이지를 가상 주소 상의 페이지로 변환&lt;/li&gt;
  &lt;li&gt;각 항목은 물리 페이지를 사용중인 &lt;strong&gt;프로세스 번호&lt;/strong&gt;, 해당 &lt;strong&gt;가상 페이지 번호&lt;/strong&gt; 를 가지고 있음&lt;/li&gt;
  &lt;li&gt;주소 변환을 위해 전체 테이블 검색
    &lt;ul&gt;
      &lt;li&gt;탐색 속도 향상을 위해 주로 해시 테이블 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;205-페이지-테이블을-디스크로-스와핑하기&quot;&gt;20.5 페이지 테이블을 디스크로 스와핑하기&lt;/h3&gt;

&lt;p&gt;모든 페이지 테이블을 메모리에 상주하기에는 너무 크다.&lt;br /&gt;
어떤 시스템들은 페이지 테이블들을 커널 가상 메모리에 위치시키고, 메모리가 부족하면 디스크에 &lt;strong&gt;스왑(swap)&lt;/strong&gt; 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21장-물리-메모리-크기의-극복-메커니즘&quot;&gt;21장. 물리 메모리 크기의 극복: 메커니즘&lt;/h2&gt;

&lt;p&gt;다수의 프로세스들이 동시에 큰 주소 공간을 사용하는 상황을 가정한다.&lt;br /&gt;
이를 위해 메모리 계층에 레이어 추가가 필요하다.&lt;br /&gt;
현대 시스템에서는 보통 &lt;strong&gt;하드 디스크 드라이브&lt;/strong&gt;를 큰 주소 공간을 보관해두는 공간으로 사용된다.&lt;/p&gt;

&lt;p&gt;편리함과 사용 용이성을 위해 프로세스에게 주소 공간을 충분히 제공해야 한다.&lt;br /&gt;
&lt;strong&gt;스왑 공간&lt;/strong&gt; 을 사용하면 프로세스들에게 큰 가상 메모리가 있는 것 같은 환상을 줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;211-스왑-공간&quot;&gt;21.1 스왑 공간&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스왑 공간(swap space)&lt;/strong&gt; 은 디스크에 페이지들을 저장할 수 있는 일정 공간이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스왑 공간의 입출력 단위는 페이지라고 가정
    &lt;ul&gt;
      &lt;li&gt;swap out: 메모리 페이지를 읽어서 스왑 공간에 저장&lt;/li&gt;
      &lt;li&gt;swap in: 페이지를 읽어 메모리에 탑재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;운영체제는 스왑 공간에 있는 모든 페이지들의 &lt;strong&gt;디스크 주소&lt;/strong&gt; 를 저장해야 함&lt;/li&gt;
  &lt;li&gt;스왑 공간을 이용하면, 실제 물리메모리 공간보다 많은 공간이 존재하는 것처럼 가장 가능&lt;/li&gt;
  &lt;li&gt;스왑 공간에만 스왑을 할 수 있는 것은 아님
    &lt;ul&gt;
      &lt;li&gt;코드 영역의 물리 페이지는 다른 페이지가 사용할 수 있는데 이는 파일 시스템 영역을 스왑 목적으로 사용하는 것임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;212-present-bit&quot;&gt;21.2 Present Bit&lt;/h3&gt;

&lt;p&gt;하드웨어 기반 TLB 를 사용하는 시스템에서 메모리 참조 과정을 다시 살펴본다.&lt;/p&gt;

&lt;h4 id=&quot;tlb-히트&quot;&gt;TLB 히트&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;가상 주소에서 VPN 추출&lt;/li&gt;
  &lt;li&gt;TLB 에 정보가 있는지 검사(TLB 히트)&lt;/li&gt;
  &lt;li&gt;물리 주소 얻은 후 메모리로 가져옴&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;tlb-미스&quot;&gt;TLB 미스&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;가상 주소에서 VPN 추출&lt;/li&gt;
  &lt;li&gt;TLB 에 정보가 있는지 검사(TLB 미스)&lt;/li&gt;
  &lt;li&gt;페이지 테이블의 메모리 주소 파악(페이지 테이블 베이스 레지스터 이용)&lt;/li&gt;
  &lt;li&gt;VPN 을 인덱스로 &lt;strong&gt;페이지 테이블 항목(PTE)&lt;/strong&gt; 추출&lt;/li&gt;
  &lt;li&gt;물리메모리에 존재하면 PTE 에서 PFN 정보 추출 후 TLB 탑재&lt;/li&gt;
  &lt;li&gt;명령어 재실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;페이지가 디스크로 스왑되기 위해서 &lt;strong&gt;present bit&lt;/strong&gt; 를 이용하여 PTE 에서 페이지가 물리 메모리에 존재하는지 여부를 표시한다.&lt;br /&gt;
1 이라면 물리 메모리에 페이지 존재, 0이면 디스크 어딘가에 존재하는 것이다.&lt;/p&gt;

&lt;p&gt;물리 메모리에 존재하지 않는 페이지를 접근하는 행위는 &lt;strong&gt;페이지 폴트(page fault)&lt;/strong&gt; 라고 한다.
페이지 폴트가 발생하면 운영체제로 제어권이 넘어가며 &lt;strong&gt;페이지 폴트 핸들러(page-fault handler)&lt;/strong&gt; 가 실행된다.&lt;/p&gt;

&lt;h3 id=&quot;213-페이지-폴트&quot;&gt;21.3 페이지 폴트&lt;/h3&gt;

&lt;p&gt;페이지 폴트가 발생하면 운영체제의 &lt;strong&gt;페이지 폴트 핸들러&lt;/strong&gt; 가 처리한다.&lt;br /&gt;
페이지 폴트 발생 시, 운영체제는 페이지 테이블 항목(PTE) 에서 페이지의 디스크상 위치를 파악하여, 메모리로 탑재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;디스크 I/O 가 완료되면 운영체제는 PTE 의 PFN 값을 탑재된 페이지의 메모리 위치로 갱신&lt;/li&gt;
  &lt;li&gt;페이지 폴트를 발생시킨 명령어 재실행&lt;/li&gt;
  &lt;li&gt;재실행으로 인해 TLB 미스가 발생되면 TLB 미스 처리 과정이후 TLB 값 갱신(페이지 폴트 처리시 함께 갱신도 가능)&lt;/li&gt;
  &lt;li&gt;재실행 시에 TLB 에서 주소 변환 정보 찾고 물리 주소에서 데이터 가져옴&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I/O 실행은 시간이 많이 소요되므로 프로세스는 &lt;strong&gt;차단된(blocked)&lt;/strong&gt; 상태가 된다.  &lt;br /&gt;
멀티 프로그램된 시스템에서는 다른 프로세스의 실행을 &lt;strong&gt;중첩(overlap)&lt;/strong&gt; 시킬 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;214-메모리에-빈-공간이-없으면&quot;&gt;21.4 메모리에 빈 공간이 없으면?&lt;/h3&gt;

&lt;p&gt;스왑 공간으로부터 &lt;strong&gt;페이지를 가져오기 위한 (page-in)&lt;/strong&gt; 여유 메모리가 부족하면, 다른 페이지들을 먼저 &lt;strong&gt;페이지 아웃(page-out)&lt;/strong&gt; 할 수 있다.&lt;br /&gt;
&lt;strong&gt;교체(replace)&lt;/strong&gt; 페이지를 선택하는 것이 &lt;strong&gt;페이지 교체 정책(page-replacement policy)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;215-페이지-폴트의-처리&quot;&gt;21.5 페이지 폴트의 처리&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;탑재할 페이지를 위한 물리 프레임 확보&lt;/li&gt;
  &lt;li&gt;여유 프레임이 없으면 교체 알고리즘으로 페이지 아웃(page-out) 으로 여유 공간 확보&lt;/li&gt;
  &lt;li&gt;I/O 요청ㅇ로 스왑 영역에서 페이지 읽어옴&lt;/li&gt;
  &lt;li&gt;페이지 테이블을 갱신하고 명령어 재실행&lt;/li&gt;
  &lt;li&gt;재실행하면 TLB 미스가 발생하며, 다시 재시도할 때 TLB 히트&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;216-교체는-실제-언제-일어나는가&quot;&gt;21.6 교체는 실제 언제 일어나는가&lt;/h3&gt;

&lt;p&gt;교체 알고리즘은 효율적이지 않기 때문에 운영체제는 항상 여유 메모리 공간을 확보하고 있어야 한다.&lt;br /&gt;
그래서 대부분의 운영체제들은 여유 공간에 관련된 &lt;strong&gt;최댓값(high watermark, HW)&lt;/strong&gt; 과 &lt;strong&gt;최솟값(low watermark, LW)&lt;/strong&gt; 을 설정하여 교체 알고리즘 작동에 활용한다.&lt;br /&gt;
여유 공간의 크기가 &lt;strong&gt;최솟값보다 작아지면&lt;/strong&gt; 여유 공간 확보를 위한 백그라운드 쓰레드가 &lt;strong&gt;최댓값에 이를 때까지&lt;/strong&gt; 페이지를 제거한다.
백그라운드 쓰레드는 &lt;strong&gt;스왑 데몬(swap daemon)&lt;/strong&gt; 또는 &lt;strong&gt;페이지 데몬(page daemon)&lt;/strong&gt; 이라고 불린다.&lt;/p&gt;

&lt;p&gt;많은 시스템들은 성능을 높이기 위해 페이지들을 &lt;strong&gt;클러스터(cluster)&lt;/strong&gt; 나 &lt;strong&gt;그룹(group)&lt;/strong&gt; 으로 묶어 스왑 파티션에 저장하여 디스크의 효율을 높인다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22장-물리-메모리-크기의-극복-정책&quot;&gt;22장. 물리 메모리 크기의 극복: 정책&lt;/h2&gt;

&lt;p&gt;운영체제는 빈 메모리 공간이 부족해서 &lt;strong&gt;메모리 압박(memory pressure)&lt;/strong&gt; 을 받으면 강제적으로 &lt;strong&gt;페이징 아웃(paging out)&lt;/strong&gt; 을 수행한다.&lt;br /&gt;
내보낼(evict) 페이지 선택은 페이지 교체 정책에 의해 결정된다.&lt;/p&gt;

&lt;h3 id=&quot;221-캐시-관리&quot;&gt;22.1 캐시 관리&lt;/h3&gt;

&lt;p&gt;캐시를 위한 교체 정책의 목표는 캐시 미스를 최소화, 캐시 히트를 최대화하는 것이다.&lt;br /&gt;
캐시 히트와 미스 횟수를 알면 &lt;strong&gt;평균 메모리 접근 시간(average memory access time, AMAT)&lt;/strong&gt; 을 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;AMAT = T&lt;sub&gt;M&lt;/sub&gt; + (P&lt;sub&gt;Miss&lt;/sub&gt; * T&lt;sub&gt;D&lt;/sub&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;T&lt;sub&gt;M&lt;/sub&gt; : 메모리 접근 비용&lt;/li&gt;
  &lt;li&gt;T&lt;sub&gt;D&lt;/sub&gt; : 디스크 접근 비용&lt;/li&gt;
  &lt;li&gt;P&lt;sub&gt;Miss&lt;/sub&gt; : 캐시 미스 확률&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;222-최적-교체-정책&quot;&gt;22.2 최적 교체 정책&lt;/h3&gt;

&lt;p&gt;교체 정책을 이해하기 위해서는 &lt;strong&gt;최적 교체 정책(The Optimal Replacement Policy)&lt;/strong&gt; 을 아는 것이 좋다.&lt;br /&gt;
최적 교체 정책은 가장 나중에 접근될 페이지를 교체하여 미스를 최소화 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/optimal-replacement-policy.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/optimal-replacement-policy.png&quot; data-rjs=&quot;/images/study/operating-system/optimal-replacement-policy.png&quot; class=&quot;zooming&quot; alt=&quot;최적의 교체 정책의 흐름&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        최적의 교체 정책의 흐름
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;캐시가 비워진 상태이기 때문에 첫 세 번은 미스가 발생된다.&lt;br /&gt;
이러한 미스는 &lt;strong&gt;최초 시작 미스(cold start miss)&lt;/strong&gt; 또는 &lt;strong&gt;강제 미스(compulsory miss)&lt;/strong&gt; 라고 한다. &lt;br /&gt;
그리고 현재 탑재되어 있는 페이지들 미래를 살펴보고 먼 미래에 접근될 페이지를 내보낸다.&lt;br /&gt;
하지만 일반적으로 미래는 알 수 없기 때문에 최적 기법의 &lt;strong&gt;구현은 불가능&lt;/strong&gt; 하다.&lt;/p&gt;

&lt;h3 id=&quot;223-간단한-정책-fifo&quot;&gt;22.3 간단한 정책: FIFO&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/page-fifo-policy.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/page-fifo-policy.png&quot; data-rjs=&quot;/images/study/operating-system/page-fifo-policy.png&quot; class=&quot;zooming&quot; alt=&quot;FIFO 정책의 흐름&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        FIFO 정책의 흐름
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;FIFO 교체 방식에서 페이지가 시스템에 들어오면 큐에 삽입되고, 교체를 해야할 경우 큐의 테일에 있는 페이지가 내보내진다.&lt;br /&gt;
FIFO 교체 방식은 구현이 쉽지만 성능이 안좋다.&lt;/p&gt;

&lt;h3 id=&quot;224-또-다른-간단한-정책-무작위-선택&quot;&gt;22.4 또 다른 간단한 정책: 무작위 선택&lt;/h3&gt;

&lt;p&gt;이 방식은 무작위로 선택하여 교체하는 방식이다.&lt;br /&gt;
구현은 쉽지만 내보낼 페이지가 제대로 선택되지 않을 수 있다.&lt;br /&gt;
무작위 선택 방식의 성능은 그때그때 달라진다.&lt;/p&gt;

&lt;h3 id=&quot;225-과거-정보의-사용-lru&quot;&gt;22.5 과거 정보의 사용: LRU&lt;/h3&gt;

&lt;p&gt;페이지 교체 정책이 활용될 수 있는 페이지의 정보는 &lt;strong&gt;빈도수(frequency)&lt;/strong&gt; 와 &lt;strong&gt;최근성(recency)&lt;/strong&gt; 가 있다.&lt;br /&gt;
&lt;strong&gt;지역성의 원칙(principle of locality)&lt;/strong&gt; 에 따르면 최근에 접근된 페이지일수록 다시 접근될 확률이 높다.&lt;br /&gt;
그래서 과거 이력을 기반한 다음과 같은 교체 알고리즘들이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Least-Frequently-Used(LFU) : 가장 적은 빈도로 사용된 페이지 교체&lt;/li&gt;
  &lt;li&gt;Least-Recently-Used(LRU) : 가장 오래 전에 사용됐던 페이지 교체&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이와 반대인 정책도 존재하지만 지역성 접근 특성을 무시하기 때문에 잘 동작하지 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Most-Frequently-Used(MFU) : 가장 많은 빈도로 사용된 페이지 교체&lt;/li&gt;
  &lt;li&gt;Most-Recently-Used(MRU) : 가장 최근에 사용된 페이지 교체&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;226-워크로드에-따른-성능-비교&quot;&gt;22.6 워크로드에 따른 성능 비교&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;지역성이 없다면 어느 정책을 사용하든 상관 없음
    &lt;ul&gt;
      &lt;li&gt;LRU, FIFO, 무작용 선택 모두 비슷한 성능을 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시가 충분히 커서 모든 워크로드를 포함할 수 있다면 어느 정책을 사용하든 상관 없음
    &lt;ul&gt;
      &lt;li&gt;모든 블럭들이 캐시에 들어갈 수 있으면 히트율이 100%&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;최적 기법이 다른 정책들보다 좋은 성능을 보임&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;80대 20 워크로드 인 경우 (20% 페이지들에서 80% 참조, 80% 페이지들에서 20% 참조)
    &lt;ul&gt;
      &lt;li&gt;최적 기법 &amp;gt; LRU &amp;gt; FIFO 순서로 좋은 성능을 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;순차 반복 워크로드인 경우 (여러 페이지들을 순차적으로 참조)
    &lt;ul&gt;
      &lt;li&gt;오래된 페이지들을 내보내기 때문에 LRU 와 FIFO 정책에서 가장 안좋은 성능을 보임&lt;/li&gt;
      &lt;li&gt;무작위 선택 정책은 최적 기법보다 미치지는 못하지만 좋은 성능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;227-과거-이력-기반-알고리즘-구현&quot;&gt;22.7 과거 이력 기반 알고리즘 구현&lt;/h3&gt;

&lt;p&gt;과거 정보에 기반은 둔 정책을 구현하기 위해서는 많은 작업이 필요하다.&lt;br /&gt;
어떤 페이지가 가장 최근 또는 오래 전에 사용됐는지 참조 정보 기록이 필요하지만, 기록에 주의하지 않으면 성능이 떨어질 수 있다.&lt;/p&gt;

&lt;p&gt;시스템 페이지 수가 증가하면 가장 오래전에 사용된 페이지를 찾는데 고비용 연산이 된다.&lt;br /&gt;
가장 오래된 페이지가 아닌 비슷하게 오래된 페이지를 찾는 방법을 고민해본다.&lt;/p&gt;

&lt;h3 id=&quot;228-lru-정책-근사하기&quot;&gt;22.8 LRU 정책 근사하기&lt;/h3&gt;

&lt;p&gt;LRU 를 근사하는 식으로 만들면 구현이 쉬워진다.&lt;br /&gt;
이를 위해 &lt;strong&gt;use bit(또는 reference bit)&lt;/strong&gt; 가 필요하다.&lt;br /&gt;
각 페이지 마다 하나의 use bit 가 있으며 페이지가 참조될 때마다 1로 설정된다.&lt;/p&gt;

&lt;p&gt;use bit 를 활용하는 방법들에 대해 알아본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시계 알고리즘(clock algorithm)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;모든 페이지들이 환형 리스트로 구성한다고 가정&lt;/li&gt;
      &lt;li&gt;시계 바늘 (clock hand) 이 특정 페이지를 가리킴&lt;/li&gt;
      &lt;li&gt;페이지를 교체해야할 때 현재 바늘이 가리키는 페이지의 use bit 검사&lt;/li&gt;
      &lt;li&gt;1이라면 최근에 사용된 것이므로 교체 대상이 아니면서 use bit 를 0으로 설정&lt;/li&gt;
      &lt;li&gt;시계 바늘은 P+1 로 이동&lt;/li&gt;
      &lt;li&gt;0으로 설정된 페이지를 찾을 때까지 반복&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Corbato&lt;/strong&gt; 알고리즘
    &lt;ul&gt;
      &lt;li&gt;미사용 페이지를 찾기 위해 모든 메모리를 검사하지 않아도 되는 특성을 지님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변형된 시계 알고리즘
    &lt;ul&gt;
      &lt;li&gt;교체할 때 페이지들을 랜덤하게 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;탐색 내성(scan resistance)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;대개 LRU와 동작은 유사하지만 최악의 경우에 보이는 행동을 방지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;229-갱신된-페이지dirty-page의-고려&quot;&gt;22.9 갱신된 페이지(Dirty Page)의 고려&lt;/h3&gt;

&lt;p&gt;페이지가 &lt;strong&gt;변경(modified)&lt;/strong&gt; 되어 &lt;strong&gt;더티(dirty)&lt;/strong&gt; 상태가 되었다면,&lt;br /&gt;
디스크에 기록해야하기 때문에 비용이 많이 든다.&lt;br /&gt;
이러한 이유로 페이지를 내보낼 때 더티 페이지보다 &lt;strong&gt;깨끗한 페이지&lt;/strong&gt; 를 교체하는 것을 선호한다.&lt;/p&gt;

&lt;p&gt;변경 여부를 판단하기 위해 하드웨어는 &lt;strong&gt;modified bit(더티 비트)&lt;/strong&gt; 를 포함한다.&lt;br /&gt;
페이지가 변경되면 이 비트가 1로 설정되는데 이를 고려하여 교체 대상이 선택된다.&lt;/p&gt;

&lt;h3 id=&quot;2210-다른-vm-정책들&quot;&gt;22.10 다른 VM 정책들&lt;/h3&gt;

&lt;p&gt;페이지 교체 정책만이 유일한 정책이 아니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;페이지 선택(page selection)&lt;/strong&gt; 정책
    &lt;ul&gt;
      &lt;li&gt;언제 페이지를 메모리로 불러들일지 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;요구 페이징(demand paging)&lt;/strong&gt; 정책
    &lt;ul&gt;
      &lt;li&gt;페이지가 실제 접근될 때 해당 페이지를 메모리로 읽어 들임&lt;/li&gt;
      &lt;li&gt;어떤 페이지가 사용될지 예상하여 미리 읽어 들일 수도 있음 (&lt;strong&gt;선반입(prefetching)&lt;/strong&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;클러스터링(clustering)&lt;/strong&gt; 또는 &lt;strong&gt;쓰기 모으기(grouping or write)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기록해야 할 페이지들을 메모리에 모은 후 한번에 기록하는 방식&lt;/li&gt;
      &lt;li&gt;디스크 드라이브는 여러 개 작은 크기보다 하나의 큰 쓰기 요청이 더 효율적임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2211-쓰레싱thrashing&quot;&gt;22.11 쓰레싱(Thrashing)&lt;/h3&gt;

&lt;p&gt;실행 중인 프로세스가 가용 물리 메모리 크기를 초과하면 시스템은 끊임없이 페이징을 한다.&lt;br /&gt;
이러한 상황을 &lt;strong&gt;쓰래싱(thrashing)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;p&gt;운영체제들에는 쓰래싱이 발생했을 때 발견과 해결을 위한 기법들이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일부 프로세스를 중지하여 나머지 프로세스를 탑재
    &lt;ul&gt;
      &lt;li&gt;프로세스가 일정 시간동안 사용하는 페이지들의 집합을 &lt;strong&gt;워킹 셋(working set)&lt;/strong&gt; 이라고 하며, &lt;strong&gt;진입 제어(admission control)&lt;/strong&gt; 방법을 활용&lt;/li&gt;
      &lt;li&gt;많은 일을 엉성하게 하는 것보다 적은 일을 제대로 하는 것이 나음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 부족 킬러(out-of-memory killer)&lt;/strong&gt; 실행
    &lt;ul&gt;
      &lt;li&gt;많은 메모리를 요구하는 프로세스를 골라 죽임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;23장-완전한-가상-메모리-시스템&quot;&gt;23장. 완전한 가상 메모리 시스템&lt;/h2&gt;

&lt;p&gt;완전한 가상 메모리 시스템을 구현하기 위해서는 성능, 기능성, 및 보안을 위한 다양한 특징들이 필요하다.&lt;br /&gt;
다음 두 개의 시스템을 살펴보면서 구현 방법에 대해 알아본다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;VAX/VMS&lt;/li&gt;
  &lt;li&gt;Linux 의 가상 메모리 시스템&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;231-vaxvms-가상-메모리&quot;&gt;23.1 VAX/VMS 가상 메모리&lt;/h3&gt;

&lt;p&gt;VAX/VMS 운영체제는 다양한 종류의 시스템에서 동작하는 기법과 정책들이 필요했다.&lt;br /&gt;
VMS 는 컴퓨터의 구조적 결함을 소트르웨어로 보완한 훌륭한 사례다.&lt;/p&gt;

&lt;h4 id=&quot;메모리-관리-하드웨어&quot;&gt;메모리 관리 하드웨어&lt;/h4&gt;

&lt;p&gt;VAX-11 은 프로세스마다 512바이트 페이지 단위로 나누어진 32비트 가상 주소 공간(가상 주소 23비트, 9비트 오프셋)을 제공한다.&lt;br /&gt;
페이징과 세그멘테이션의 하이브리드 구조를 가지고 있다.&lt;/p&gt;

&lt;p&gt;프로세스 공간의 첫 번째 절반(P0)은 사용자 프로그램과 힙(heap)이 존재 (주소가 큰쪽으로 증가)&lt;br /&gt;
두 번째, 큰 쪽 절반은(P1) 주소가 스택(stack) 존재(주소가 작은 방향으로 증가)&lt;br /&gt;
주소 공간의 상위 절반은 반만 사용되며 시스템 공간 (보호된 코드와 데이터 존재)&lt;/p&gt;

&lt;p&gt;하지만 VMS 에는 페이지 테이블의 크기가 512바이트로 커진다는 문제가 있었다.&lt;br /&gt;
이 메모리 압박 정도를 경감시키기 위해 두 가지 방법을 사용했다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자 주소공간을 두 개의 세그멘트로 나누어 프로세스마다 (P0 과 P1) 각 영역을 위한 페이지 테이블 소유
    &lt;ul&gt;
      &lt;li&gt;스택과 힙 사이의 사용되지 않는 주소 영역을 위한 페이지 테이블 공간이 필요 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 페이지 테이블들을 커널의 가상 메모리에 배치
    &lt;ul&gt;
      &lt;li&gt;메모리 공간이 부족하면 페이지 테이블들을 디스크로 스왑하여 메모리 확보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;실제-주소-공간&quot;&gt;실제 주소 공간&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/vax-vms-address-space.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/vax-vms-address-space.png&quot; data-rjs=&quot;/images/study/operating-system/vax-vms-address-space.png&quot; class=&quot;zooming&quot; alt=&quot;VAX/VMS 주소 공간&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        VAX/VMS 주소 공간
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;코드 세그먼트는 절대 페이지 0에서 시작하지 않음 (접근 불가능한 페이지로 마킹)&lt;/li&gt;
  &lt;li&gt;커널의 가상 주소 공간은 사용자 주소 공간의 일부
    &lt;ul&gt;
      &lt;li&gt;문맥 교환이 발생되면 P0과 P1 레지스터를 다음 실행될 프로세스의 페이지 테이블을 가리킴&lt;/li&gt;
      &lt;li&gt;s 베이스와 바운드 레지스터는 변경되지 않기 때문에 동일한 커널 구조들이 사용자 주소 공간에 매핑&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;운영체제는 응용 프로그램이 운용체제의 데이터나 코드를 읽거나 쓰는 것을 보호&lt;/li&gt;
  &lt;li&gt;커널은 사용자 프로세스가 커널의 데이터를 읽거나 쓰는 것을 보호
    &lt;ul&gt;
      &lt;li&gt;protection bit 에 보호 수준을 지정하여 권한 수준을 기록&lt;/li&gt;
      &lt;li&gt;보호 수준의 자료를 접근하면 트랩이 걸리고 프로세스는 종료됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;페이지-교체&quot;&gt;페이지 교체&lt;/h4&gt;

&lt;p&gt;VAX 페이지 테이블 항목(PTE) 는 다음과 같은 비트들을 가지고 있음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;유효 (valid) 비트&lt;/li&gt;
  &lt;li&gt;보호 필드(protection field, 4비트)&lt;/li&gt;
  &lt;li&gt;변경(modify) 또는 더티(dirty) 비트&lt;/li&gt;
  &lt;li&gt;운영체제가 예약해 놓은 필드(5비트)&lt;/li&gt;
  &lt;li&gt;물리 프레임 번호(PFN)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;참조 비트(reference bit)&lt;/strong&gt; 는 포함되지 않은 문제와 
&lt;strong&gt;메모리 호그(memory hog)&lt;/strong&gt; 에 대한 문제를 해결하기 위해 &lt;strong&gt;세그멘트된 FIFO&lt;/strong&gt; 교체 정책을 제안했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;메모리 호그(memory hog): 메모리를 너무 많이 사용하는 프로그램&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;세그멘트된 FIFO&lt;/strong&gt; 교체 정책은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 프로세스는 &lt;strong&gt;상주 집합 크기 (resident set size, RSS)&lt;/strong&gt; 라는 메모리에 유지할 수 있는 최대 페이지 개수를 지정&lt;/li&gt;
  &lt;li&gt;페이지들은 FIFO 리스트에 보관&lt;/li&gt;
  &lt;li&gt;페이지 개수가 RSS 보다 커지면 먼저 들어온 페이지가 아웃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FIFO의 성능을 개선하기 위한 방법으로는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클린-페이지 프리 리스트와 더티 페이지 리스트라는 &lt;strong&gt;second-chance list&lt;/strong&gt; 도입
    &lt;ul&gt;
      &lt;li&gt;second-chance list 는 메모리에서 제거되기 전에 페이지가 보관되는 리스트&lt;/li&gt;
      &lt;li&gt;제거된 페이지가 수정 안된 상태라면 클린-페이지 프리 리스트, 변경된 상태라면 더티 페이지 리스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VMS의 작은 페이지 크기 극복
    &lt;ul&gt;
      &lt;li&gt;페이지 크기가 작을 수록 스왑할 때 디스크 I/O가 비효율&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;클러스터링(clustering)&lt;/strong&gt; 기법으로 작업 묶음을 만들어 한번에 디스크로 보냄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그외-기법들&quot;&gt;그외 기법들&lt;/h4&gt;

&lt;p&gt;VMS 는 표준화된 게르은(lazy) 최적화 기법 두 가지가 더 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;요청 시 0으로 채우기(demand zeroing)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;페이지 추가 요청이 오면 페이지를 찾아 0으로 채움(이전에 사용했던 페이지의 내용을 볼 수 없도록 보안을 위함)&lt;/li&gt;
      &lt;li&gt;해당 페이지를 사용하지 않는다면 많은 비용을 지불하게 됨&lt;/li&gt;
      &lt;li&gt;물리 페이지를 0으로 채우고 프로세스 주소 공간으로 매핑하는 작업이 필요 없어짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쓰기-시-복사(copy-on-write, COW)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한 주소 공간에서 다른 공간으로 페이지 복사가 필요하다면, 복사하지 않고 해당 페이지를 대상 주소 공간으로 매핑&lt;/li&gt;
      &lt;li&gt;페이지 테이블 엔트리를 양쪽 주소 공간에서 읽기 전용으로 표시&lt;/li&gt;
      &lt;li&gt;데이터 이동없이 빠른 복사 가능&lt;/li&gt;
      &lt;li&gt;쓰기를 시도하면 트랩이 발생되면서 페이지 할당 및 데이터로 채우고 주소 공간에 매핑&lt;/li&gt;
      &lt;li&gt;메모리 공간 절약 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;232-linux-가상-메모리-시스템&quot;&gt;23.2 Linux 가상 메모리 시스템&lt;/h3&gt;

&lt;p&gt;가장 많은 수를 차지하고 있는 Intel x86 용 Linux 를 대상으로 살펴본다.&lt;/p&gt;

&lt;h4 id=&quot;linux-주소-공간&quot;&gt;Linux 주소 공간&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/linux-address-space.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/linux-address-space.png&quot; data-rjs=&quot;/images/study/operating-system/linux-address-space.png&quot; class=&quot;zooming&quot; alt=&quot;Linux 주소 공간&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        Linux 주소 공간
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Linux 가상 주소는 다음과 같이 구성된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 영역: 사용자 프로그램 코드, 스택, 힙 및 기타 부분이 탑재되는 부분&lt;/li&gt;
  &lt;li&gt;커널 영역: 커널 코드, 스택, 힙 및 기타 부분이 탑재되는 부분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문맥 교시 현재 실행중인 주소 공간의 사용자 영역이 변경된다.&lt;br /&gt;
사용자 모드에서 실행되는 프로그램은 커널로 트랩이 발생하고 특권 모드로 전환되어야 커널 메모리에 접근 가능하다.&lt;/p&gt;

&lt;p&gt;Linux 는 커널 가상 주소의 유형이 두 개다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;커널 논리 주소(kernel logical address)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;커널의 가상 주소 공간 (페이지 테이블, 프로스세스 별 커널 스택 등)&lt;/li&gt;
      &lt;li&gt;이 유형의 메모리가 더 필요하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmalloc&lt;/code&gt; 호출&lt;/li&gt;
      &lt;li&gt;디스크로 스왑 불가능&lt;/li&gt;
      &lt;li&gt;커널 논리 주소는 물리 메모리의 첫 부분에 직접 매핑
        &lt;ul&gt;
          &lt;li&gt;커널 논리 주소와 물리 주소 사이의 변환이 간단&lt;/li&gt;
          &lt;li&gt;메모리 청크가 논리 주소 공간에서 연속적이면 물리 메모리에서도 연속적이므로 DMA 에 적합&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;커널 가상 주소(kernel virtual address)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이 유형의 메모리가 필요하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vmalloc&lt;/code&gt; 호출&lt;/li&gt;
      &lt;li&gt;연속적이지 않게 물리 페이지에 매핑 될 수 있으므로 DMA 적합하지 않음&lt;/li&gt;
      &lt;li&gt;더 쉽게 할당할 수 있어서 연속된 물리 메모리 청크는 찾는 것이 어려운 대용량 버퍼 할당에 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;DMA: 직접 메모리 접근 방식 (direct memory access)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;페이지-테이블-구조&quot;&gt;페이지 테이블 구조&lt;/h4&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/linux-page-table-structure.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/linux-page-table-structure.png&quot; data-rjs=&quot;/images/study/operating-system/linux-page-table-structure.png&quot; class=&quot;zooming&quot; alt=&quot;linux 페이지 테이블 구조&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        linux 페이지 테이블 구조
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;x86은 다중 레벨 페이지 테이블을 사용&lt;/li&gt;
  &lt;li&gt;전체 64비트 시스템은 4레벨 테이블 사용&lt;/li&gt;
  &lt;li&gt;가상 주소 상위 16 비트는 사용되지 않음 (역할이 없음)&lt;/li&gt;
  &lt;li&gt;하위 12비트가 오프셋으로 사용&lt;/li&gt;
  &lt;li&gt;변환에는 중간의 36비트가 관여&lt;/li&gt;
  &lt;li&gt;시스템 메모리가 커지면 페이지 테이블 트리 구조의 레벨이 증가&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;크기가-큰-페이지-지원&quot;&gt;크기가 큰 페이지 지원&lt;/h4&gt;

&lt;p&gt;Intel x86은 여러 페이지 크기를 사용할 수 있다.&lt;br /&gt;
거대한 페이지를 사용하면 다음과 같은 장점이 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 테이블에 필요한 매핑 개수 감소
    &lt;ul&gt;
      &lt;li&gt;TLB가 더 효과적으로 작동하고 성능 향상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TLB가 변환 결과로 빨리 채워지게 됨&lt;/li&gt;
  &lt;li&gt;거대한 페이지는 TLB의 적은 슬롯을 사용해도 TLB 미스 없이 큰 메모리 공간에 접근 가능&lt;/li&gt;
  &lt;li&gt;TLB 미스가 발생 했을 때 할당이 빠르게 처리됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TBL 를 더 효과적으로 사용하기 위해 투명한(transparent) 거대한 페이지 지원 추가했다.&lt;br /&gt;
이 기능은 응용프로그램을 수정하지 않아도 거대한 페이지를 할당할 수 있는 기회를 자동으로 찾는다.&lt;/p&gt;

&lt;p&gt;하지만 거대한 페이지를 사용하는 것에는 단점도 존재한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;내부 단편화(internal fragmentation)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용되지 않는 페이지들로 메모리를 채울 수 ㅣㅇㅆ음&lt;/li&gt;
      &lt;li&gt;거대한 페이지를 사용하면 스와핑도 작동하지 않으며 시스템의 I/O 양을 증가 시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;페이지-캐시&quot;&gt;페이지 캐시&lt;/h4&gt;

&lt;p&gt;대부분의 시스템은 영구 저장장치 접근 비용을 줄이기 위해 &lt;strong&gt;캐싱&lt;/strong&gt; 서브시스템을 사용한다.&lt;/p&gt;

&lt;p&gt;Linux 페이지 &lt;strong&gt;캐시(page cache)&lt;/strong&gt; 는 세 가지 주요 소스로부터 온 페이지를 메모리에 유지할 수 있도록 통합한다.&lt;br /&gt;
이러한 요소들은 페이지 캐시 해시 테이블(page cache hash table)에 저장되어 빠른 검색이 가능하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;메모리 맵 파일(memory-mapped file)&lt;/li&gt;
  &lt;li&gt;파일 데이터와 장치의 메타 데이터 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출되어 액세스)&lt;/li&gt;
  &lt;li&gt;힙과 각 프로세스를 구성하는 스택 페이지 (공급 파일은 없고 스왑 공간이 데이터를 공급하기때문에 &lt;strong&gt;anonymous memory&lt;/strong&gt; 라고도 함)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;페이지 캐시는 항목이 클린 또는 더티인지 추적하고, &lt;br /&gt;
더티 데이터라면 백그라운드 쓰레드에 의해 주기적으로 영구 저장 장치에 다시 기록된다.&lt;/p&gt;

&lt;p&gt;리눅스에서는 메모리 확보를 위해 &lt;strong&gt;2Q&lt;/strong&gt; 교체 알고리즘을 사용하여 축출할 페이지를 결정한다.&lt;br /&gt;
두 개의 리스트를 유지하여 메모리를 두 부분으로 나누어 관리한다.&lt;br /&gt;
처음 액세스 되면 &lt;strong&gt;비활동 리스트(inactive list)&lt;/strong&gt; 에 저장되고, 다시 참조되면 &lt;strong&gt;활동 리스트(active list)&lt;/strong&gt; 로 이동한다.
교체 후보는 inactive list 에서 선택되며, 주기적으로 active list 의 맨 아래 페이지를 inactive list 이동시킨다.&lt;/p&gt;

&lt;p&gt;Linux 는 LRU 순서가 되도록 이 리스트를 관리하려고 했지만 비용이 많이 을어 LRU 근사 알고리즘(클록 교체 알고리즘과 유사)을 사용&lt;/p&gt;

&lt;h4 id=&quot;보안과-버퍼-오버플로-공격&quot;&gt;보안과 버퍼 오버플로 공격&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;버퍼 오버 플로(buffer overflow)&lt;/strong&gt; 공격은 공격자가 버퍼의 경계를 넘도록 데이터를 길게 입력하여 목표 메모리를 덮어쓰며 발생되는 버그를 찾는 것이다.  &lt;br /&gt;
이 공격 으로 프로그램이나 커널 자체를 대상으로 사용될 수 있다.&lt;br /&gt;
공격이 성공하면 &lt;strong&gt;권한 상승(privilege escalation)&lt;/strong&gt; 되어 많은 자원에 접근이 가능하다. &lt;br /&gt;
방어 방법으로는 특정 영역에 탑재된 코드를 실행할 수 없게 만드는 것이다. (&lt;strong&gt;NX 비트(No-eXecute)&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;하지만 공격자는 코드를 주입할 수 없을 때에도 &lt;strong&gt;ROP(return-oriented programming)&lt;/strong&gt; 형태로 임의의 명령 시퀀스를 실행할 수 있다.&lt;br /&gt;
공격자는 실행 중인 함수의 복귀 주소가 악성 명령어를 가리키게끔 스택을 덮어써서 &lt;strong&gt;가젯(gadgets)&lt;/strong&gt; 으로 원하는 코드를 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;ROP를 방어하기 위해 &lt;strong&gt;ASLR(address space layout randomization)&lt;/strong&gt; 를 추가한다.&lt;br /&gt;
가상 주소 공간내에 코드, 스택 및 힙을 무작위로 배치하는 것이다.&lt;/p&gt;

&lt;h4 id=&quot;다른-보안-관련-문제들-meltdown-and-spectre&quot;&gt;다른 보안 관련 문제들: Meltdown And Spectre&lt;/h4&gt;

&lt;p&gt;CPU 가 성능을 향상 시키기위해 speculative execution 이라는 기법을 사용하면서 이 문제의 핵심이 된다.&lt;br /&gt;
이 기법은 향후 실행될 명령을 추측하고 미리 실행하는 기법이다.&lt;br /&gt;
예측하기 위해 실행 흔적을 남기기 때문에 취약하게 될 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;커널 보호를 강화하기 위해서 커널 주소 공간을 많이 제거하고 커널 데이터에 대해 커널 페이지 테이블을 사용하는 것이다.&lt;br /&gt;
이러한 방법을 &lt;strong&gt;커널 페이지 테이블 격리(kernel page table isolation, KPTI)&lt;/strong&gt; 라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;24장-메모리-가상화를-정리하는-대화&quot;&gt;24장. 메모리 가상화를 정리하는 대화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스의 명령어 반입, 명시적인 로드와 스토어 동작 방식 이해&lt;/li&gt;
  &lt;li&gt;프로그램 내에서 볼 수 있는 주소는 가상 주소&lt;/li&gt;
  &lt;li&gt;데이터와 코드가 메모리에 있는 것 같은 환상을 만들어 냄&lt;/li&gt;
  &lt;li&gt;주소 변환을 위해 적은 하드웨어 캐시를 갖는 시스템을 지원하는 TLB&lt;/li&gt;
  &lt;li&gt;TLB 로 인해 가상 주소를 물리 주소로 변환하는 과정을 빠르게 할 수 있음&lt;/li&gt;
  &lt;li&gt;페이지 테이블은 크기 때문에 크고 느린 메모리에 존재&lt;/li&gt;
  &lt;li&gt;페이지 테이블은 배열과 같은 자료구조 부터 멀티 레벨 테이블로 발전&lt;/li&gt;
  &lt;li&gt;주소 변환 구조는 필요할 때만 공간을 생성할 수 있도록 유연해야 함 (ex. 멀티레벨 테이블)&lt;/li&gt;
  &lt;li&gt;페이지 교체 정책&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="study" /><category term="study" /><category term="book" /><category term="operation-system" /><summary type="html">운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다. 이 글에서는 20장부터 24장까지의 내용을 정리한다.</summary></entry><entry><title type="html">[Study] 운영체제 아주 쉬운 세가지 이야기 17장~19장</title><link href="https://devyonghee.github.io/study/2022/11/21/operation-system-three-easy-pieces-17-20/" rel="alternate" type="text/html" title="[Study] 운영체제 아주 쉬운 세가지 이야기 17장~19장" /><published>2022-11-21T00:00:00+00:00</published><updated>2022-11-21T00:00:00+00:00</updated><id>https://devyonghee.github.io/study/2022/11/21/operation-system-three-easy-pieces-17-20</id><content type="html" xml:base="https://devyonghee.github.io/study/2022/11/21/operation-system-three-easy-pieces-17-20/">&lt;p&gt;운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.&lt;br /&gt;
이 글에서는 가상화에 대해 다룬 17장부터 19장까지의 내용을 정리한다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;17장-빈-공간-관리&quot;&gt;17장. 빈 공간 관리&lt;/h2&gt;

&lt;p&gt;빈 공간 관리가 어려운 경우는 관리하는 공간이 가변-크기 빈 공간들의 집합으로 구성되어 있는 경우다. (세그멘테이션)&lt;br /&gt;
이러한 경우에는 외부 단편화가 존재한다.&lt;br /&gt;
이번장에서 이 문제를 해결하고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;171-가정&quot;&gt;17.1 가정&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;외부 단편화&lt;/strong&gt; 방지에 중점을 둔다.&lt;br /&gt;
하지만 반대로 &lt;strong&gt;내부 단편화&lt;/strong&gt; 문제가 있을 수 있다.&lt;br /&gt;
할당기가 요청한 크기보다 더 큰 메모리 청크를 할당할 경우, 
요청되지 않은 공간에 대해 할당 청크의 내부에서 낭비가 발생하기 때문에 내부 단편화라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;172-저수준-기법들&quot;&gt;17.2 저수준 기법들&lt;/h3&gt;

&lt;p&gt;할당기에서 사용되는 기법에 대해 논의한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;분할(splitting)&lt;/strong&gt; 과 &lt;strong&gt;병합(coalescing)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;할당된 영역의 크기를 빠르고 상대적으로 쉽게 파악할 수 있는 방법&lt;/li&gt;
  &lt;li&gt;빈 공간과 사용 중인 공간을 추적하기 위해 빈 공간 내에 간단한 리스트 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;분할과-병합&quot;&gt;분할과 병합&lt;/h4&gt;

&lt;p&gt;힙의 빈 공간 리스트에 2개의 원소가 있다고 가정한다.&lt;br /&gt;
하나는 10 바이트의 빈 세그멘트(바이트 0-9) 이고 나머지는 빈 세그멘트(바이트 20-29) 를 표현한다.
10 바이트를 초과하는 모든 요청은 실패할 것이고 작은 요청은 쉽게 충족할 것이다.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/space-splitting.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/space-splitting.png&quot; data-rjs=&quot;/images/study/operating-system/space-splitting.png&quot; class=&quot;zooming&quot; alt=&quot;분할&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        분할
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;1바이트만 요청하게 된다면 할당기는 &lt;strong&gt;분할(splitting)&lt;/strong&gt; 작업을 수행한다.&lt;br /&gt;
두 번째 원소를 사용해서 충족했다고 가정하면 두 번째 빈 공간은 20이 아닌 21에서 시작하고 길이는 9가 된다.&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/space-coalescing.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/space-coalescing.png&quot; data-rjs=&quot;/images/study/operating-system/space-coalescing.png&quot; class=&quot;zooming&quot; alt=&quot;병합&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        병합
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;분할데 동방되는 기법은 &lt;strong&gt;병합(coalescing)&lt;/strong&gt; 이다.&lt;br /&gt;
힙의 중간에 존재하는 공간을 반환하면 빈 공간들을 병합함으로써 하나의 큰 빈 공간으로 만든다.&lt;/p&gt;

&lt;h4 id=&quot;할당된-공간의-크기-파악&quot;&gt;할당된 공간의 크기 파악&lt;/h4&gt;

&lt;p&gt;메모리 영역의 크기를 파악하여 공간을 빈 공간 리스트에 추가하기 위해 할당기는 &lt;strong&gt;헤더(header)&lt;/strong&gt; 블럭에 추가 정보를 저장한다.&lt;br /&gt;
여기서 주의할 점으로 빈 영역의 크기는 헤더 크기 + 사용자에게 할당된 영역의 크기로 된다. (n 바이트 + 헤더 크기의 청크를 찾음)&lt;br /&gt;
헤더는 다음과 같은 정보들을 저장할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;할당된 공간의 크기&lt;/li&gt;
  &lt;li&gt;추가의 포인터
    &lt;ul&gt;
      &lt;li&gt;해제 속도 향상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매직넘버
    &lt;ul&gt;
      &lt;li&gt;부가적인 무결성 검사 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;빈-공간-리스트-내장&quot;&gt;빈 공간 리스트 내장&lt;/h4&gt;

&lt;p&gt;새로운 노드를 위한 공간을 할당하기 위해 빈 공간 내에 리스트를 구축해야 한다.&lt;br /&gt;
요청하기에 충분한 크기가 있다면 요청 크기 + 헤더 크기를 충족하는 청크와 빈 청크 두 개로 &lt;strong&gt;분할&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;메모리 반환이 일어나면 라이브러리는 빈 공간의 크기를 파악하고 빈 청크를 빈 공간 리스트에 삽입한다.&lt;br /&gt;
그리고 단편화가 발생되지 않도록 리스트를 순회하면서 인접한 청크를 병합한다.&lt;/p&gt;

&lt;h4 id=&quot;힙의-확장&quot;&gt;힙의 확장&lt;/h4&gt;

&lt;p&gt;대부분의 전통적인 할당기는 적은 크기의 힙으로 시작하여 부족하면 운영체제에게 메모리를 요청한다.&lt;br /&gt;
할당기는 힙을 확장하기 위해 특정 시스템 콜(sbrk)을 호출한다.&lt;/p&gt;

&lt;h3 id=&quot;173-기본적략&quot;&gt;17.3 기본적략&lt;/h3&gt;

&lt;p&gt;할당기는 속도가 빠르고 단편화를 최소로 해야 한다.&lt;br /&gt;
빈 공간 할당을 위한 몇 가지 기본 정책에 대해 알아본다.&lt;/p&gt;

&lt;h4 id=&quot;최적-적합best-fit&quot;&gt;최적 적합(Best Fit)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;빈 공간 리스트를 검색하여 요청한 크기와 같거나 더 큰 메모리 청크를 찾음&lt;/li&gt;
  &lt;li&gt;후보자 그룹중 가장 작은 크기의 청크 반환 (최적 청크, 최소 적합)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;장점&quot;&gt;장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;공간 낭비 최소화&lt;/li&gt;
  &lt;li&gt;빈 공간 리스트를 한번만 순회하면 정확한 블럭을 찾음&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점&quot;&gt;단점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;정교하지 않은 구현은 항상 전체 검색하기 때문에 성능 저하&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;최악-적합worst-fit&quot;&gt;최악 적합(Worst Fit)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;최적 적합의 반대&lt;/li&gt;
  &lt;li&gt;가장 큰 빈 청크를 찾아 요청된 크기 만큼만 반환하고 남은 부분은 빈 공간 리스트에 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;장점-1&quot;&gt;장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;최적 적합 방식에서 발생되는 작은 청크 방지&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점-1&quot;&gt;단점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;항상 빈 공간 리스트 전체를 탐색하는 오버헤드 존재&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;최초-적합first-fit&quot;&gt;최초 적합(First Fit)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;요청보다 큰 첫 번째 블럭을 찾아 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;장점-2&quot;&gt;장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;전체 탐색할 필요가 없어서 속도가 빠름&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점-2&quot;&gt;단점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;리스트 시작에 작은 객체가 많이 생길 수 있음
    &lt;ul&gt;
      &lt;li&gt;빈 공간 리스트 순서 관리 필요 (ex. 주소-기반 정렬, address-based ordering)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다음-적합next-fit&quot;&gt;다음 적합(Next Fit)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;리스트 처음부터 탐색이 아닌 마지막으로 찾았던 원소를 가리키는 추가의 포인터 유지&lt;/li&gt;
  &lt;li&gt;전체 탐색을 하지 않기 때문에 최초 적합의 성능과 비슷&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;장점-3&quot;&gt;장점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;빈 공간 탐색을 리스트 전체에 균등하게 분산&lt;/li&gt;
  &lt;li&gt;첫 부분에만 단편이 발생하는 것을 방지&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;174-다른-접근법&quot;&gt;17.4 다른 접근법&lt;/h3&gt;

&lt;p&gt;기본적인 접근 방식외에도 메모리 할당을 향상시키 위한 방법에 대해 알아본다.&lt;/p&gt;

&lt;h4 id=&quot;개별-리스트&quot;&gt;개별 리스트&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;별도의 개별리스트(segregated list)&lt;/li&gt;
  &lt;li&gt;자주 요청하는 크기가 있다면 그 크기의 객체를 관리하기 위한 별도의 리스트 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;장점-4&quot;&gt;장점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;단편화 가능성 감소
    &lt;ul&gt;
      &lt;li&gt;특정 크기의 요청을 위한 메모리 청크를 유지하기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요청된 크기의 청크만 존재하여 할당과 해제 요청을 신속히 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점-3&quot;&gt;단점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;지정된 크기의 메모리 풀과 일반적인 풀에 얼만큼 메모리 할당을 해야할지 결정하는 추가적인 오버헤드 존재
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;슬랩 할당기(slab allocator)&lt;/strong&gt; 는 이문제를 해결 (할당된 캐시공간이 부족하면 추가 슬랩 요청)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;버디-할당&quot;&gt;버디 할당&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;이진 버디 할당기(binary buddy allocator)&lt;/strong&gt; 합병을 간단히 하는 방법 중 하나임&lt;/li&gt;
  &lt;li&gt;빈 메모리는 2의 거듭제곱 크기로 생각하고 메모리 요청이 발생하면 충분한 공간이 발견될 때까지 빈 공간을 2개로 분할&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;장점-5&quot;&gt;장점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;블럭이 해제될 때는 다음 블럭이 비어있는지 확인하고 합병하는 식으로 재귀 합병이 발생됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점-4&quot;&gt;단점&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;2의 거듭제곱 크기만큼의 블럭만 할당되어 &lt;strong&gt;내부 단편화&lt;/strong&gt; 발생될 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기타-아이디어&quot;&gt;기타 아이디어&lt;/h4&gt;

&lt;p&gt;위의 방식들은 확장성에 문제가 있음&lt;br /&gt;
빈 공간들의 개수가 늘어갈수록 리스트 검색이 느려질 수 있음
정교한 할당기는 복잡한 자료구조를 사용하여 이 비용을 줄임&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;균형 이진트리(balanced binary tree)&lt;/li&gt;
  &lt;li&gt;스플레이 트리(splay tree)&lt;/li&gt;
  &lt;li&gt;부분 정렬 트리(partially ordered tree)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;18장-페이징-개요&quot;&gt;18장. 페이징: 개요&lt;/h2&gt;

&lt;p&gt;공간 관리 문제를 해결하기 위한 방법에는 두 가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;세그멘테이션&lt;/strong&gt; 기법
    &lt;ul&gt;
      &lt;li&gt;가변 크기의 조각들로 분해하는 것&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단편화(fragmented)&lt;/strong&gt; 가 발생될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;페이징&lt;/strong&gt; 기법
    &lt;ul&gt;
      &lt;li&gt;프로세스 주소 공간을 고정 크기의 조각(페이지, page)으로 분할&lt;/li&gt;
      &lt;li&gt;상응하는 물리메모리는 &lt;strong&gt;페이지 프레임(page frame)&lt;/strong&gt; 이라는 고정 크기의 슬롯 배열으로 생각&lt;/li&gt;
      &lt;li&gt;프레임에는 하나의 가상 메모리 페이지 저장 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;181-간단한-예제-및-개요&quot;&gt;18.1 간단한 예제 및 개요&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/paging-address-space-example.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/paging-address-space-example.png&quot; data-rjs=&quot;/images/study/operating-system/paging-address-space-example.png&quot; class=&quot;zooming&quot; alt=&quot;64바이트 주소 공간&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        64바이트 주소 공간
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;주소 공간의 총 크기는 64바이트이면서 4개의 16바이트 페이지로 구성된 작은 주소 공간을 가정한다.&lt;br /&gt;
물리 메모리는 고정 크기의 슬롯들로 구성된다.&lt;br /&gt;
가상 주소 공간의 페이지들은 위 그림과 같이 물리 메모리 전체에 분산 배치되어 있다.&lt;/p&gt;

&lt;p&gt;운영체제는 주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위해 프로세스마다 &lt;strong&gt;페이지 테이블(page table)&lt;/strong&gt; 자료 구조 유지&lt;br /&gt;
&lt;strong&gt;페이지 테이블&lt;/strong&gt;은 주소 공간의 가상 페이지 &lt;strong&gt;주소 변환(address translation)&lt;/strong&gt; 정보 저장 (&lt;strong&gt;역 페이지 테이블(inverted page table)&lt;/strong&gt; 라는 예외 기법도 존재)&lt;/p&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/virtual-page-number.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/virtual-page-number.png&quot; data-rjs=&quot;/images/study/operating-system/virtual-page-number.png&quot; class=&quot;zooming&quot; alt=&quot;가상 페이지 번호와 오프셋&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        가상 페이지 번호와 오프셋
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;프로세스가 생성한 가상 주소 변환을 위해 가상 주소를 &lt;strong&gt;가상 페이지 번호(virtual page number, VPN)&lt;/strong&gt; 와 페이지 내의 &lt;strong&gt;오프셋&lt;/strong&gt; 2개의 구성요소로 분할한다.&lt;br /&gt;
위 예에서 가장 주소 공간의 크기가 64바이트 이므로 가상주소는 6비트가 필요하다.&lt;br /&gt;
주소 공간은 16바이트 이기 때문에 페이지는 4개를 선택해야 하므로 최상위 2비트가 VPN 을 가지게 된다.  &lt;br /&gt;
나저미 비트는 &lt;strong&gt;오프셋&lt;/strong&gt; 으로 바이트의 위치를 나타낸다.&lt;/p&gt;

&lt;p&gt;가상 페이지 번호와 페이지 테이블의 인덱스를 이용하면 &lt;strong&gt;물리 프레임 번호(physical frame number, PFN)&lt;/strong&gt; 혹은 &lt;strong&gt;물리 페이지 번호(phsyical page number, PPN)&lt;/strong&gt; 를 알 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;페이징-장점&quot;&gt;페이징 장점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;유연성
    &lt;ul&gt;
      &lt;li&gt;프로세스의 주소 공간 사용방식과 상관 없이 효율적으로 주소 공간 개념 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빈 공간 관리의 단순함
    &lt;ul&gt;
      &lt;li&gt;주소 공간을 물리 메모리에 배치를 원한다면 비어있는 페이지만 찾으면 됨&lt;/li&gt;
      &lt;li&gt;운영체제는 페이지의 빈 공간 리스트를 유지하며 리스트의 첫 페이지 목록을 선택&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;182-페이지-테이블은-어디에-저장되는가&quot;&gt;18.2 페이지 테이블은 어디에 저장되는가&lt;/h3&gt;

&lt;p&gt;페이지 테이블은 세그멘트 테이블에 비해 매우 커질 수 있다.&lt;br /&gt;
물리 주소로의 변환 정보와 다른 필요한 정보를 저장하기 위한 &lt;strong&gt;페이지 테이블 항목(page table entry, PTE)&lt;/strong&gt; 이 메모리를 많이 차지할 수 있다.&lt;br /&gt;
그래서 각 프로세스의 페이지 테이블을 MMU 보다 메모리에 저장한다. (디스크에 스왑될 수 있음)&lt;/p&gt;

&lt;h3 id=&quot;183-페이지-테이블에는-실제-무엇이-있는가&quot;&gt;18.3 페이지 테이블에는 실제 무엇이 있는가&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/page-table-entry.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/page-table-entry.png&quot; data-rjs=&quot;/images/study/operating-system/page-table-entry.png&quot; class=&quot;zooming&quot; alt=&quot;페이지 테이블 항목(PTE)&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        페이지 테이블 항목(PTE)
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;페이지 테이블은 가상 주소 (또는 가상 페이지 번호)를 물리 주소(물리 프레임 번호)로 매핑하는데 사용되는 자료다.&lt;br /&gt;
간단한 형태로는 &lt;strong&gt;선형 페이지 테이블(linear page table)&lt;/strong&gt; 이다.
운영체제는 &lt;strong&gt;가상 페이지 번호(VPN)&lt;/strong&gt; 으로 배열 항목에 접근하고 &lt;strong&gt;페이지 테이블 항복(PTE)&lt;/strong&gt; 를 검색하여 &lt;strong&gt;물리 프레임 번호(PFN)&lt;/strong&gt; 를 찾는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Valid bit&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 변환의 유효 여부 표현 (ex. 스택과 힙 사이의 미사용된 공간은 &lt;strong&gt;무효(invalid)&lt;/strong&gt; 로 표시)&lt;/li&gt;
      &lt;li&gt;무효로 표시된 메모리에 접근하면 운영체제는 트랩 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;protection bit&lt;/strong&gt; (P)
    &lt;ul&gt;
      &lt;li&gt;페이지 읽기, 쓰기, 실행 가능 여부를 표시&lt;/li&gt;
      &lt;li&gt;허용되지 않은 방식이라면 트랩 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;present bit&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;물리 메모리에 있는지 디스크에 있는지 가리킴 (스왑 아웃 여부)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;dirty bit&lt;/strong&gt; (D)
    &lt;ul&gt;
      &lt;li&gt;메모리에 반입된 후 페이지 변경 여부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;reference bit&lt;/strong&gt; (또는 &lt;strong&gt;access bit&lt;/strong&gt;, A)
    &lt;ul&gt;
      &lt;li&gt;페이지가 접근되었는지 추적하기 위함&lt;/li&gt;
      &lt;li&gt;페이지 교체 알고리즘에 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;184-페이징-너무-느림&quot;&gt;18.4 페이징: 너무 느림&lt;/h3&gt;

&lt;p&gt;페이지 테이블의 크기가 메모리 상에 크게 증가할 수 있어서 처리 속도가 저하될 수 있다.&lt;br /&gt;
시스템은 프로세스의 페이지 테이블에서 적절한 페이지 항목을 가져오고, 변환 수행 후, 물리 메모리에서 데이터를 탑재한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;페이지 테이블 베이스 레지스터(page table base register)&lt;/strong&gt; 가 페이지 테이블의 시작 주소를 저장한다고 가정한다.&lt;br /&gt;
모든 메모리 참조에 대해 페이지 테이블에서 변환 정보를 반입해야 하기 때문에 메모리 참조가 많이 발생된다.&lt;br /&gt;
그래서 페이지 테이블로 인해 &lt;strong&gt;시스템이 느려질 수 있으며, 많은 메모리를 차지&lt;/strong&gt;하게 된다.&lt;/p&gt;

&lt;h4 id=&quot;185-메모리-트레이스&quot;&gt;18.5 메모리 트레이스&lt;/h4&gt;

&lt;p&gt;페이징을 사용했을 때 메모리 접근이 많이 발생된다. (ex. 페이지 테이블 접근, 데이터 및 명령어 접근)
간단한 코드에도 실제 응용 프로그램의 메모리 동작은 굉장히 복잡하게 발생된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;19장-페이징-더-빠른-변환-tlb&quot;&gt;19장. 페이징: 더 빠른 변환 (TLB)&lt;/h2&gt;

&lt;p&gt;페이징은 성능 저하를 유발할 수 있다.&lt;br /&gt;
주소를 빠르게 변환하여 실행 성능을 개선하기 위해
&lt;strong&gt;메모리 관리부(memory-management unit, MMU)&lt;/strong&gt; 의 일부인 &lt;strong&gt;변환-색인 버퍼(translation-lookside buffer, TLB)&lt;/strong&gt; 라는 하드웨어의 도움을 받는다. &lt;br /&gt;
TLB는 가상 주소-실주소 변환 정보를 저장하는 하드웨어 캐시다. (&lt;strong&gt;주소-변환 캐시(address-translation cache)&lt;/strong&gt; 라고도 함)&lt;/p&gt;

&lt;h3 id=&quot;191-tlb의-기본-알고리즘&quot;&gt;19.1 TLB의 기본 알고리즘&lt;/h3&gt;

&lt;h4 id=&quot;tlb-에-변환-정보가-있는-경우tlb-히트&quot;&gt;TLB 에 변환 정보가 있는 경우(TLB 히트)&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;가상 주소에서 가상 페이지 번호(virtual page number, VPN) 추출&lt;/li&gt;
  &lt;li&gt;VPN 의 TLB 존재 여부 검사 (존재하면 TLB 히트, 변환 값을 가지고 있음)&lt;/li&gt;
  &lt;li&gt;TLB 에서 페이지 프레임 번호(page frame number, PFN) 추출&lt;/li&gt;
  &lt;li&gt;페이지 접근 권한 검사&lt;/li&gt;
  &lt;li&gt;가상 주소의 오프셋과 합쳐 원하는 물리 주소(PA) 구성 후 메모리 접근&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;tlb-에-변환-정보가-없는-경우tlb-미스&quot;&gt;TLB 에 변환 정보가 없는 경우(TLB 미스)&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;가상 주소에서 가상 페이지 번호(virtual page number, VPN) 추출&lt;/li&gt;
  &lt;li&gt;VPN 의 TLB 존재 여부 검사 (존재하지 않으면 TLB 미스)&lt;/li&gt;
  &lt;li&gt;변환 정보를 찾기 위해 페이지 테이블 접근&lt;/li&gt;
  &lt;li&gt;가상 메모리 참조가 유효하고 접근가능 하면 변환 정보를 TLB로 읽어옴&lt;/li&gt;
  &lt;li&gt;TLB 가 갱신되면 명령어 재실행&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;192-예제-배열-접근&quot;&gt;19.2 예제: 배열 접근&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;공간 지역성(spatial locality)&lt;/strong&gt; 으로 성능 개선 가능
    &lt;ul&gt;
      &lt;li&gt;페이지에 한번 접근하면 인접한 항목도 같은 페이지에 존재하기 때문에 TLB 히트&lt;/li&gt;
      &lt;li&gt;페이지 크기가 두 배가 되면 미스 횟수 감소 (일반적으로 페이지 크기는 4KB)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시간 지역성(temporal locality)&lt;/strong&gt; 으로 성능 개선 가능
    &lt;ul&gt;
      &lt;li&gt;한번 참조된 메모리 영역이 짧은 시간 내에 재 참조될 가능성이 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;193-tlb-미스는-누가-처리할까&quot;&gt;19.3 TLB 미스는 누가 처리할까&lt;/h3&gt;

&lt;p&gt;미스 처리를 담당하는 방법은 두 가지가 있다.&lt;/p&gt;

&lt;h4 id=&quot;하드웨어-관리-tlb&quot;&gt;하드웨어 관리 TLB&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CISC(complex instruction set computers)&lt;/strong&gt; 기반 컴퓨터&lt;/li&gt;
  &lt;li&gt;인텔 x86 CPU 가 대표적인 예로 &lt;strong&gt;멀티 레벨 페이지 테이블(multi-level page table)&lt;/strong&gt; 을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;페이지 테이블에서 원하는 페이지 테이블 엔트리를 찾음&lt;/li&gt;
  &lt;li&gt;필요한 변환 정보 추출&lt;/li&gt;
  &lt;li&gt;TLB 갱신&lt;/li&gt;
  &lt;li&gt;TLB 미스가 발생한 명령어 재실행&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;소프트웨어-관리-tlb&quot;&gt;소프트웨어 관리 TLB&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;RISC(reduced instruction set computing)&lt;/strong&gt; 기반 컴퓨터&lt;/li&gt;
  &lt;li&gt;하드웨어 변경없이 페이지 테이블 구조를 자유롭게 변경할 수 있음&lt;/li&gt;
  &lt;li&gt;하드웨어는 할 일이 별로 없기 때문에 단순함&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;TLB 에서 주소 찾는 것을 실패하면, 하드웨어 예외(exception) 시그널 발생&lt;/li&gt;
  &lt;li&gt;예외를 받은 운영체제는 명령어 실행 중지&lt;/li&gt;
  &lt;li&gt;실행 모드를 커널모드로 변경하여 커널 코드 실행 준비&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트랩 핸들러(trap handler)&lt;/strong&gt; 실행
    &lt;ul&gt;
      &lt;li&gt;시스템 콜 호출 시 다음 라인부터 실행되는 것과 다르게 트랩을 발생시킨 명령을 다시 실행 (TLB 히트)&lt;/li&gt;
      &lt;li&gt;TLB 미스가 무한 발생되지 않도록 주의 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이지 테이블 검색하여 변환 정보 찾기&lt;/li&gt;
  &lt;li&gt;TLB 접근 가능한 특권 명령어(privileged instruction)를 사용하여 TLB 갱신 후 리턴&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;194-tlb의-구성-무엇이-있나&quot;&gt;19.4 TLB의 구성: 무엇이 있나?&lt;/h3&gt;

&lt;p&gt;일반적인 TLB 는 32, 64, 128 개의 엔트리를 가지며, &lt;strong&gt;완전 연관(fully associative)&lt;/strong&gt; 방식으로 설계된다.&lt;br /&gt;
변환 정보는 TLB 내 어디든 위치할 수 있으며, 변환 정보 검색은 병렬적으로 수행된다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VPN | PFN | 다른 비트들
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TLB 의 각 항목에는 가상 페이지 번호(VPN) 와 물리 페이지 번호(PFN) 가 존재한다.&lt;br /&gt;
비트들에는 다음과 같은 정보들이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;valid bit&lt;/strong&gt; : 유효한 변환 정보인지를 나타내는 비트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;보호(protection)&lt;/strong&gt; 비트: 페이지가 어떻게 접근될 수 있는지 나타내는 비트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주소 공간 식별자(address-space identifier)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;더티 비트(dirty bit)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;195-tlb의-문제-문맥-교환&quot;&gt;19.5 TLB의 문제: 문맥 교환&lt;/h3&gt;

&lt;p&gt;TLB 를 사용하면 변환 정보는 해당 프로세스에서만 유효하기 때문에 문제가 발생한다.&lt;br /&gt;
TLB 가 멀티 프로세스 간의 가상화를 지원하기 위해서는 추가 기능이 필요하다.&lt;/p&gt;

&lt;p&gt;다음 프로세스가 실행되기 전 TLB 내용 비우면 된다.&lt;br /&gt;
비우는 작엄은 모든 &lt;strong&gt;valid bit 를 0&lt;/strong&gt;으로 설정하는 것이다.  &lt;br /&gt;
하지만 문맥 교체가 빈번하다면 TLB 미스가 발생되어 &lt;strong&gt;성능이 저하&lt;/strong&gt;될 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 기반의 시스템
    &lt;ul&gt;
      &lt;li&gt;특별한 하드웨어 명령어로 TLB 를 비움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하드웨어 기반 시스템
    &lt;ul&gt;
      &lt;li&gt;페이지 테이블 베이스 레지스터가 변경될 때 비우기 시작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제를 해결하기 위해 문맥 교환이 발생해도 
TLB 를 유지할 수 있도록 &lt;strong&gt;주소 공간 식별자(address space identifier, ASID)&lt;/strong&gt; 필드를 추가했다.&lt;br /&gt;
&lt;strong&gt;프로세스 식별자(process identifier, PID)&lt;/strong&gt; 와 비슷한 개념이다.&lt;/p&gt;

&lt;p&gt;주소 공간 식별자를 통해 프로세스 별로 TLB 변환 정보를 구분할 수 있다.&lt;br /&gt;
운영체제는 문맥 교환이 발생하면 새로운 ASID 값을 정해진 레지스터에 저장한다.&lt;/p&gt;

&lt;h3 id=&quot;196-이슈-교체-정책&quot;&gt;19.6 이슈: 교체 정책&lt;/h3&gt;

&lt;p&gt;일반적인 TLB &lt;strong&gt;캐시 교체(cache replacement)&lt;/strong&gt; 정책들을 알아본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최저 사용 빈도(least-recently-used, LRU)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;가장 오랫동안 사용되지 않은 항목을 교체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;랜덤(random)
    &lt;ul&gt;
      &lt;li&gt;교체 대상을 무작위로 선택&lt;/li&gt;
      &lt;li&gt;잘못된 결정을 할 수 있음&lt;/li&gt;
      &lt;li&gt;구현이 간단하고 예외 상황의 발생을 피할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;197-실제-tlb&quot;&gt;19.7 실제 TLB&lt;/h3&gt;

&lt;figure&gt;
    &lt;a href=&quot;/images/study/operating-system/mips-tlb.png&quot;&gt;
        &lt;img src=&quot;/images/study/operating-system/mips-tlb.png&quot; data-rjs=&quot;/images/study/operating-system/mips-tlb.png&quot; class=&quot;zooming&quot; alt=&quot;MIPS 의 TLB 항목&quot; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        MIPS 의 TLB 항목
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;실제 TLB 인 MIPS R4000 구성에 대해 알아본다.&lt;br /&gt;
MIPS 는 소프트웨어로 관리되는 TLB 를 사용한다.
MIPS 는 32비트 주소 공간에 4KB 페이지를 지원한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VPN: 19비트 할당
    &lt;ul&gt;
      &lt;li&gt;전체 주소 공간의 절반만 사용자 주소 공간으로 할당되어 있기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PFN: 24비트 할당&lt;/li&gt;
  &lt;li&gt;ASID: 8비트 할당&lt;/li&gt;
  &lt;li&gt;G: 전역비트
    &lt;ul&gt;
      &lt;li&gt;프로세스들 간에 공유되는 페이지들을 위해 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C: 3비트 할당
    &lt;ul&gt;
      &lt;li&gt;일관성 비트(coherence)&lt;/li&gt;
      &lt;li&gt;페이지가 어떻게 캐시되어 있는지 판별&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;D: 1비트 할당
    &lt;ul&gt;
      &lt;li&gt;더티 비트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;V: 1비트 할당
    &lt;ul&gt;
      &lt;li&gt;유효 비트&lt;/li&gt;
      &lt;li&gt;유효한 변환 정보 존재 여부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;198-요약&quot;&gt;19.8 요약&lt;/h3&gt;

&lt;p&gt;TLB 형대 시스템에서 페이징을 사용하기 위한 필수요소다. 
하지만 짧은 시간 동안 접근하는 페이지들이 TLB 에 들어갈 수 있는 수보다 많아지면 TLB 미스가 발생되고 느리게 동작하게 될 것이다.&lt;br /&gt;
이러한 현상을 &lt;strong&gt;TLB 범위(TLB coverage)&lt;/strong&gt; 를 벗어난다고 한다.&lt;/p&gt;

&lt;p&gt;이 현상을 해결하기 위한 방법 중 하나로 더 큰 페이지 크기를 지원하는 것인데,&lt;br /&gt;
큰 페이지들을 지원하기 위해서는 &lt;strong&gt;데이터베이스 관리 시스템(database management system, DBMS)&lt;/strong&gt; 같은 프로그램이 주로 사용된다.&lt;/p&gt;

&lt;p&gt;또 다른 문제로 CPU 파이프라인에서 TLB 접근은 병목이 될 수 있다.&lt;br /&gt;
특히, &lt;strong&gt;물리적으로 인덱스된 캐시(physically-indexed cache)&lt;/strong&gt; 가 사용될 경우에는 주소 변환이 캐시 접근 전에 이루어져야 하는데 이런 경우 상당히 느려진다.&lt;br /&gt;
&lt;strong&gt;가상적으로 인덱스된 캐시(virtually indexed cache)&lt;/strong&gt; 로 일부 성능 문제를 해결하지만 새로운 하드웨어 설계 문제들이 생긴다.&lt;/p&gt;</content><author><name></name></author><category term="study" /><category term="study" /><category term="book" /><category term="operation-system" /><summary type="html">운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다. 이 글에서는 가상화에 대해 다룬 17장부터 19장까지의 내용을 정리한다.</summary></entry></feed>