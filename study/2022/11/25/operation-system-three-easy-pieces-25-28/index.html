<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>devyonghee blog | [Study] 운영체제 아주 쉬운 세가지 이야기 25장~28장</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="[Study] 운영체제 아주 쉬운 세가지 이야기 25장~28장">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://devyonghee.github.io/study/2022/11/25/operation-system-three-easy-pieces-25-28/">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="devyonghee blog">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://devyonghee.github.io/study/2022/11/25/operation-system-three-easy-pieces-25-28/">
  <meta name="twitter:title" content="[Study] 운영체제 아주 쉬운 세가지 이야기 25장~28장">
  <meta name="twitter:description" content="">

  
    <meta name="google-site-verification" content="1DbhSO778Ec8l_4qztuQgVDcPhc_ya64RGP-nwD_bj0" />
  

  
    <meta property="og:image" content="">
    <meta name="twitter:image" content="">
  

  <link href="https://devyonghee.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="devyonghee blog Last 10 blog posts" />
  <link rel="stylesheet" type="text/css" href="/css/fonts.css">


  <link rel="icon" type="image/x-icon" href="/icons/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  

    
      <link rel="stylesheet" type="text/css" title="light" id="light" href="/css/light.css">
      <link rel="stylesheet" type="text/css" title="dark" id="dark" href="/css/dark.css" disabled="false">
    

  

</head>

<body>
  <main>
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav scrollappear">
  <a href="/" class="header-logo" title="devyonghee blog">devyonghee blog</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-about">
  <use href="/icons/about.svg#icon-about"
       xlink:href="/icons/about.svg#icon-about">
  </use>
</svg>

        </a>
      </li>
    

    
    <li>
      <a href="/tags" title="Tags">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon-tag">
  <use href="/icons/tag.svg#icon-tag"
       xlink:href="/icons/tag.svg#icon-tag">
  </use>
</svg>

      </a>
    </li>
    

    
    
    
    
      <li>
        <a href="https://github.com/devyonghee" rel="noreferrer noopener" target="_blank" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-github">
  <use href="/icons/github.svg#icon-github"
       xlink:href="/icons/github.svg#icon-github">
  </use>
</svg>

        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="mailto:devyonghee@gmail.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-email">
  <use href="/icons/email.svg#icon-email"
       xlink:href="/icons/email.svg#icon-email">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" rel="noreferrer noopener" target="_blank" title="RSS">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-rss">
  <use href="/icons/rss.svg#icon-rss"
       xlink:href="/icons/rss.svg#icon-rss">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a id="toggleBtn" title="Toggle Theme">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-theme">
  <use href="/icons/theme.svg#icon-theme"
       xlink:href="/icons/theme.svg#icon-theme">
  </use>
</svg>

        </a>
      </li>
    
  </ul>
</nav>
        <article class="article scrollappear">
          <header class="article-header">
            <h1>[Study] 운영체제 아주 쉬운 세가지 이야기 25장~28장</h1>
            <p></p>
            <div class="article-list-footer">
  <span class="article-list-date">
    November 25, 2022
  </span>
  <span class="article-list-divider">-</span>
  <span class="article-list-minutes">
    
    
      12 minute read
    
  </span>
  <span class="article-list-divider">-</span>
  <div class="article-list-tags">
    
      <a href="/tag/study" title="See all posts with tag 'study'">study</a>
    
      <a href="/tag/book" title="See all posts with tag 'book'">book</a>
    
      <a href="/tag/operation-system" title="See all posts with tag 'operation-system'">operation-system</a>
    
  </div>
</div>
          </header>

          <div class="article-content">
            <p>운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.<br />
이 글에서는 병행성에 대해 다룬 25장부터 28장까지의 내용을 정리한다.</p>

<!--more-->

<h2 id="25장-병행성에-관한-대화">25장. 병행성에 관한 대화</h2>

<p>멀티쓰레드 프로그램에서 각 쓰레드는 독립된 객체로 프로그램을 대신하여 일을 한다.<br />
쓰레드들은 동시에 메모리에 접근하게 되는데 이를 조정하지 않으면 예상치 못한 문제가 발생될 수 있다.</p>

<h3 id="운영체제와-병행성">운영체제와 병행성</h3>

<ul>
  <li><strong>락(lock)</strong> 과 <strong>컨디션 변수(conditional variable)</strong> 같은 기본 동작으로 멀티 쓰레드 프로그램을 지원해야 함</li>
  <li>운영체제 역시 최초의 동시 프로그램 (메모리 영역도 조심스럽게 접근 필요)</li>
</ul>

<p><br /></p>

<h2 id="26장-병행성-개요">26장. 병행성: 개요</h2>

<p>멀티 쓰레드 프로그램은 하나 이상의 실행 지점을 가지고 있다.<br />
<strong>쓰레드(Thread)</strong> 들은 주소 공간을 공유하기 때문에 동일한 값에 접근할 수 있다.</p>

<p>쓰레드의 상태는 프로세스와 유사하며, 명령어를 가져오는 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가지고 있다. <br />
두 쓰레드가 하나의 프로세서에서 실행중이라면 <strong>문맥 교환(context switch)</strong> 를 통해 실행중인 쓰레드와 교체된다.<br />
여기서 교환되는 상태를 <strong>프로세스 제어 블럭(process control block, PCB)</strong> 에 저장하듯이 <strong>쓰레드 제어 블럭(thread control block, TCB)</strong> 을 사용한다.<br />
프로세스와 달리 쓰레드간의 문맥 교환은 주소 공간(페이지 테이블)을 그대로 사용한다.</p>

<figure>
    <a href="/images/study/operating-system/single-multi-thread-address-space.png">
        <img src="/images/study/operating-system/single-multi-thread-address-space.png" data-rjs="/images/study/operating-system/single-multi-thread-address-space.png" class="zooming" alt="단일 쓰레드와 멀티 쓰레드의 주소 공간" />
    </a>
    
    <figcaption>
        단일 쓰레드와 멀티 쓰레드의 주소 공간
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<p>멀티 쓰레드 프로세스의 경우, 주소 공간에 쓰레드마다 스택이 할당되어 있다.<br />
로컬 변수, 매개변수, 리턴 값, 그외 스택에 넣는 것들은 해당 쓰레드의 스택인 <strong>쓰레드-로컬 저장소(thread-local storage)</strong> 에 저장된다.</p>

<h3 id="261-왜-쓰레드를-사용하는가">26.1 왜 쓰레드를 사용하는가?</h3>

<p>쓰레드를 사용해야 하는 이유 2가지</p>

<ul>
  <li><strong>병렬 처리(parallelism)</strong>
    <ul>
      <li>단일 쓰레드(single-threaded) 프로그램을 멀티프로세서 프로그램으로 변환하는 작업을 <strong>병렬화(parallelization)</strong> 라고 함</li>
      <li>작업의 일부분을 나눠서 실행하여 실행 속도를 높일 수 있음</li>
    </ul>
  </li>
  <li>I/O 로 인해 프로그램 실행이 멈추지 않도록 함
    <ul>
      <li>하나의 쓰레드가 대기하는 동안 다른 쓰레드로 전환 가능</li>
      <li>쓰레딩은 하나의 프로그램 안에서 다른 작업이 중첩(overlap) 될 수 있게 함 (멀티 프로그래밍과 비슷)</li>
    </ul>
  </li>
</ul>

<h3 id="262-예제-쓰레드-생성">26.2 예제: 쓰레드 생성</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">mythread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span> 

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"main: begin</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="s">"A"</span><span class="p">);</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="s">"B"</span><span class="p">);</span>
    <span class="c1">// 대기 중인 쓰레드 병합</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"main: end</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<figure>
    <a href="/images/study/operating-system/thread-creation-code-execute.png">
        <img src="/images/study/operating-system/thread-creation-code-execute.png" data-rjs="/images/study/operating-system/thread-creation-code-execute.png" class="zooming" alt="쓰레드 실행 추적" />
    </a>
    
    <figcaption>
        쓰레드 실행 추적
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<p>실행 가능 순서는 유일하지 않다.<br />
다음에 실행될 쓰레드는 <strong>OS 스케줄러(scheduler)</strong> 에 의해 결정된다.<br />
하지만 어떤 쓰레드가 언제 실행되는지 알기 어렵기 때문에 병행성이 더 어려워진다.</p>

<h3 id="263-훨씬-더-어려운-이유-데이터-공유">26.3 훨씬 더 어려운 이유: 데이터 공유</h3>

<p>각 쓰레드에서 공유 변수에 접근하여 수정하게 된다면 예상치 못한 결과가 나온다.<br />
예를 들어, 두 쓰레드에서 공유 변수에 +1 하는 과정을 10000번을 반복한다면 20000 이 나오지 않는 문제가 발생한다.</p>

<h3 id="264-문제의-핵심-제어-없는-스케줄링">26.4 문제의 핵심: 제어 없는 스케줄링</h3>

<p>위 문제처럼 명령어의 실행 순서에 따라 결과가 달라지는 상황을 <strong>경쟁 조건(race condition)</strong> 또는 <strong>데이터 경쟁(data race)</strong> 이라고 한다.<br />
문맥 교환이 적절하게 실행되지 않으면 잘못된 결과가 나온다.<br />
이처럼 실행할 때마다 결과가 다른 경우를 <strong>비결정적(indeterminate)</strong> 인 결과라고 한다.</p>

<p>공유 변수를 접근하고 하나 이상의 쓰레드에서 동시에 실행되면 안 되는 코드를 <strong>임계 영역(critical section)</strong> 이라고 한다.  <br />
이러한 코드에서는 <strong>상호 배제(mutual exclusion)</strong> 속성이 필요하다.<br />
한 쓰레드에서 임계 영역 내의 코드를 실행 중일 때 다른 쓰레드가 실행할 수 없도록 보장하는 것이다.</p>

<h3 id="265-원자성에-대한-바람">26.5 원자성에 대한 바람</h3>

<p>임계 영역 문제 해결 방법 중 하나로 원자적으로 실행되는 명령어 한개를 수행하여, 수행 도중에 인터럽트 발생 가능성을 차단하는 것이다.
따라서 하드웨어에 <strong>동기화 함수(synchronization primitives)</strong> 구현에 필요한 명령어를 요청한다.  <br />
하드웨어 지원을 사용하고 운영체제의 도움을 받아 하나의 쓰레드만 임계 영역에서 실행해야 한다.</p>

<h3 id="266-또-다른-문제-상대-기다리기">26.6 또 다른 문제: 상대 기다리기</h3>

<p>하나의 쓰레드가 다른 쓰레드의 동작이 끝날 때까지 대기해야 하는 상황도 발생한다.<br />
디스크 I/O 로 요청으로 인해 잠든 경우, I/O 완료 후 쓰레드가 일어나 이후의 작업을 진행하도록 해야 한다.</p>

<h3 id="267-정리-왜-운영체제에서">26.7 정리: 왜 운영체제에서?</h3>

<p>운영체제는 최초의 병행 프로그램으로 운영체제 내에서 사용하기 위해 이러한 기법들이 생성되었다.<br />
멀티 쓰레드 프로그램이 등장하면서 응용 프로그래머들도 비슷한 문제를 고민하게 되었다.</p>

<h3 id="주요-용어">주요 용어</h3>

<ul>
  <li><strong>임계 영역(critical section)</strong>
    <ul>
      <li>변수나 자료 구조와 같은 공유 자원을 접하는 코드의 일부분</li>
    </ul>
  </li>
  <li><strong>경쟁 조건(race condition)</strong> 혹은 <strong>데이터 경쟁(data race)</strong>
    <ul>
      <li>멀티 쓰레드가 동시에 임계 영역을 실행하려고 할 때 발생</li>
      <li>공유 자료 구조에 대해 동시에 접근하면 예상치 못한 결과 발생</li>
    </ul>
  </li>
  <li><strong>비결정적(indeterminate)</strong>
    <ul>
      <li>프로그램의 실행 결과가 실행할 때마다 다름</li>
    </ul>
  </li>
  <li><strong>상호 배제(mutual exclusion)</strong>
    <ul>
      <li>임계 영역에 대해 한 번에 하나의 쓰레드만 접근할 수 있도록 보장</li>
      <li>경쟁을 피할 수 있고 실행결과를 결정론적으로 얻을 수 있음</li>
    </ul>
  </li>
</ul>

<h2 id="27장-막간-쓰레드-api">27장. 막간: 쓰레드 API</h2>

<p>쓰레드 API 의 주요 부분을 다룬다.</p>

<h3 id="271-쓰레드-생성">27.1 쓰레드 생성</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">pthread_create</span> <span class="p">(</span><span class="n">pthread_t</span>            <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> 
                <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
                <span class="kt">void</span>                 <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> 
                <span class="kt">void</span>                 <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">thread</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">pthread_t</code> 타입 구조체를 가리키는 포인터</li>
      <li>이 구조체가 쓰레드와 상호작용</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">attr</code>
    <ul>
      <li>쓰레드의 속성 지정 (스택의 크기와 쓰레드의 스케줄링 우선순위 같은 정보)</li>
      <li><code class="language-plaintext highlighter-rouge">NULL</code> 로 지정하면 기본값 사용 (대부분 기본값으로 충분)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">start_routine</code>
    <ul>
      <li>쓰레드가 시작할 때 실행할 함수</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">arg</code>
    <ul>
      <li>실행할 함수에게 전달할 인자</li>
    </ul>
  </li>
</ul>

<h3 id="272-쓰레드-종료">27.2 쓰레드 종료</h3>

<p>쓰레드의 완료를 기다리기 위한 함수</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_join</span> <span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">value_ptr</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_t thread</code>
    <ul>
      <li>어떤 쓰레드를 기다리는지 명시 (쓰레드 생성 루틴에 의해 초기화)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">value_ptr</code>
    <ul>
      <li>반환 값에 대한 포인터</li>
      <li>전달된 인자의 값을 변경하기 때문에 포인터를 전달</li>
    </ul>
  </li>
</ul>

<h3 id="273-락">27.3 락</h3>

<p>쓰레드 라이브러리에서는 <strong>락(lock)</strong> 함수를 통해 임계 영역에 대한 상호 배제 기법을 제공한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutext_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutext_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutext_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="c1">// int rc = pthread_mutext_init(&amp;lock, NULL); 이 방식으로도 초기화 가능</span>
<span class="n">pthread_mutext_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">pthread_mutext_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutext_lock</code> 가 호출되었을 때 다른 쓰레드도 락을 가지고 있지 않다면 락을 얻어 임계 영역에 진입</li>
  <li>다른 쓰레드가 락을 가지고 있으면 락을 얻을 때까지 호출에서 리턴하지 않음</li>
  <li>락을 획득한 쓰레드가 언락을 호출해야 함</li>
  <li>락과 언락을 호출할 때 에러 코드 확인 필요</li>
</ul>

<h3 id="274-컨디션-변수">27.4 컨디션 변수</h3>

<p>한 쓰레드가 계속 진행하기 전에 다른 쓰레드가 작업을 기다리는 일종의 쓰레드 간에 시그널 교환할 수 있는 <strong>컨디션 변수(condition variable)</strong> 을 제공한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">pthread_cond_wait</code> 는 호출 쓰레드를 수면(sleep) 상태로 만들고 다른 쓰레드로부터 시그널을 대기한다.
수면중인 쓰레드가 관심있는 사항이 변경되면 시그널을 보낸다.</p>

<p>또한, 컨디션 변수를 사용하려면 연결된 락이 반드시 필요하다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutext_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
<span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>시그널을 보내고 전역 변수 <code class="language-plaintext highlighter-rouge">ready</code> 를 수정할 때 락을 가지고 있어야 함</li>
  <li>시그널 보내기 함수에서는 조건만을 인자로 받는 것에 유의해야 함</li>
  <li>대기하는 쓰레드가 조건을 검사할 때 <code class="language-plaintext highlighter-rouge">if</code> 대신 <code class="language-plaintext highlighter-rouge">while</code> 문 사용해야 함</li>
</ul>

<h3 id="275-컴파일과-실행">27.5 컴파일과 실행</h3>

<p><code class="language-plaintext highlighter-rouge">-pthread</code> 플래그를 추가하여 pthread 라이브러리와 링크해야 함</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prompt&gt; gcc -o main main.c -Wall -pthread
</code></pre></div></div>

<p><br /></p>

<h2 id="28장-락">28장. 락</h2>

<p><strong>락(lock)</strong> 을 이용하여 병행 프로그램의 근본적인 문제를 다룬다.<br />
임계 영역을 락으로 둘러서 하나의 원자 단위 명령어인 것처럼 실행되도록 한다.</p>

<h3 id="281-락-기본-개념">28.1 락: 기본 개념</h3>

<p>락은 일종의 변수로 사용하기 위해 락 변수를 먼저 선언해야 한다.<br />
두 개의 상태가 있는데 <strong>사용가능 상태(available, unlocked, free)</strong> 상태와 <strong>사용 중(acquired)</strong> 상태가 존재한다.<br />
<code class="language-plaintext highlighter-rouge">lock()</code> 루틴 호출을 통해 락 획득을 시도하고, <code class="language-plaintext highlighter-rouge">unlock()</code> 호출을 하면 락은 다시 사용 가능한 상태로 된다.</p>

<p>락을 획득한 쓰레드는 락 <strong>소유자(owner)</strong> 라고 한다.</p>

<h3 id="282-pthread-락">28.2 Pthread 락</h3>

<p>쓰레드 간에 <strong>상호 배제(mutual exclusion)</strong> 기능을 제공하기 때문에 POSIX 라이브러리는 락을 <strong>mutex</strong> 라고 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">Phtread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<p>다른 변수를 보호하기 위해 다른 락을 사용할 수도 있다.<br />
하나의 락으로 모든 임계 영역들을 보호하는 것은 <strong>coarse-grained</strong> 락 사용 전략,<br />
다수의 쓰레드가 서로 다른 락으로 보호된 코드를 실행하는 것은 <strong>미세(fine-grained)</strong> 락 사용 전략이라고 한다.</p>

<h3 id="283-락의-구현">28.3 락의 구현</h3>

<p>사용 가능한 락을 만들기 위해서는 하드웨어와 운영체제 도움이 필요하다.</p>

<h3 id="284-락의-평가">28.4 락의 평가</h3>

<p>락 설계시, 정상동작 여부 판단을 위해 판단 기준이 필요하다.</p>

<ul>
  <li><strong>상호 배제</strong> 를 제대로 지원하는가
    <ul>
      <li>임계 영역 내로 다수의 쓰레드가 진입을 막을 수 있는가</li>
    </ul>
  </li>
  <li><strong>공정성(fairness)</strong>
    <ul>
      <li>락 획득에 대한 공정한 기회가 주어지는가</li>
      <li>락을 획득하지 못하는 굶주리는(starve) 경우가 발생하는가</li>
    </ul>
  </li>
  <li><strong>성능(performance)</strong>
    <ul>
      <li>경쟁이 전혀 없는 경우의 성능</li>
      <li>단일 CPU 상에서 락을 획득하려고 경쟁할 때 성능</li>
      <li>멀티 CPU 상황에서 락 경쟁 시의 성능</li>
    </ul>
  </li>
</ul>

<h3 id="285-인터럽트-제어">28.5 인터럽트 제어</h3>

<p>초창기 단일 프로세스 시스템에서는 임계 영역 내에서는 인터럽트를 비활성화화여 상호 배제를 지원했다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">DisableInterrupts</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">EnableInterrupts</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="장점">장점</h4>

<ul>
  <li>단순</li>
</ul>

<h4 id="단점">단점</h4>

<ul>
  <li>쓰레드가 인터럽트를 활성/비활성화하는 <strong>특권(privileged)</strong> 연산을 실행할 수 있도록 허가 필요
    <ul>
      <li>악의적인 프로그램이 독점하거나 무한 반복문에 빠질 수 있음</li>
    </ul>
  </li>
  <li>멀티프로세서에서 적용 불가능
    <ul>
      <li>특정 프로세서의 인터럽트 비활성화는 다른 프로세서에 영향을 주지 않음 (임계 영역 진입 가능)</li>
    </ul>
  </li>
  <li>장시간동안 인터럽트를 중지하면 중요한 시점을 놓칠 수 있음</li>
  <li>최신의 CPU 들에서는 느리게 실행되는 경향이 있음</li>
</ul>

<h3 id="286-실패한-시도-오직-loadstore-명령어만-사용하기">28.6 실패한 시도: 오직 load/store 명령어만 사용하기</h3>

<p>load/store 명령어만으로는 락의 구현이 불가능하다.</p>

<ul>
  <li>상호 배제 제공 실패
    <ul>
      <li>적시에 인터럽트가 발생하면 두 쓰레드 모두 플래그가 예상치 못한 값으로 설정되어 임계 영역에 두 쓰레드가 진입 가능</li>
    </ul>
  </li>
  <li>성능 저하
    <ul>
      <li>다른 쓰레드가 락을 해제할 때까지 시낭 낭비</li>
    </ul>
  </li>
</ul>

<h3 id="287-test-and-set-을-사용하여-작동하는-스핀-락-구현하기">28.7 Test-And-Set 을 사용하여 작동하는 스핀 락 구현하기</h3>

<p><strong>test-and-set</strong> 명령어 또는 <strong>원자적 교체(atomic exchange)</strong> 명령어가 락 지원을 위한 하드웨어 기법 중 가장 기본이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">TestAndSet</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">old_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_ptr</span><span class="p">;</span>  <span class="c1">// old_ptr 의 이전 값 가져옴</span>
    <span class="o">*</span><span class="n">old_ptr</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>      <span class="c1">// old_ptr 에 new 값 설정</span>
    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">TestAndSet</code> 명령어는 이전 값을 <strong>검사(test)</strong> 하면서 메모리에 새로운 값을 <strong>설정(set)</strong> 하기 때문에 원자적으로 수행된다.<br />
이 명령어만으로 <strong>스핀 락(spin lock)</strong> 을 만들 수 있다.<br />
스핀 락은 가장 기초적인 형태의 락으로, 락을 획득할 때까지 CPU 사이클을 소모하면서 회전한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">;</span> <span class="c1">//do nothing</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">unlcok</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="288-스핀-락-평가">28.8 스핀 락 평가</h3>

<ul>
  <li>상호 배제의 정확성
    <ul>
      <li>임의의 시간에 단 하나의 쓰레드만이 임계 영역에 진입할 수 있음</li>
    </ul>
  </li>
  <li>공정성 보장하지 못함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">while</code> 문을 회전 중인 쓰레드는 경쟁에 밀려 그 상태에 남아있을 수 있음</li>
    </ul>
  </li>
  <li>성능
    <ul>
      <li>단일 CPU 의 경우 오버헤드가 클 수 있음 (CPU 사이클 낭비)</li>
      <li>다중 CPU 의 경우 합리적으로 동작 (다른 CPU 에서 대기)</li>
    </ul>
  </li>
</ul>

<h3 id="289-compare-and-swap">28.9 Compare-And-Swap</h3>

<p>다른 하드웨어 기법으로는 SPARC 의 <strong>Compare-And-Swap</strong>, x86 에서는 <strong>Compare-And-Exchange</strong> 가 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">original</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">original</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span>
        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">original</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 기법은 <code class="language-plaintext highlighter-rouge">ptr</code> 이 가리키고 있는 주소의 값이 <code class="language-plaintext highlighter-rouge">extected</code> 변수와 일치하는지 검사하는 것이다.<br />
<strong>Compare-And-Swap</strong> 명령어는 <code class="language-plaintext highlighter-rouge">TestAndSet</code> 명령어보다 더 강력하고 <strong>대기 없는 동기화(wait-free synchronization)</strong> 를 제공한다.</p>

<h3 id="2810-load-linked-그리고-store-conditional">28.10 Load-Linked 그리고 Store-Conditional</h3>

<p>MIPS 구조에서는 <strong>load-linked</strong> 와 <strong>store-conditional</strong> 명령어를 사용하여 락이나 병행 연산을 위한 자료구조를 만들 수 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">LoadLinked</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">StoreConditional</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">no</span> <span class="n">updat</span> <span class="n">to</span> <span class="o">*</span> <span class="n">ptr</span> <span class="n">since</span> <span class="n">the</span> <span class="n">LoadLinked</span> <span class="n">to</span> <span class="n">this</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 성공</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 갱신 실패</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LoadLinked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">StoreConditional</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">;</span> <span class="c1">// 회전</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2811-fetch-and-add">28.11 Fetch-And-Add</h3>

<p>이 기법은 Fetch-And-Add 명령어로 원자적으로 특정 주소의 예전 값을 반환하면서 값을 증가시킨다. <br />
모든 쓰레드들이 각자의 순서에 따라 진행</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">FetchAndAdd</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2812-요약-과도한-스핀">28.12 요약: 과도한 스핀</h3>

<p>위에서 소개한 하드웨어 기반의 락은 간단하고 잘 동작한다.<br />
하지만 쓰레드가 스핀 구문을 실행하면서 변경되기를 기다리며 시간을 낭비한다.<br />
쓰레드가 경쟁하게 되면 상황은 더 심해진다.</p>

<h3 id="2813-간단한-접근법-조건-없는-양보">28.13 간단한 접근법: 조건 없는 양보!</h3>

<p>다른 쓰레드에서 락을 획득한 상태라서 스핀만 무한히 하는 경우에 대한 해결책 알아본다. <br />
락이 해제되기를 기다려야 할 경우 CPU 를 다른 쓰레드에게 양보하는 것이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">yield</span><span class="p">();</span>  <span class="c1">// 다른 쓰레드에게 CPU 양보</span>
<span class="p">}</span>
</code></pre></div></div>

<p>쓰레드는 실행중(running), 준비(ready), 막힘(blocked) 세 가지 상태가 있다.<br />
<strong>양보(yield)</strong> 시스템 콜은 실행 중(running) 상태에서 준비(ready) 상태로 변환하여 다른 쓰레드가 실행 중 상태로 전이하도록 한다.<br />
하지만 이 기법은 문맥 교환 비용이 상당하며 낭비가 많다.</p>

<h3 id="2814-큐의-사용-스핀-대신-잠자기">28.14 큐의 사용: 스핀 대신 잠자기</h3>

<p>다수의 쓰레드가 대기하는 경우 명시적으로 쓰레드를 선택할 수 있도록 운영체제의 지원과 큐를 이용한 대기 쓰레드 관리가 필요하다.<br />
Solaris 방식에서는 쓰레드를 잠재우는 <code class="language-plaintext highlighter-rouge">park()</code>, 깨우는 <code class="language-plaintext highlighter-rouge">unpark(threadID)</code> 함수가 있다.</p>

<p>락 대기자 전용 큐를 사용하여 락을 더 효율적이고 기아 현상을 피할 수 있도록 구현한다.<br />
이 방식은 스핀 대기 시간이 상당히 짧아 오버헤드가 작다.</p>

<p>하지만 쓰레드가 <code class="language-plaintext highlighter-rouge">park()</code> 호출 직전에 다른 쓰레드에서 락을 해제하면 블럭 상태(<strong>wakeup/waiting race</strong> 문제)가 되기 때문에 경쟁 조건이 발생할 수 있다.  <br />
이 문제는 <code class="language-plaintext highlighter-rouge">setpark()</code> 를 추가하면서 해결했다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> 
        <span class="p">;</span> <span class="c1">// 회전하면서 guard 락 획득</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 락 획득</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">queue_add</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">gettid</span><span class="p">());</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">park</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">;</span> <span class="c1">// 회전하면서 guard 락 획득</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_empty</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">))</span> 
         <span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 락 포기</span>
    <span class="k">else</span>
        <span class="n">unpark</span><span class="p">(</span><span class="n">queue_remove</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">));</span>  <span class="c1">// 락 획득</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2815-다른-운영체제-다른-지원">28.15 다른 운영체제, 다른 지원</h3>

<p>Linux 의 경우 <strong>futex</strong> 를 지원한다. <br />
futex 는 특정 물리 메모리 주소 그리고 커널에 정의된 큐를 갖고 있다.
쓰레드를 블럭시키는 <code class="language-plaintext highlighter-rouge">futex_wait(address, expected)</code> , 큐에서 대기하고 있는 쓰레드를 깨우는 <code class="language-plaintext highlighter-rouge">futext_wake(address)</code> 명령어가 존재한다.</p>

<h3 id="2816-2단계-락">28.16 2단계 락</h3>

<p>Linux의 락은 <strong>2단계(two-phase lock)</strong> 이라고 불린다.<br />
첫 번째 단계에서는 회전하며 대기하고, 획득하지 못했다면 두 번째 단계에서 호출자는 차단된다.<br />
락 해제시 블럭된 쓰레드중 하나를 깨웩 된다.</p>

          </div>
          <div class="article-share">
            
            
            <a href="https://twitter.com/home?status=[Study]+%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C+%EC%95%84%EC%A3%BC+%EC%89%AC%EC%9A%B4+%EC%84%B8%EA%B0%80%25E...%20-%20https://devyonghee.github.io/study/2022/11/25/operation-system-three-easy-pieces-25-28/" title="Share on Twitter" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6 -18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6 0.8 15 2.5 22.1 -80.5-4-151.9-42.6-199.6-101.3 -8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7C67 210.7 52 206.3 39 199c0 0.4 0 0.8 0 1.2 0 47 33.4 86.1 77.7 95 -8.1 2.2-16.7 3.4-25.5 3.4 -6.2 0-12.3-0.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3 -33.1 26-74.9 41.5-120.3 41.5 -7.8 0-15.5-0.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-0.1-8.4-0.3-12.5C462.6 146 479 129 492 109.5z"/></svg>
            </a>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://devyonghee.github.io/study/2022/11/25/operation-system-three-easy-pieces-25-28/" title="Share on Facebook" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M288 192v-38.1c0-17.2 3.8-25.9 30.5-25.9H352V64h-55.9c-68.5 0-91.1 31.4-91.1 85.3V192h-45v64h45v192h83V256h56.4l7.6-64H288z"/></svg>
            </a>
          </div>
          
            <script src="https://utteranc.es/client.js"
                    repo="devyonghee/devyonghee.github.io"
                    issue-term="pathname"
                    theme="preferred-color-scheme"
                    crossorigin="anonymous"
                    async>
            </script>
          
        </article>
        <footer class="footer scrollappear">
  <p>
    Chalk is a high quality, completely customizable, performant and 100% free
    blog template for Jekyll built by
    <a href="/about" title="About me">Nielsen Ramon</a>. Download it <a href="https://github.com/nielsenramon/chalk" rel="noreferrer noopener" target="_blank" title="Download Chalk">here</a>.
  </p>
</footer>

      </div>
    </div>
  </main>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7PS3PZYZ6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Q7PS3PZYZ6');
  </script>


  <script src="/javascripts/application.f8aad56336bbc2752062.js"></script>


  <script src="/javascripts/scrollappear.964ae3fd7af0dfd85a7e.js"></script>




  <script src="/javascripts/themetoggle.b54b8a02c0c26756418e.js"></script>

</body>
</html>
