<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>devyonghee blog | [Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="[Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://devyonghee.github.io/study/2022/12/05/operation-system-three-easy-pieces-35-40/">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="devyonghee blog">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://devyonghee.github.io/study/2022/12/05/operation-system-three-easy-pieces-35-40/">
  <meta name="twitter:title" content="[Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장">
  <meta name="twitter:description" content="">

  
    <meta name="google-site-verification" content="1DbhSO778Ec8l_4qztuQgVDcPhc_ya64RGP-nwD_bj0" />
  

  
    <meta property="og:image" content="">
    <meta name="twitter:image" content="">
  

  <link href="https://devyonghee.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="devyonghee blog Last 10 blog posts" />
  <link rel="stylesheet" type="text/css" href="/css/fonts.css">


  <link rel="icon" type="image/x-icon" href="/icons/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  

    
      <link rel="stylesheet" type="text/css" title="light" id="light" href="/css/light.css">
      <link rel="stylesheet" type="text/css" title="dark" id="dark" href="/css/dark.css" disabled="false">
    

  

</head>

<body>
  <main>
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav scrollappear">
  <a href="/" class="header-logo" title="devyonghee blog">devyonghee blog</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-about">
  <use href="/icons/about.svg#icon-about"
       xlink:href="/icons/about.svg#icon-about">
  </use>
</svg>

        </a>
      </li>
    

    
    <li>
      <a href="/tags" title="Tags">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon-tag">
  <use href="/icons/tag.svg#icon-tag"
       xlink:href="/icons/tag.svg#icon-tag">
  </use>
</svg>

      </a>
    </li>
    

    
    
    
    
      <li>
        <a href="https://github.com/devyonghee" rel="noreferrer noopener" target="_blank" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-github">
  <use href="/icons/github.svg#icon-github"
       xlink:href="/icons/github.svg#icon-github">
  </use>
</svg>

        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="mailto:devyonghee@gmail.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-email">
  <use href="/icons/email.svg#icon-email"
       xlink:href="/icons/email.svg#icon-email">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" rel="noreferrer noopener" target="_blank" title="RSS">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-rss">
  <use href="/icons/rss.svg#icon-rss"
       xlink:href="/icons/rss.svg#icon-rss">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a id="toggleBtn" title="Toggle Theme">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-theme">
  <use href="/icons/theme.svg#icon-theme"
       xlink:href="/icons/theme.svg#icon-theme">
  </use>
</svg>

        </a>
      </li>
    
  </ul>
</nav>
        <article class="article scrollappear">
          <header class="article-header">
            <h1>[Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장</h1>
            <p></p>
            <div class="article-list-footer">
  <span class="article-list-date">
    December 5, 2022
  </span>
  <span class="article-list-divider">-</span>
  <span class="article-list-minutes">
    
    
      21 minute read
    
  </span>
  <span class="article-list-divider">-</span>
  <div class="article-list-tags">
    
      <a href="/tag/study" title="See all posts with tag 'study'">study</a>
    
      <a href="/tag/book" title="See all posts with tag 'book'">book</a>
    
      <a href="/tag/operation-system" title="See all posts with tag 'operation-system'">operation-system</a>
    
  </div>
</div>
          </header>

          <div class="article-content">
            <p>운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.<br />
이 글에서는 영속성에 대해 다룬 35장부터 40장까지의 내용을 정리한다.</p>

<!--more-->

<h2 id="35장-영속성에-관한-대화">35장. 영속성에 관한 대화</h2>

<p>컴퓨터가 멈추고 디스크가 고장나고 전원이 꺼져도 정보를 그대로 유지해야 한다.</p>

<p><br /></p>

<h2 id="36장-io-장치">36장. I/O 장치</h2>

<p><strong>입력/출력 장치(I/O)</strong> 의 개념과 이 장치가 운영체제와 상호 작용하는 방법을 알아본다.</p>

<h3 id="361-시스템-구조">36.1 시스템 구조</h3>

<figure>
    <a href="/images/study/operating-system/simple-system-structure.png">
        <img src="/images/study/operating-system/simple-system-structure.png" data-rjs="/images/study/operating-system/simple-system-structure.png" class="zooming" alt="시스템 구조 모형" />
    </a>
    
    <figcaption>
        시스템 구조 모형
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<p>CPU 와 주메모리는 메모리 버스로 연결되어 있다.<br />
몇몇 장치들은 범용 <strong>I/O 버스</strong> 에 연결되어 있는데, 현대 시스템에서는 <strong>PCI</strong> 를 사용한다.
그 아래에는 SCSI, SATA(Serial ATA), USB 와 같은 <strong>주변 장치용 버스</strong> 가 있고 이를 통해 디스크, 마우스, 키보드 같은 장치가 연결된다.</p>

<figure>
    <a href="/images/study/operating-system/modern-system-structure.png">
        <img src="/images/study/operating-system/modern-system-structure.png" data-rjs="/images/study/operating-system/modern-system-structure.png" class="zooming" alt="현대식 시스템 구조" />
    </a>
    
    <figcaption>
        현대식 시스템 구조
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<p>현대식 시스템은 칩셋들과 점대점 연결 방식을 늘리고 있다.</p>

<ul>
  <li>DMI(Direct Media Interface)
    <ul>
      <li>CPU가 이 기술로 I/O 칩에 연결</li>
    </ul>
  </li>
  <li>eSATA(external SATA)
    <ul>
      <li>하드 디스크들이 연결</li>
    </ul>
  </li>
  <li>ATA(AT attachment, 고급 기술 결합)</li>
  <li>SATA(Serial ATA)</li>
  <li>PCIe(Peripheral Component Interconnect Express, 주변 장치 연결 익스프레스)</li>
</ul>

<h3 id="362-표준-장치">36.2 표준 장치</h3>

<p>가상의 표준 장치를 효율적 활용하기 위한 두 가지 요소가 있다.</p>

<ul>
  <li>하드웨어 인터페이스 (레지스터 상태, 명령, 데이터)
    <ul>
      <li>인터페이스를 제공하여 시스템 소프트웨어가 동작을 제어할 수 있도록 해야 함</li>
    </ul>
  </li>
  <li>내부 구조(CPU, 메모리, 하드웨어에 특화된 칩)
    <ul>
      <li>장치의 기능을 추상화하여 시스템 제공하에 목적에 맞게 동작 해야 함</li>
    </ul>
  </li>
</ul>

<h3 id="363-표준-방식">36.3 표준 방식</h3>

<p>장치의 인터페이스는 세 개의 레지스터로 구성되어 있다.</p>

<ul>
  <li><strong>상태(status)</strong> 레지스터
    <ul>
      <li>장치의 현재 상태를 읽음</li>
    </ul>
  </li>
  <li><strong>명령(command)</strong> 레지스터
    <ul>
      <li>장치가 데이터를 보내거나 받거나 할 때 사용</li>
    </ul>
  </li>
  <li><strong>데이터(data)</strong> 레지스터
    <ul>
      <li>장치에 데이터를 보내거나 받거나 할 때 사용</li>
    </ul>
  </li>
</ul>

<p>장치가 동작을 할 때 다음과 같은 방식을 따른다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">While</span> <span class="p">(</span><span class="n">STATUS</span> <span class="o">==</span> <span class="n">BUSY</span><span class="p">)</span>
    <span class="p">;</span> <span class="c1">// 장치가 바쁜 상태가 아닐 때까지 대기</span>
<span class="err">데이터를</span> <span class="n">DATA</span> <span class="err">레지스터에</span> <span class="err">쓰기</span>
<span class="err">명령어를</span> <span class="n">COMMAND</span> <span class="err">레지스터에</span> <span class="err">쓰기</span> <span class="p">(</span><span class="err">장치가</span> <span class="err">명령어</span> <span class="err">실행</span><span class="p">)</span>
<span class="n">While</span> <span class="p">(</span><span class="n">STATUS</span> <span class="o">==</span> <span class="n">BUSY</span><span class="p">)</span>
    <span class="p">;</span> <span class="c1">// 요청을 완료할 때까지 대기        </span>
</code></pre></div></div>

<ol>
  <li>반복적으로 상태 레지스터를 읽어서 명령의 수신 여부 판단 (<strong>polling</strong> 방식, 비효율적)</li>
  <li>운영체제가 데이터 레지스터에 데이터 전달 (데이터 전송에 메인 CPU 가 관여하게 되면 <strong>programmed I/O</strong> 라고 함)</li>
  <li>운영체제가 명령 레지스터에 명령어 기록</li>
  <li>디바이스가 처리 완료되었는지 폴링하면서 대기</li>
</ol>

<h3 id="364-인터럽트를-이용한-cpu-오버헤드-개선">36.4 인터럽트를 이용한 CPU 오버헤드 개선</h3>

<p>폴링 대신 입출력 작업을 요청한 프로세스를 블록시키고 CPU 를 다른 프로세스에게 양도한다.<br />
장치가 작업을 끝마치고 나면 하드웨어 인터럽트를 발생시키고 
CPU 는 <strong>인터럽트 서비스 루틴(interrupt service routine, ISR)</strong> 또는 <strong>인터럽트 핸들러(interrupt handler)</strong> 를 실행한다.</p>

<h4 id="단점">단점</h4>

<ul>
  <li>문맥 교환 비용 또한 비싸기 때문에 폴링이 빠른 장치라면 폴링 방식이 더 좋을 수 있음
    <ul>
      <li>장치 속도를 모른다면 짧은 시간동안만 폴링 하다가 인터럽트를 사용하는 <strong>하이브리드 방식</strong> 을 사용하는 것이 좋음</li>
    </ul>
  </li>
  <li>인터럽트만 처리하다가 프로세스 요청을 처리할 수 없도록 <strong>무한반복(livelock)</strong> 에 빠질 수 있음
    <ul>
      <li>폴링을 사용하면 보다 효율적으로 제어할 수 있음</li>
      <li><strong>병합(coalescing)</strong> 기법으로 잠시 기다렸다가 한번만 인터럽트를 발생시키는 방법으로 처리할 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="365-dma를-이용한-효율적인-데이터-이동">36.5 DMA를 이용한 효율적인 데이터 이동</h3>

<p>많은 양의 데이터를 디스크로 전달하기 위해 prodgrammed I/O(PIO) 를 사용하면 CPU 를 이용하기 때문에 비효율적이다.<br />
<strong>직접 메모리 접근 방식(Direct Memory Access, DMA)</strong> 을 사용하면 CPU 간섭없이 메모리와 장치 간에 전송할 수 있다.</p>

<h4 id="동작-과정">동작 과정</h4>

<ol>
  <li>데이터를 장치로 전송한다고 하면 DMA 엔진에 메모리상의 데이터 위치와 전송할 데이터의 크기와 대상 장치를 프로그램</li>
  <li>이 시점에 운영체제는 다른 작업을 수행</li>
  <li>DMA 동작이 끝나면 DMA 컨트롤러가 인터럽트를 발생시켜 완료되었다고 알림</li>
</ol>

<h3 id="366-디바이스와-상호작용하는-방법">36.6 디바이스와 상호작용하는 방법</h3>

<p>장치와 운영체제가 정보를 교환하는 기본적인 방법 두 가지를 알아본다.</p>

<ul>
  <li><strong>I/O</strong> 명령을 명시적으로 사용
    <ul>
      <li>운영체제가 특정 장치 레지스터에 데이터 전송할 수 있음</li>
      <li>대부분이 <strong>특권(privileged)</strong> 명령어 운영체제가 장치를 제어</li>
    </ul>
  </li>
  <li><strong>맵 입출력(memory mapped I/O)</strong>
    <ul>
      <li>장치의 레지스터들이 메모리 상에 존재하는 것처럼 만듦</li>
      <li>load/store 명령어가 주 메모리 대신 장치로 연결되도록 함</li>
    </ul>
  </li>
</ul>

<h3 id="367-운영체제에-연결하기-디바이스-드라이버">36.7 운영체제에 연결하기: 디바이스 드라이버</h3>

<p>서로 다른 인터페이스를 가진 장치들과 운영체제를 연결시키는 방법으로 <strong>추상화(abstraction)</strong> 가 있다.</p>

<ul>
  <li><strong>디바이스 드라이버(device driver)</strong>
    <ul>
      <li>장치의 동작 방식을 알고 있는 운영체제 최하위 계층의 일부 소프트웨어</li>
      <li>자세한 상호작용은 내부에 있음</li>
      <li>어떤 장치에도 필요하기 때문에 커널 코드의 대부분을 차지함</li>
      <li>특정 장치의 특별한 기능을 사용할 수 없을 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="37장-하드-디스크-드라이브">37장. 하드 디스크 드라이브</h2>

<p>시스템의 영구적인 데이터 저장소로 사용되는 하드 디스크 드라이브에 대해 알아본다.</p>

<h3 id="371-인터페이스">37.1 인터페이스</h3>

<p>드라이브는 읽고 쓸 수 있는 많은 수의 섹터(512byte 블럭)들로 이루어져있다.<br />
그래서 디스크를 섹터들의 배열로 볼 수 있으며 드라이브의 <strong>주소 공간</strong>이 된다.</p>

<p>많은 파일 시스템들은 한번에 4KB 를 읽거나 쓸 수 있지만,
드라이브는 512byte 쓰기만 <strong>원자성</strong> 을 보장하기 때문에 일부만 작성될 수 있다. (<strong>찢어 쓰기(torn write)</strong>)</p>

<h3 id="372-기본-구조">37.2 기본 구조</h3>

<ul>
  <li><strong>플래터(platter)</strong>
    <ul>
      <li>원형의 딱딱한 표면</li>
      <li>자기적 성질을 변형하여 데이터 지속</li>
      <li>디스크는 하나 또는 여러 개의 플래터를 갖고 있으며 각각은 2개의 표면(surface) 를 가짐</li>
    </ul>
  </li>
  <li><strong>회전축(spindle)</strong>
    <ul>
      <li>플래터들을 고정</li>
      <li>모터와 연결되어 있어서 플래터를 회전</li>
      <li><strong>분당 회전수(rotation per minute, RPM)</strong> 로 측정 되며 보통 7,200 ~ 15,000RPM</li>
    </ul>
  </li>
  <li><strong>트랙(track)</strong>
    <ul>
      <li>표면에 동심원을 따라 섹터들 위에 데이터가 부호화되는데 이 동심원 하나를 트랙이라고 함</li>
      <li>표면에 트랙들이촘촘하게 붙어 있음</li>
    </ul>
  </li>
  <li><strong>디스크 헤드(disk head)</strong>
    <ul>
      <li>디스크의 자기적 패턴을 감지하거나 변형을 유도하는 장치</li>
    </ul>
  </li>
  <li><strong>디스크 암(disk arm)</strong>
    <ul>
      <li>디스크 헤드를 트랙 위로 움직이는 장치</li>
    </ul>
  </li>
</ul>

<h3 id="373-간단한-디스크-드라이브">37.3 간단한 디스크 드라이브</h3>

<figure>
    <a href="/images/study/operating-system/one-track-disk.png">
        <img src="/images/study/operating-system/one-track-disk.png" data-rjs="/images/study/operating-system/one-track-disk.png" class="zooming" alt="트랙 하나와 헤드" />
    </a>
    
    <figcaption>
        트랙 하나와 헤드
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<p>이 트랙에는 12개의 섹터가 있고 각 섹터는 512 byte 크기를 갖고 있다.<br />
주소 영역은 0 부터 11까지(0 ~ n-1)로 이루어져 있다.</p>

<h4 id="단일-트랙-지연-시간-회전-지연">단일 트랙 지연 시간: 회전 지연</h4>

<p><strong>회전형 지연(rotational delay)</strong> 또는 <strong>회전 지연(rotation delay)</strong> 은 디스크 헤드 아래에 원하는 섹터가 위치할 때까지 기다리는 것을 의미한다.</p>

<h4 id="멀티-트랙-탐색-시간">멀티 트랙: 탐색 시간</h4>

<figure>
    <a href="/images/study/operating-system/disk-track-seek.png">
        <img src="/images/study/operating-system/disk-track-seek.png" data-rjs="/images/study/operating-system/disk-track-seek.png" class="zooming" alt="탐색을 포함한 트랙과 헤드" />
    </a>
    
    <figcaption>
        탐색을 포함한 트랙과 헤드
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<p><strong>탐색(seek)</strong> 은 읽기 요청을 처리하기 위해 드라이브를 디스크 암을 올바른 트랙 위에 위치시키는 과정니다.
탐색은 여러 단계로 이루어져 있다.</p>

<ol>
  <li>가속 단계: 디스크의 암이 움직이기 시작</li>
  <li>활주 단계: 디스크 암이 최고 속도로 움직이는 단계</li>
  <li>감속 단계: 디스크 암의 속도가 줄어드는 단계</li>
  <li>안정화 단계: 정확한 트랙 위에 위치하는 단계 (<strong>안정화 시간(settling time)</strong> 이 중요, 보통 0.5 ~ 2msec)</li>
</ol>

<h4 id="그-외의-세부사항">그 외의 세부사항</h4>

<figure>
    <a href="/images/study/operating-system/disk-track-skew.png">
        <img src="/images/study/operating-system/disk-track-skew.png" data-rjs="/images/study/operating-system/disk-track-skew.png" class="zooming" alt="트랙 스큐" />
    </a>
    
    <figcaption>
        트랙 스큐
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<ul>
  <li><strong>트랙 비틀림(track skew)</strong>
    <ul>
      <li>트랙의 경계를 지나 순차적으로 존재하는 섹터들을 읽을 수 있는 기술</li>
      <li>트랙으로 넘어갈 때 읽어야 할 블럭을 놓치지 않고 읽을 수 있음</li>
    </ul>
  </li>
  <li><strong>멀티 구역(multi-zoned)</strong>
    <ul>
      <li>디스크 드라이브는 바깥 측 트랙들이 안쪽 트랙들보다 많은 섹터들이 있는 트랙</li>
      <li>여러 구역으로 나뉘어 있으며 한 구역은 연속적으로 존재하는 트랙들의 집합</li>
      <li>각 구역 내의 트랙은 같은 수의 섹터들을 포함하고 있음</li>
    </ul>
  </li>
  <li><strong>캐시(cache)</strong> 또는 <strong>트랙 버퍼(track buffer)</strong>
    <ul>
      <li>일반적으로 8 또는 16MB 정도 크기의 메모리</li>
      <li>드라이브가 디스크에서 읽거나 쓴 데이터를 보관하는 데 사용</li>
    </ul>
  </li>
  <li>쓰기 요청의 완료 보고
    <ul>
      <li>write-back 캐싱(즉시 보고(immediate reporting)): 메모리에 데이터가 기록된 시점에 쓰기가 완료되었다고 보고
        <ul>
          <li>빠르게 보일 수 있지만 위험할 수 있음</li>
        </ul>
      </li>
      <li>write-through: 디스크에 실제로 기록된 시점에 쓰기가 완료되었다고 보고</li>
    </ul>
  </li>
</ul>

<h3 id="374-io-시간-계산">37.4 I/O 시간 계산</h3>

<p>I/O 시간을 나타내는 식</p>

<p>T<sub>I/O</sub> = T<sub>seek</sub> + T<sub>rotation</sub> + T<sub>transfer</sub></p>

<p>I/O 속도(rate, R<sub>I/O</sub>)를 나타내는 식</p>

<p>R<sub>I/O</sub> = Size<sub>Transfer</sub> / T<sub>I/O</sub></p>

<h3 id="375-디스크-스케줄링">37.5 디스크 스케줄링</h3>

<p>운영체제가 디스크에게 I/O 요청을 하면 <strong>디스크 스케줄러</strong>는 다음에 어떤 I/O를 처리할 지 결정한다.<br />
디스크 스케줄링은 요청 작업이 얼마나 길지 예측이 가능하기 때문에 <strong>SFJ(shotest job first, 짧은 작업 우선)</strong> 원칙을 따르려고 한다.</p>

<h4 id="sstf-최단-탐색-시간-우선">SSTF: 최단 탐색 시간 우선</h4>

<p>초기 디스크 스케줄링은 <strong>최단 탐색 시간 우선(shortest seek time first, SSTF)</strong> (또는 <strong>최단 탐색 우선(shortest-seek-first, SSF)</strong> 이라고도 불림) 을 사용했다.<br />
SSTF 는 트랙을 기준으로 I/O 요청 큐를 정렬하여 가까운 트랙의 요청을 먼저 처리한다.</p>

<h6 id="문제점">문제점</h6>
<ul>
  <li>드라이브의 구조는 호스트 운영체제에게 공개되어 있지 않고 운영체제는 블럭들의 배열로 인식하는 문제
    <ul>
      <li>이 문제를 해결하기 위해 운영체제는 SSTF 대신 <strong>가장 가까운 블럭 우선(Nearest-block-first, NBF)</strong> 방식을 사용</li>
    </ul>
  </li>
  <li>기아 현상(starvation)
    <ul>
      <li>다른 트랙에 있는 요청들이 무시될 수 있음</li>
    </ul>
  </li>
</ul>

<h4 id="엘리베이터scan-또는-c-scan-이라고-함">엘리베이터(SCAN 또는 C-SCAN 이라고 함)</h4>

<ul>
  <li><strong>SCAN</strong> 알고리즘
    <ul>
      <li>트랙의 순서에 따라 디스크를 앞뒤로 가로지르며(스위프(sweep)) 요청을 서비스</li>
      <li>가까운 층이 아닌 위, 아래로 이동하는 엘리페이터와 같다하여 엘리페이터 알고리즘</li>
    </ul>
  </li>
  <li><strong>F-SCAN</strong> 알고리즘
    <ul>
      <li>스위프하는 동안에 큐를 동결</li>
      <li>늦게 도착한 요청들의 처리를 지연시켜 요청에 대한 기아 현상을 없앰</li>
    </ul>
  </li>
  <li><strong>C-SCAN</strong> 알고리즘 (Circular SCAN)
    <ul>
      <li>스위프하는 방향이 양 방향이 아닌, 밖에서 안으로만 스위프</li>
    </ul>
  </li>
</ul>

<h5 id="문제점-1">문제점</h5>

<ul>
  <li>SJF 원칙을 지키기 위해 최선을 다하지 않음 (회전 무시)</li>
</ul>

<h4 id="sptf-최단-위치-잡기-우선">SPTF: 최단 위치 잡기 우선</h4>

<p>디스크 회전 비용을 고려하기 위해
<strong>최단 위치 잡기 우선(shortest positioning time first, SPTF)</strong> (또는 <strong>최단 접근 시간 우선(shortest access time first, SATF)</strong>) 을 이용한다.</p>

<p>탐색과 회전에 걸리는 시간이 다르기 때문에 상황에 따라 다음 차례가 달라진다.<br />
SPTF가 유용하고 성능을 개선할 수 있다. <br />
하지만 운영체제가 트랙의 경계 또는 디스크 헤드가 어디있는지 알 수 없기 때문에 드라이브 내부에서 실행된다.</p>

<h4 id="다른-스케줄링-쟁점들">다른 스케줄링 쟁점들</h4>

<ul>
  <li>디스크는 상세한 트랙 배치 정보와 헤드의 위치 정보로 최선의 순서(SPTF)로 정렬</li>
  <li><strong>I/O 병합(I/O merging)</strong>
    <ul>
      <li>디스크로 내려보내는 요청의 개수를 줄여 오버헤드 감소</li>
    </ul>
  </li>
  <li><strong>작업 보전(work-conserving)</strong>
    <ul>
      <li>디스크가 유휴 상태가 되지 않도록 함</li>
    </ul>
  </li>
  <li><strong>작업 비보전(non-work-conserving)</strong>
    <ul>
      <li><strong>예측 디스크 스케줄링(anticipatory disk scheduling)</strong> 으로 잠시 기다리는 것이 더 좋을 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="38장-redundant-array-of-inexpensive-disks-raid">38장. Redundant Array of Inexpensive Disks (RAID)</h2>

<p><strong>Redundant Array of Inexpensive Disks</strong> 또는 RAID 로 알려진 기술에 대해 알아본다.<br />
이 기술은 고속이면서 대용량의 디스크 시스템을 만든다.</p>

<p>RAID 는 하나의 디스크처럼 보이지만 내부에는 여러 개의 디스크와 메모리, 시스템을 관리하기 위한 프로세서들로 이루어져있다.<br />
RAID 하드웨어는 컴퓨터 시스템과 유사하며 디스크의 그룹을 관리하기 위한 시스템이다.</p>

<h3 id="장점">장점</h3>

<p>RAID 는 장점들을 투명하게 제공하여 확산력(deployability)을 개선 시켰다.<br />
사용자와 관리자가 소프트웨어 호환성을 걱정하지 않고 사용할 수 있다.</p>

<ul>
  <li>성능
    <ul>
      <li>디스크 여러 개를 병렬적으로 사용하여 I/O 시간 개선</li>
    </ul>
  </li>
  <li>용량
    <ul>
      <li>많은 디스크 공간으로 데이터 양이 많음</li>
    </ul>
  </li>
  <li>신뢰성
    <ul>
      <li><strong>데이터 중복 기술(redundancy)</strong> 으로 디스크 한 개의 고장 감내 가능</li>
    </ul>
  </li>
</ul>

<h3 id="381-인터페이스와-raid-의-내부">38.1 인터페이스와 RAID 의 내부</h3>

<p>RAID 도 선형적인 블럭들의 배열로 보이며 파일 시스템이 각 블럭을 읽거나 쓸 수 있다.<br />
파일 시스템이 논리적 I/O 요청을 하면 내부에서 요청 가능한 디스크를 계산하고 물리적으로 I/O 를 발생시킨다. (2개의 복사본을 유지한다면 두 번 물리적 I/O 실행)</p>

<h3 id="382-결함-모델">38.2 결함 모델</h3>

<p>RAID 는 특정 종류의 결함을 파악하고 복구하도록 설계되었다.</p>

<ul>
  <li><strong>고장시 멈춤(fail-stop)</strong> 결함 모델
    <ul>
      <li>“정상 작동” 이거나 “멈춤” 상태로 있다고 가정</li>
      <li>동작 중인 디스크에 모든 블럭을 읽거나 쓸 수 있음</li>
      <li>멈춤 상태의 디스크는 완전히 사용 불가능</li>
      <li>디스크가 고장나면 쉽게 파악할 수 있다고 가정한다는 것이 단점</li>
    </ul>
  </li>
</ul>

<h3 id="383-raid-의-평가-방법">38.3 RAID 의 평가 방법</h3>

<ul>
  <li>용량
    <ul>
      <li>클라이언트가 사용할 수 있는 유효 용량 평가</li>
      <li>중복 저장이 없다면 N*B</li>
      <li>두 개의 복사본을 갖는다면 (N*B)/2</li>
    </ul>
  </li>
  <li>신뢰성
    <ul>
      <li>몇 개의 디스크 결함을 감내할 수 있는지 평가</li>
    </ul>
  </li>
  <li>성능
    <ul>
      <li>워크로드에 따라 크게 달라지기 때문에 평가가 어려움</li>
    </ul>
  </li>
</ul>

<h3 id="384-raid-레벨-0-스트라이핑">38.4 RAID 레벨 0: 스트라이핑</h3>

<p>RAID 레벨 0 또는 <strong>스트라이핑(striping)</strong> 방식은 성능과 용량에 대한 훌륭한 상한 기준을 나타낸다.<br />
이 방식은 블럭들을 여러 디스크에 걸쳐 줄을 긋는 것 처럼 저장한다. (중복 저장을 하지 않음)</p>

<p>디스크 배열의 블럭들을 라운드 로빈 방식으로 디스크를 가로질러 펼친다.<br />
연속적인 청크에 대해 요청을 받았을 때 병렬성을 가장 잘 활용하도록 설계되었다.<br />
같은 행에 있는 블럭들은 <strong>스트라이프(stripe)</strong> 라고 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">디스크0</th>
      <th style="text-align: center">디스크1</th>
      <th style="text-align: center">디스크2</th>
      <th style="text-align: center">디스크3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">7</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">10</td>
      <td style="text-align: center">11</td>
    </tr>
    <tr>
      <td style="text-align: center">12</td>
      <td style="text-align: center">13</td>
      <td style="text-align: center">14</td>
      <td style="text-align: center">15</td>
    </tr>
  </tbody>
</table>

<h4 id="청크-크기">청크 크기</h4>

<p>청크 크기는 RAID 성능에 영향을 준다.</p>

<ul>
  <li>작은 청크 크기
    <ul>
      <li>많은 파일들이 여러 디스크에 걸쳐 스트라이프 되어 병렬성이 증가</li>
      <li>여러 디스크에서 찾아 블럭 위치를 찾아야 하므로 찾는데 오래 걸림</li>
    </ul>
  </li>
  <li>큰 청크 크기
    <ul>
      <li>병렬성이 감소되어 처리 성능을 높이기 위해서는 여러 요청을 병행하게 실행해야 함</li>
      <li>위치 찾는 시간 감소</li>
    </ul>
  </li>
</ul>

<h4 id="raid-0-분석으로-돌아가서">RAID-0 분석으로 돌아가서</h4>

<ul>
  <li>유효 용량
    <ul>
      <li>B 개의 블럭을 갖는 N개의 디스크라면 N*B 만큼의 유효 용량</li>
    </ul>
  </li>
  <li>신뢰성
    <ul>
      <li>어느 디스크라도 고장나면 전체 디스크 손실</li>
    </ul>
  </li>
  <li>성능
    <ul>
      <li>병렬로 사용자 I/O 요청 처리가 가능</li>
    </ul>
  </li>
</ul>

<h4 id="raid-0-의-성능">RAID-0 의 성능</h4>

<ul>
  <li>단일 요청의 지연시간
    <ul>
      <li>한 블럭과 디스크에 대한 요청의 지연 시간은 거의 동일</li>
    </ul>
  </li>
  <li>RAID 의 정상 상태(steady state) 에서의 처리 성능(throughput)
    <ul>
      <li>최대 대역폭 기대 가능</li>
      <li>처리성능은 N(디스크 수) * S(디스크 하나의 순차 접근 대역폭) 와 같음</li>
    </ul>
  </li>
</ul>

<h3 id="385-raid-레벨-1-미러링">38.5 RAID 레벨 1: 미러링</h3>

<p>첫 번째 RAID 레벨은 RAID 레벨 1 또는 미러링으로 불린다.<br />
각 블럭에 대해 하나 이상의 사본을 둬서 디스크 고장에 대처한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">디스크0</th>
      <th style="text-align: center">디스크1</th>
      <th style="text-align: center">디스크2</th>
      <th style="text-align: center">디스크3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">7</td>
      <td style="text-align: center">7</td>
    </tr>
  </tbody>
</table>

<p>이 방식은 일반적으로 미러링(RAID-1)을 스트라이핑(RAID-0) 하기 때문에 RAID-10 또는 RAID 1+0 이라고 한다.</p>

<h4 id="raid-1-분석">RAID-1 분석</h4>

<ul>
  <li>용량
    <ul>
      <li>비용이 많이 듦</li>
      <li>미러링 레벨이 2라면 최대 사용 가능한 용량의 반만 사용 가능 (N*B)/2</li>
    </ul>
  </li>
  <li>신뢰성
    <ul>
      <li>디스크 중 고장이 발생해도 감내 가능</li>
    </ul>
  </li>
  <li>성능
    <ul>
      <li>단일 읽기는 단일 디스크에서 읽는 요청의 지연 시간과 동일</li>
      <li>쓰기의 경우 병렬적으로 이루어지지만, 물리적으로 두 개의 쓰기가 연산되어야 하므로 최악의 탐색과 회전 지연시간에 의해 결정</li>
    </ul>
  </li>
  <li>처리 성능
    <ul>
      <li>순차 쓰기의 경우 N/2 * S 또는 최대 대역폭의 절반의 대역폭</li>
      <li>순차 읽기 상황도 N/2 * S 으로 동일</li>
    </ul>
  </li>
</ul>

<h4 id="386-raid-레벨-4-패리티를-이용한-공간-절약">38.6 RAID 레벨 4: 패리티를 이용한 공간 절약</h4>

<p>패리티 기반의 접근 방법은 저장 공간을 적게 사용하여 미러링 기반 시스템의 공간 낭비를 극복하고자 한다.<br />
하지만 성능 저하가 발생될 수 있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">디스크0</th>
      <th style="text-align: center">디스크1</th>
      <th style="text-align: center">디스크2</th>
      <th style="text-align: center">디스크3</th>
      <th style="text-align: center">디스크4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">P0</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">7</td>
      <td style="text-align: center">P1</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">10</td>
      <td style="text-align: center">11</td>
      <td style="text-align: center">P2</td>
    </tr>
    <tr>
      <td style="text-align: center">12</td>
      <td style="text-align: center">13</td>
      <td style="text-align: center">14</td>
      <td style="text-align: center">15</td>
      <td style="text-align: center">P3</td>
    </tr>
  </tbody>
</table>

<p>스트라이프마다 중복 정보를 담고 있는 패리티 블럭을 추가한다.
블럭 P1 은 블럭 4,5,6 과 7번으로부터 계산된 중복 정보를 가지고 있다.<br />
고장난 디스크로부터 데이터를 복구하기 위해서는 스 행의 모든 값을 읽은 후 패리티를 통해 올바른 값을 <strong>다시 계산</strong> 한다.</p>

<h4 id="raid-4-분석">RAID-4 분석</h4>

<ul>
  <li>용량
    <ul>
      <li>디스크 하나를 패리티 정보 저장에 사용하기 때문에 (N-1)*B</li>
    </ul>
  </li>
  <li>신뢰성
    <ul>
      <li>하나만의 디스크 고장 감내 가능</li>
      <li>두 개 이상의 고장은 복원 불가능</li>
    </ul>
  </li>
  <li>성능
    <ul>
      <li>순차 읽기의 경우 최대 유효한 대역폭은 (N-1)*S MB/s</li>
      <li>순차 쓰기의 경우 스프라이프 전부 쓰기가 가장 효율적인 방법이므로 (N-1)*S MB/s</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h5 id="특정-블럭과-함께-패리티-블럭을-갱신하는-정확하고-효율적인-두-가지-방법">특정 블럭과 함께 패리티 블럭을 갱신하는 정확하고 효율적인 두 가지 방법</h5>

<ul>
  <li><strong>가산적 패리티(additive parity)</strong>
    <ul>
      <li>스트라이프 내의 다른 모든 블록을 병렬로 읽고 새로운 블럭과 함께 갱신</li>
      <li>디스크의 개수에 따라 계산의 양이 다르기 때문에 많은 수의 읽기 연산이 필요해질 수 있음</li>
    </ul>
  </li>
  <li><strong>감산적 패리티(subtractive parity)</strong>
    <ul>
      <li>갱신 하고자 하는 블록과 패리티 값을 읽음 (동일하면 그대로 유지)</li>
      <li>이전의 패리티 비트를 현재 상태의 반대 값으로 뒤집어서 처리</li>
      <li>P<sub>new</sub> = (C<sub>old</sub> ⊕ C<sub>new</sub>) ⊕ P<sub>old</sub></li>
    </ul>
  </li>
</ul>

<h5 id="문제점-2">문제점</h5>

<ul>
  <li><strong>small-write 문제</strong>
    <ul>
      <li>쓰기가 동시에 요청되면 패리티 디스크는 병목으로 작용</li>
      <li>패리티 디스크로 인해 순차적으로 실행되어야 함</li>
    </ul>
  </li>
</ul>

<h3 id="387-raid-레벨-5-순환-패리티">38.7 RAID 레벨 5: 순환 패리티</h3>

<p>RAID-5 는 RAID-4 와 거의 동일하게 동작하지만 패리티 블럭을 <strong>순환(rotate)</strong> 하여 small-write 문제를 해결한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">디스크0</th>
      <th style="text-align: center">디스크1</th>
      <th style="text-align: center">디스크2</th>
      <th style="text-align: center">디스크3</th>
      <th style="text-align: center">디스크4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">P0</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">7</td>
      <td style="text-align: center">P1</td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: center">11</td>
      <td style="text-align: center">P2</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">9</td>
    </tr>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">P3</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">13</td>
      <td style="text-align: center">14</td>
    </tr>
    <tr>
      <td style="text-align: center">P4</td>
      <td style="text-align: center">16</td>
      <td style="text-align: center">17</td>
      <td style="text-align: center">18</td>
      <td style="text-align: center">P9</td>
    </tr>
  </tbody>
</table>

<h4 id="raid-5-분석">RAID-5 분석</h4>

<p>많은 부분은 RAID-4와 동일하다.<br />
모든 디스크를 활용할 수 있기 때문에 랜덤 읽기 성능이 약간 더 좋다.<br />
RAID-5 성능이 거의 RAID-4와 동일하기 때문에 RAID-5로 완전히 대체되었다.</p>

<h3 id="385-raid-비교-정리">38.5 RAID 비교: 정리</h3>

<p>성능만을 원하고 신뢰성을 고려하지 않는다면 스트라이핑<br />
임의 I/O 성능과 신뢰성을 원한다면 미러링<br />
순차 I/O 만 사용하거나 용량과 신뢰성이 목적이라면 RAID-5</p>

<h3 id="389-raid-와-관련된-다른-흥미로운-주제들">38.9 RAID 와 관련된 다른 흥미로운 주제들</h3>

<ul>
  <li>디스크가 고장났을 때 <strong>대체용 스페어(hot spare)</strong> 로 고장난 디스크를 대신하는 방법도 있음</li>
  <li>잠재된 섹터 오류(latent sector error) 또는 블럭 훼손(block corruption) 을 고려한 모델들도 있음</li>
  <li>소프트웨어 레이어로 RAID(<strong>소프트웨어 RAID</strong>) 구성도 가능.
    <ul>
      <li>저렴하지만 일관성-유지 등의 문제 발생</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="39장-막간-파일과-디렉터리">39장. 막간: 파일과 디렉터리</h2>

<p>이번 장에서는 <strong>하드 디스크 드라이브</strong> 또는 <strong>솔리드 스테이트 드라이브(Solid-state storage, SSD)</strong> 와 같은 <strong>영속 저장 장치(persistent storage)</strong> 개념을 다룬다.<br />
영속 보존 장치는 전원 공급이 차단되어도 데이터를 그대로 보존한다.</p>

<h3 id="391-파일과-디렉터리">39.1 파일과 디렉터리</h3>

<h4 id="파일">파일</h4>

<ul>
  <li>읽거나 쓸 수 있는 순차적인 바이트의 배열</li>
  <li>각 파일은 <strong>저수준 이름(low-level name)</strong> 을 가지고 있음</li>
  <li>저수준 이름을 <strong>아이노드 번호(inode number)</strong>  라고 함</li>
  <li>각 파일은 아이노드 번호와 연결되어 있음</li>
  <li>운영 체제는 파일의 구조를 모르고 파일 시스템이 데이터를 디스크에 저장하고 돌려주는 역할을 함</li>
  <li>파일의 종류를 나타내는 확장자는 <strong>관용적(convention)</strong> 일뿐 반드시 지킬 필요는 없음</li>
</ul>

<h4 id="디렉터리">디렉터리</h4>

<ul>
  <li>파일와 마찬가지로 저수준의 이름(아이노 번호드)를 가짐</li>
  <li>&lt;사용자가 읽을 수 있는 이름, 저수준의 이름&gt; 쌍으로 이루어진 목록을 가짐
    <ul>
      <li>각 항목은 파일 또는 다른 디렉터리를 가리킴</li>
    </ul>
  </li>
  <li>디렉터리내에 디렉터리를 포함하여, <strong>디렉터리 트리(directory tree</strong>, 또는 <strong>디렉터리 계층(directory hierarchy)</strong>) 구성</li>
  <li>디렉터리 계층은 <strong>루트 디렉터리(root directory)</strong> 부터 시작</li>
  <li><strong>구분자(separator)</strong> 를 사용하여 <strong>하위 디렉터리</strong> 명시</li>
</ul>

<figure>
    <a href="/images/study/operating-system/directory-tree.png">
        <img src="/images/study/operating-system/directory-tree.png" data-rjs="/images/study/operating-system/directory-tree.png" class="zooming" alt="디렉터리 트리의 예제" />
    </a>
    
    <figcaption>
        디렉터리 트리의 예제
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<h3 id="392-파일-시스템-인터페이스">39.2 파일 시스템 인터페이스</h3>

<p>파일의 생성, 접근, 삭제 등의 인터페이스를 다뤄본다.</p>

<h3 id="393-파일의-생성">39.3 파일의 생성</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="n">O_CREATE</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">open</code> 시스템 콜로 파일 생성할 수 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">O_CREATE</code>: 파일이 없으면 생성</li>
  <li><code class="language-plaintext highlighter-rouge">O_WRONLY</code>: 쓰기 전용</li>
  <li><code class="language-plaintext highlighter-rouge">O_TRUNC</code>: 파일의 크기를 0byte 줄여서 내용 삭제</li>
  <li><code class="language-plaintext highlighter-rouge">S_IRUSR | S_IWUSR</code>: 소유자만 읽기, 쓰기 권한 설정</li>
  <li><strong>파일 디스크립터(file descriptor)</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">open()</code> 의 반환 값</li>
      <li>프로세스마다 존재하는 정수로 파일을 접근하는 데 사용 (권한 필요)</li>
      <li><code class="language-plaintext highlighter-rouge">read()</code>, <code class="language-plaintext highlighter-rouge">write()</code> 등의 메소드로 파일 접근 가능</li>
    </ul>
  </li>
</ul>

<h3 id="394-파일의-읽기와-쓰기">39.4 파일의 읽기와 쓰기</h3>

<p>프로그램이 호출하는 시스템 콜을 추적하는 Linux 의 <code class="language-plaintext highlighter-rouge">strace</code> 를 통해 <code class="language-plaintext highlighter-rouge">cat</code> 동작을 살펴본다.</p>

<ol>
  <li>파일을 읽기 전용으로 열기 (표준 입력(0), 출력(1), 에러 파일(2) 디스크립터가 열기기 때문에 반환값이 3)</li>
  <li><code class="language-plaintext highlighter-rouge">read()</code> 시스템 콜로 파일에서 반복적으로 읽음</li>
  <li><code class="language-plaintext highlighter-rouge">write()</code> 시스템 콜에서 표준 출력(STDOUT) 하기 위해 파일 디스크립터 1 사용 (화면 출력)</li>
  <li>파일 내용을 더 읽으려고 시도 (남은 바이트가 없어서 0 반환)</li>
  <li><code class="language-plaintext highlighter-rouge">close()</code> 로 파일 할 일 끝남</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prompt&gt; strace <span class="nb">cat </span>foo
...
open<span class="o">(</span><span class="s2">"foo"</span>, O_RDONLY | O_LARGEFILE<span class="o">)</span> <span class="o">=</span> 3
<span class="nb">read</span><span class="o">(</span>3, <span class="s2">"hello</span><span class="se">\n</span><span class="s2">"</span>, 4096<span class="o">)</span> <span class="o">=</span> 6
write<span class="o">(</span>1, <span class="s2">"hello</span><span class="se">\n</span><span class="s2">"</span>, 6<span class="o">)</span> <span class="o">=</span> 6
hello
<span class="nb">read</span><span class="o">(</span>3, <span class="s2">""</span>, 4096<span class="o">)</span> <span class="o">=</span> 0
close<span class="o">(</span>3<span class="o">)</span> <span class="o">=</span> 0
...
</code></pre></div></div>

<h3 id="395-비-순차적-읽기와-쓰기">39.5 비 순차적 읽기와 쓰기</h3>

<p>파일의 임의의 오프셋부터 읽거나 써야 할 때가 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">off_t</span> <span class="nf">lseek</span><span class="p">(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fildes</code>: 파일 디스크립터</li>
  <li><code class="language-plaintext highlighter-rouge">offset</code>: 오프셋</li>
  <li><code class="language-plaintext highlighter-rouge">whence</code>: 탐색 방식 결정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SEEK_SET</code>: 오프셋은 offset 바이트로 설정</li>
      <li><code class="language-plaintext highlighter-rouge">SEEK_CUR</code>: 현재 위치에 offset 바이트를 더한 값으로 설정</li>
      <li><code class="language-plaintext highlighter-rouge">SEEK_END</code>: 파일의 크기에 offset 바이트를 더한 값으로 설정</li>
    </ul>
  </li>
</ul>

<h3 id="396-공유하는-파일-테이블의-요소들-fork-와-dup">39.6 공유하는 파일 테이블의 요소들: fork() 와 dup()</h3>

<p>각 프로세스는 개별적인 열린 파일 테이블의 요소를 다룬다.<br />
같은 파일에 대한 논리적 읽기와 쓰기는 독립적이며 개별적인 현재 오프셋을 관리한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fork()</code>
    <ul>
      <li>부모 프로세스가 <code class="language-plaintext highlighter-rouge">fork()</code> 으로 자식 프로세스를 생성하면 파일 테이블은 공유</li>
      <li>파일 테이블의 요소가 공유되면 <strong>참조 횟수(reference count)</strong> 가 증가</li>
      <li>부모 자식 프로세스가 모두 종료되어야 요소들 제거</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">dup()</code>
    <ul>
      <li>이미 열려있는 파일의 디스크립터를 참조하는 새로운 파일 디스크립터 생성</li>
      <li>유닉스 쉘과 출력 재지향하는 경우에 유용</li>
    </ul>
  </li>
</ul>

<h3 id="397-fsync-를-이용한-즉시-기록">39.7 fsync() 를 이용한 즉시 기록</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">write()</code>
    <ul>
      <li>영속 저장 장치에 기록 해달라고 파일 시스템에 요청</li>
      <li>파일 시스템에서 성능을 위해 메모리에 모은 후 (버퍼링) 처리</li>
      <li>데이터가 유실되는 경우가 발생</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fsync()</code>
    <ul>
      <li>파일 시스템이 지정된 파일의 <strong>더티(갱신된)</strong> 데이터를 디스크에 강제로 기록</li>
      <li>쓰기들이 처리되면 리턴</li>
    </ul>
  </li>
</ul>

<h3 id="398-파일-이름-생성">39.8 파일 이름 생성</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rename</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>
</code></pre></div></div>

<p>시스템 크래시에 대해 <strong>원자적</strong> 으로 구현되어 있음 (중간 상태가 없음)</p>

<h3 id="399-파일-정보-추출">39.9 파일 정보 추출</h3>

<p>파일에 대한 정보를 <strong>메타데이터(metadata)</strong> 라고 한다.
메타데이터를 보려면 <code class="language-plaintext highlighter-rouge">stat()</code> 이나 <code class="language-plaintext highlighter-rouge">fstat()</code> 를 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
    <span class="n">dev_t</span> <span class="n">st_dev</span><span class="p">;</span> <span class="c1">// 파일이 있는 장치의 ID</span>
    <span class="n">ino_t</span> <span class="n">st_ino</span><span class="p">;</span> <span class="c1">// 아이노드 번호</span>
    <span class="n">mode_t</span> <span class="n">st_mode</span><span class="p">;</span> <span class="c1">// 보호</span>
    <span class="n">nlink_t</span> <span class="n">st_nlink</span><span class="p">;</span> <span class="c1">// 하드링크 수</span>
    <span class="n">uid_t</span> <span class="n">st_uid</span><span class="p">;</span> <span class="c1">// 소유자의 사용자 ID</span>
    <span class="n">gid_t</span> <span class="n">st_gid</span><span class="p">;</span> <span class="c1">// 소유자의 그룹 ID</span>
    <span class="n">dev_t</span> <span class="n">st_rdev</span><span class="p">;</span> <span class="c1">// 장치 ID (특수 파일인 경우)</span>
    <span class="kt">off_t</span> <span class="n">st_size</span><span class="p">;</span> <span class="c1">// 파일 크기 (바이트)</span>
    <span class="n">blksize_t</span> <span class="n">st_blksize</span><span class="p">;</span> <span class="c1">// 파일 시스템 입출력의 블록 크기</span>
    <span class="n">blkcnt_t</span> <span class="n">st_blocks</span><span class="p">;</span> <span class="c1">// 할당된 블록 수</span>
    <span class="kt">time_t</span> <span class="n">st_atime</span><span class="p">;</span> <span class="c1">// 최종 접근 시간</span>
    <span class="kt">time_t</span> <span class="n">st_mtime</span><span class="p">;</span> <span class="c1">// 최종 갱신 시간</span>
    <span class="kt">time_t</span> <span class="n">st_ctime</span><span class="p">;</span> <span class="c1">// 최종 상태 변경 시간</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3910-파일-삭제">39.10 파일 삭제</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prompt&gt; strace <span class="nb">rm </span>foo
...
<span class="nb">unlink</span><span class="o">(</span><span class="s2">"foo"</span><span class="o">)</span> <span class="o">=</span> 0
...
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">unlink()</code> 시스템 콜에서는 파일 이름을 인자로 받아서 성공하면 0 리턴</p>

<h3 id="3911-디렉터리-생성">39.11 디렉터리 생성</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prompt</span><span class="o">&gt;</span> <span class="n">strace</span> <span class="n">mkdir</span> <span class="n">foo</span>
<span class="p">...</span>
<span class="n">mkdir</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="mo">0777</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">...</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mkdir()</code> 시스템 콜로 디렉터리 생성한다.
디렉터리에는 자신을 나타내는 “.”(dot) 디렉터리, 부모 디렉터리를 가리키는 “..”(dot-dot) 디렉터리가 있다.</p>

<h3 id="3912-디렉터리-읽기">39.12 디렉터리 읽기</h3>

<p>디렉터리를 읽는 것은 <code class="language-plaintext highlighter-rouge">ls</code> 프로그램이다.<br />
이 프로그램은 <code class="language-plaintext highlighter-rouge">opendir()</code>, <code class="language-plaintext highlighter-rouge">readdir()</code>, <code class="language-plaintext highlighter-rouge">closedir()</code> 시스템콜을 사용한다.<br />
반복문으로 디렉터리 항목을 읽고 이름과 아이노드 번호를 출력한다.</p>

<p><code class="language-plaintext highlighter-rouge">ls</code> 에 <code class="language-plaintext highlighter-rouge">-l</code> 플래그를 추가하면 파일 크기 같은 추가 정보를 얻기 위해 <code class="language-plaintext highlighter-rouge">stat()</code> 을 호출한다.</p>

<h3 id="3913-디렉터리-삭제하기">39.13 디렉터리 삭제하기</h3>

<p><code class="language-plaintext highlighter-rouge">rmdir()</code> 시스템 콜로 디렉터리를 삭제한다.<br />
비어있지 않은 디렉터리에 대해 호출하면 실패한다.</p>

<h3 id="3914-하드-링크">39.14 하드 링크</h3>

<p><code class="language-plaintext highlighter-rouge">link()</code> 시스템 콜은 원래의 경로명과 새로운 경로명을 인자로 받는다.<br />
원래 파일 이름에 새로운 이름을 link 하면 동일한 파일을 접근할 수 있는 새로운 방법을 만든다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prompt&gt; <span class="nb">echo </span>hello <span class="o">&gt;</span> file
prompt&gt; <span class="nb">cat </span>file
hello
prompt&gt; <span class="nb">ln </span>file file2
prompt&gt; <span class="nb">cat </span>file2
hello
</code></pre></div></div>

<p>위와 같이 하드 링크를 생성하면 <code class="language-plaintext highlighter-rouge">file</code> 또는 <code class="language-plaintext highlighter-rouge">file2</code> 으로 읽을 수 있다.
<code class="language-plaintext highlighter-rouge">link()</code> 는 새롭게 링크하려는 이름 항목을 디렉터리에 생성하고, 원래 파일과 같은 아이노드 번호를 가리킨다. (복사되지 않음)
여기서 <code class="language-plaintext highlighter-rouge">unlink()</code> 로 한 파일을 삭제해도 다른 이름으로 파일 접근이 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">unlink()</code> 는 아이노드 번호의 <strong>참조 횟수(reference count)</strong> 를 검사하고 참조 횟수를 줄이는데,  <br />
참조 횟수가 0 되면 파일 시스템은 데이터 블럭을 해제하여 파일을 진정으로 삭제한다.</p>

<h3 id="3915-심볼릭-링크">39.15 심볼릭 링크</h3>

<p>하드 링크는 디렉터리에 대해 사용 불가, 다른 디스크 파티션에 있는 파일 링크 불가 등의 제한이 있다.<br />
<strong>심볼릭 링크(symbolic link)</strong> 또는 <strong>소프트 링크(soft link)</strong> 는 이런 경우 유용하게 사용할 수 있는 링크다.<br />
심볼릭 링크를 생성하기 위해서는 <code class="language-plaintext highlighter-rouge">ln</code> 프로그램에 <code class="language-plaintext highlighter-rouge">-s</code> 플래그를 추가하면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prompt&gt; <span class="nb">echo </span>hello <span class="o">&gt;</span> file
prompt&gt; <span class="nb">ln</span> <span class="nt">-s</span> file file2
prompt&gt; <span class="nb">cat </span>file2
hello

prompt&gt; <span class="nb">ls</span> <span class="nt">-al</span>
drwxr-x---  2 remzi remzi   29 May 3 19:10 ./
drwxr-x--- 27 remzi remzi 4096 May 3 19:10 ../
<span class="nt">-rw-r-----</span>  1 remzi remzi    6 May 3 19:10 file
lrwxr-x---  1 remzi remzi    4 May 3 19:10 file2 -&gt; file
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">file</code>과 <code class="language-plaintext highlighter-rouge">file2</code> 모두 접근이 가능하다.  <br />
하드 링크와 유사해보이지만 다음과 같은 차이가 있다.</p>

<ul>
  <li>심볼릭 링크는 다른 형식의 독립된 파일 (파일, 디렉터리와 다름)
    <ul>
      <li>소프트 링크 가장 왼쪽에 <code class="language-plaintext highlighter-rouge">l</code> 이 표시</li>
      <li>링크한 대상의 파일이 보임</li>
    </ul>
  </li>
  <li>심볼릭 링크의 크기는 파일의 경로명 길이</li>
  <li>원래 파일을 삭제하면 심볼릭 링크가 가리키는 실제 파일도 삭제됨</li>
</ul>

<h3 id="3916-권한-비트와-접근-제어-목록">39.16 권한 비트와 접근 제어 목록</h3>

<p>파일 시스템은 디스크에 대한 가상화를 제공하여 디스크상의 블럭들을 파일과 디렉터리로 변환한다.<br />
하지만 파일은 다수의 사용나자 프로세스들이 공유하므로 파일 시스템은 공유범위를 한정하는 기법들도 제공한다.</p>

<h4 id="권한-비트permisision-bits">권한 비트(permisision bits)</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prompt&gt; <span class="nb">ls</span> <span class="nt">-l</span> foo.txt
<span class="nt">-rw-r--r--</span> 1 remzi remzi 0 May 3 19:10 foo.txt
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-rw-r--r--</code> 은 에서 첫 번째 글자는 파일의 종류를 의미한다.  <br />
<code class="language-plaintext highlighter-rouge">-</code> 일반 파일, <code class="language-plaintext highlighter-rouge">d</code> 디렉터리, <code class="language-plaintext highlighter-rouge">l</code> 심볼릭 링크를 나타낸다.</p>

<p>그 이후의 아홉 개 글자는 <strong>소유자(owner)</strong>, <strong>그룹(group)</strong>, <strong>나머지 사용자(other)</strong> 으로 세 개의 그룹으로 나누어진 권한을 의미한다.<br />
이 그룹들이 할 수 있는 일은 읽기(r), 쓰기(w), 실행하기(x) 다.</p>

<p><strong>파일 모드(file moe)</strong> 를 변경하는 <code class="language-plaintext highlighter-rouge">chomod</code> 명령으로 권한의 설정을 변경할 수 있다.</p>

<h4 id="접근-제어-목록access-control-list">접근 제어 목록(access control list)</h4>

<p>AFS와 같은 분산 파일 시스템을 포함하는 다른 파일 시스템의 경우 디렉터리마다 <strong>접근 제어 목록(access control list, ACL)</strong> 을 가지고 있다.<br />
접근 제어 목록은 누가 특정 자원을 접근할 수 있는지 명확하게 표현한다.</p>

<h3 id="3917-파일-시스템-생성과-마운트">39.17 파일 시스템 생성과 마운트</h3>

<p>다수의 파일 시스템 파티션들이 존재할 때는 마운트를 통해 단일 디렉터리 트리 구성이 가능하다.</p>

<p>많은 파일 시스템에서 <code class="language-plaintext highlighter-rouge">mkfs</code> 로 파일 시스템을 생성할 수 있다.<br />
이 새로운 파일 시스템을 루트 디렉터리에서 시작하는 기존의 디렉터리 구성으로 접근할 수 있도록 하는 작업을 마운트라고 한다.</p>

<p><code class="language-plaintext highlighter-rouge">mount</code> 프로그램으로 기존의 디렉터리 중 하나를 <strong>마운트 지점(mount point)</strong> 으로 지정하여 새로운 파일 시스템을 붙여 넣는다.</p>

<p><br /></p>

<h2 id="40장-파일-시스템-구현">40장. 파일 시스템 구현</h2>

<p>이번 장에서 <strong>vsfs(Very Simple File System)</strong> 라는 간단한 파일 시스템에 대해 알아본다.</p>

<h3 id="401-생각하는-방법">40.1 생각하는 방법</h3>

<p>파일 시스템의 두 가지 측면에 대해 알아본다.</p>

<ul>
  <li><strong>자료 구조</strong>
    <ul>
      <li>간단한 파일 시스템은 블럭과 다른 객체들을 배열과 같은 간단한 자료 구조</li>
      <li>다른 파일 시스템은 복잡한 트리 기반의 자료 구조</li>
    </ul>
  </li>
  <li><strong>접근 방법(access method)</strong>
    <ul>
      <li>프로세스가 호출하는 <code class="language-plaintext highlighter-rouge">open()</code>, <code class="language-plaintext highlighter-rouge">read()</code>, <code class="language-plaintext highlighter-rouge">write()</code> 등의 시스템콜을 실핼할 때 어떻게 동작하는지</li>
    </ul>
  </li>
</ul>

<h3 id="402-전체-구성">40.2 전체 구성</h3>

<figure>
    <a href="/images/study/operating-system/file-system-data-structure">
        <img src="/images/study/operating-system/file-system-data-structure" data-rjs="/images/study/operating-system/file-system-data-structure" class="zooming" alt="파일 시스템의 자료구조" />
    </a>
    
    <figcaption>
        파일 시스템의 자료구조
        
        (출처: 운영체제 아주 쉬운 세가지 이야기)
        
    </figcaption>
    
</figure>

<p>vsfs 파일 시스템의 자료 구조에 대해 디스크를 <strong>블럭(block)</strong> 들로 나누어 알아본다.
4KB 블럭이 64개 나열된 작은 디스크를 가정한다.</p>

<ul>
  <li><strong>데이터 영역(data region)</strong>
    <ul>
      <li>사용자 데이터가 있는 디스크 공간</li>
      <li>데이터 블럭(D)</li>
    </ul>
  </li>
  <li><strong>아이노드(inode)</strong>
    <ul>
      <li>파일에 대한 <strong>메타데이터(metadata)</strong></li>
      <li>파일 크기, 소유자, 접근 권한, 접근과 변경 시간 등과 같은 정</li>
      <li>아이노드 블럭(I)</li>
    </ul>
  </li>
  <li><strong>아이노드 테이블(inode table)</strong>
    <ul>
      <li>아이노드들의 저장을 위한 디스크 공간</li>
      <li>아이노드들이 배열형태로 저장</li>
    </ul>
  </li>
  <li><strong>슈퍼블럭(superblock)</strong>
    <ul>
      <li>파일 시스템 전체에 대한 정보 (아이노드와 데이터 블럭 개수, 아이노드 테이블 시작 위치 등)</li>
    </ul>
  </li>
</ul>

<p>각 블럭이 현재 사용 중인지 아닌지는 <strong>할당 구조(allocation structure)</strong> 로 표현해야 한다.
사용 여부를 표현하는 데에는 다양한 방법이 존재한다.</p>

<ul>
  <li><strong>프리 리스트(free list)</strong>
    <ul>
      <li>사용 중이 아닌 블럭들을 링크드 리스트 형태로 관리</li>
    </ul>
  </li>
  <li><strong>비트맵(bitmap)</strong>
    <ul>
      <li><strong>데이터 비트맵(data bitmap)</strong>: 데이터 영역에 있는 블럭들의 사용여부 표시 (d)</li>
      <li><strong>아이노드 비트맵(inode bitmap)</strong>: 아이노드 테이블에 있는 아이노드들의 사용여부 표시 (i)</li>
    </ul>
  </li>
</ul>

<h3 id="403-파일-구성-아이노드">40.3 파일 구성: 아이노드</h3>

<p><strong>아이노드(inode)</strong> 는 <strong>인덱스 노드(index node)</strong> 의 줄임말로 디스크 자료 구조 중 가장 중요하다.<br />
각 아이노드는 <strong>아이-넘버(i-number)</strong> 라는 숫자로 표현되는데 이를 <strong>저수준 이름(low-level name)</strong> 이라고 한다.</p>

<p>아이노드에는 파일의 종류, 크기, 할당된 블럭 수, 보호 정보, 시간 정보, 데이터 블록의 디스크 위치 등과 같은 <strong>메타데이터(metadata)</strong> 가 저장되어 있다.<br />
데이터 블럭의 위치를 표현하는 가장 간단한 방법은 <strong>직접 포인터(direct pointer)</strong> 를 두는 것이지만 파일 크기의 제한이 있다.</p>

<h4 id="멀티-레벨-인덱스">멀티 레벨 인덱스</h4>

<p>큰 파일을 지원하기 위한 일반적인 방법은 아이노드 내에 <strong>간접 포인터(indirect pointer)</strong> 를 두는 것이다.<br />
간접 포인터는 데이터 블럭의 위치를 가리키지 않고 데이터 블럭을 가리키는 포인터들이 저장된다.<br />
더 큰 파일을 저장하고 싶으면 <strong>이중 간접 포인터(double indirect pointer)</strong>, <strong>삼중 간접 포인터(triple indirect pointer)</strong> 등을 둘 수 있다.<br />
이러한 구성 방식을 멀티 레벨 인덱스 기법이라고 한다.</p>

<h3 id="404-디렉터리-구조">40.4 디렉터리 구조</h3>

<p>디렉터리의 데이터 블럭에는 문자열과 숫자가 쌍으로 존재하며 문자열 길이에 대한 정보도 있다.<br />
대부분의 파일 시스템에서는 디렉터리들을 특수한 종류의 파일로 간주한다.<br />
디렉터리는 자신의 아이노드를 가지며, 아이노드의 type 필드에 디렉터리 라고 명시되어 잇다.</p>

<h3 id="405-빈공간의-관리">40.5 빈공간의 관리</h3>

<p>파일 시스템은 아이노드와 데이터 블럭 사용 여부를 관리하는 <strong>빈 공간 관리(free space management)</strong> 로 파일이나 디렉터리를 할당할 공간을 찾는다.  <br />
파일 시스템은 <strong>선할당(pre-allocation)</strong> 정책으로 연속된 블럭들이 비어있는 공간 할당하여 파일에 대한 입출력 성능을 개선한다.</p>

<h3 id="406-실행-흐름-읽기와-쓰기">40.6 실행 흐름: 읽기와 쓰기</h3>

<p>파일 시스템 동작을 이해하기 위해 <strong>실행 과정(access path)</strong> 에 대해 알아본다.</p>

<h4 id="디스크에서-파일-읽기">디스크에서 파일 읽기</h4>

<ol>
  <li><code class="language-plaintext highlighter-rouge">open("foo/bar", O_RDONLY)</code> 호출</li>
  <li>항상 <strong>루트 디렉터리(root directory)</strong> 에서 시작하여 루트 디렉터리의 아이노드 읽음</li>
  <li>아이노드에서 데이터 블럭의 포인터 추출 하여 디렉터리 정보 읽기</li>
  <li>디렉터리 정보를 통해 <code class="language-plaintext highlighter-rouge">foo</code> 항목 찾기</li>
  <li><code class="language-plaintext highlighter-rouge">foo</code> 의 아이노드 블럭과 데이터를 읽은 후 <code class="language-plaintext highlighter-rouge">bar</code> 아이노드 번호 찾기</li>
  <li><code class="language-plaintext highlighter-rouge">open()</code> 에서 <code class="language-plaintext highlighter-rouge">bar</code> 에 대한 아이노드를 메모리로 읽어 들임</li>
  <li>파일에 대한 접근 권한을 확인하고 파일 디스크립터를 할당받아 사용자에게 리턴</li>
  <li><code class="language-plaintext highlighter-rouge">read()</code> 를 통해 파일 읽기</li>
</ol>

<h4 id="디스크에-파일-쓰기">디스크에 파일 쓰기</h4>

<ol>
  <li>파일을 열기</li>
  <li><code class="language-plaintext highlighter-rouge">write()</code> 를 호출하여 새로운 내용으로 파일 갱신</li>
</ol>

<h3 id="407-캐싱과-버퍼링">40.7 캐싱과 버퍼링</h3>

<p>대부분의 파일 시스템들은 자주 사용되는 블럭들을 메모리(DRAM)에 캐싱한다.<br />
캐싱을 하지 않으면 아이노드와 디렉터리 데이터 읽기로 최소 두번의 읽기가 필요하다.</p>

<p>초기 시스템은 고정 크기의 캐시(전체 메모리의 약 10%)를 가지고 캐시 교체 정책들로 어떤 블럭들을 남길지 결정했다.</p>

<p>현대 시스템은 동적 파티션 방식을 사용한다.<br />
가상 메모리 페이지와 파일 시스템 페이지들을 통합하여 <strong>일원화된 페이지 캐시(unified page cache)</strong> 를 사용한다.<br />
이를 통해 파일 시스템과 가상 메모리에 융통성있게 메모리를 할당할 수 있다.</p>

<p>캐시를 이용하면 쓰기의 경우 <strong>쓰기 버퍼링(write buffering)</strong> 이 가능하여 <strong>일괄처리(batch)</strong> 가 가능하다.</p>

<ul>
  <li>첫번째 갱신에 대한 쓰기를 연기하여 두 번째 연산과 병합 가능 (I/O 줄임)</li>
  <li>쓰기 요청들을 모아 I/O 들을 스케줄하여 성능 개선</li>
  <li>쓰기 자체 회피 가능 (생성 후 즉시 삭제한다면 생성할 필요가 없음)</li>
</ul>

<p>데이터가 유실되지 않도록 강제적으로 기록하려면 <code class="language-plaintext highlighter-rouge">fsync()</code> 를 사용한다.</p>


          </div>
          <div class="article-share">
            
            
            <a href="https://twitter.com/home?status=[Study]+%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C+%EC%95%84%EC%A3%BC+%EC%89%AC%EC%9A%B4+%EC%84%B8%EA%B0%80%25E...%20-%20https://devyonghee.github.io/study/2022/12/05/operation-system-three-easy-pieces-35-40/" title="Share on Twitter" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6 -18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6 0.8 15 2.5 22.1 -80.5-4-151.9-42.6-199.6-101.3 -8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7C67 210.7 52 206.3 39 199c0 0.4 0 0.8 0 1.2 0 47 33.4 86.1 77.7 95 -8.1 2.2-16.7 3.4-25.5 3.4 -6.2 0-12.3-0.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3 -33.1 26-74.9 41.5-120.3 41.5 -7.8 0-15.5-0.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-0.1-8.4-0.3-12.5C462.6 146 479 129 492 109.5z"/></svg>
            </a>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://devyonghee.github.io/study/2022/12/05/operation-system-three-easy-pieces-35-40/" title="Share on Facebook" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M288 192v-38.1c0-17.2 3.8-25.9 30.5-25.9H352V64h-55.9c-68.5 0-91.1 31.4-91.1 85.3V192h-45v64h45v192h83V256h56.4l7.6-64H288z"/></svg>
            </a>
          </div>
          
            <script src="https://utteranc.es/client.js"
                    repo="devyonghee/devyonghee.github.io"
                    issue-term="pathname"
                    theme="preferred-color-scheme"
                    crossorigin="anonymous"
                    async>
            </script>
          
        </article>
        <footer class="footer scrollappear">
  <p>
    Chalk is a high quality, completely customizable, performant and 100% free
    blog template for Jekyll built by
    <a href="/about" title="About me">Nielsen Ramon</a>. Download it <a href="https://github.com/nielsenramon/chalk" rel="noreferrer noopener" target="_blank" title="Download Chalk">here</a>.
  </p>
</footer>

      </div>
    </div>
  </main>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7PS3PZYZ6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Q7PS3PZYZ6');
  </script>


  <script src="/javascripts/application.f8aad56336bbc2752062.js"></script>


  <script src="/javascripts/scrollappear.964ae3fd7af0dfd85a7e.js"></script>




  <script src="/javascripts/themetoggle.b54b8a02c0c26756418e.js"></script>

</body>
</html>
