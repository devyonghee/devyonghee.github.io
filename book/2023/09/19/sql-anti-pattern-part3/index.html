<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>devyonghee blog | [SQL AntiPattern] 3부 쿼리 안티패턴</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="[SQL AntiPattern] 3부 쿼리 안티패턴">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://devyonghee.github.io/book/2023/09/19/sql-anti-pattern-part3/">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="devyonghee blog">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://devyonghee.github.io/book/2023/09/19/sql-anti-pattern-part3/">
  <meta name="twitter:title" content="[SQL AntiPattern] 3부 쿼리 안티패턴">
  <meta name="twitter:description" content="">

  
    <meta name="google-site-verification" content="1DbhSO778Ec8l_4qztuQgVDcPhc_ya64RGP-nwD_bj0" />
  

  
    <meta property="og:image" content="">
    <meta name="twitter:image" content="">
  

  <link href="https://devyonghee.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="devyonghee blog Last 10 blog posts" />
  <link rel="stylesheet" type="text/css" href="/css/fonts.css">


  <link rel="icon" type="image/x-icon" href="/icons/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  

    
      <link rel="stylesheet" type="text/css" title="light" id="light" href="/css/light.css">
      <link rel="stylesheet" type="text/css" title="dark" id="dark" href="/css/dark.css" disabled="false">
    

  

</head>

<body>
  <main>
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav scrollappear">
  <a href="/" class="header-logo" title="devyonghee blog">devyonghee blog</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-about">
  <use href="/icons/about.svg#icon-about"
       xlink:href="/icons/about.svg#icon-about">
  </use>
</svg>

        </a>
      </li>
    

    
    <li>
      <a href="/tags" title="Tags">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon-tag">
  <use href="/icons/tag.svg#icon-tag"
       xlink:href="/icons/tag.svg#icon-tag">
  </use>
</svg>

      </a>
    </li>
    

    
    
    
    
      <li>
        <a href="https://github.com/devyonghee" rel="noreferrer noopener" target="_blank" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-github">
  <use href="/icons/github.svg#icon-github"
       xlink:href="/icons/github.svg#icon-github">
  </use>
</svg>

        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="mailto:devyonghee@gmail.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-email">
  <use href="/icons/email.svg#icon-email"
       xlink:href="/icons/email.svg#icon-email">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" rel="noreferrer noopener" target="_blank" title="RSS">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-rss">
  <use href="/icons/rss.svg#icon-rss"
       xlink:href="/icons/rss.svg#icon-rss">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a id="toggleBtn" title="Toggle Theme">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-theme">
  <use href="/icons/theme.svg#icon-theme"
       xlink:href="/icons/theme.svg#icon-theme">
  </use>
</svg>

        </a>
      </li>
    
  </ul>
</nav>
        <article class="article scrollappear">
          <header class="article-header">
            <h1>[SQL AntiPattern] 3부 쿼리 안티패턴</h1>
            <p></p>
            <div class="article-list-footer">
  <span class="article-list-date">
    September 19, 2023
  </span>
  <span class="article-list-divider">-</span>
  <span class="article-list-minutes">
    
    
      8 minute read
    
  </span>
  <span class="article-list-divider">-</span>
  <div class="article-list-tags">
    
      <a href="/tag/book" title="See all posts with tag 'book'">book</a>
    
      <a href="/tag/sql anti pattern" title="See all posts with tag 'sql anti pattern'">sql anti pattern</a>
    
      <a href="/tag/database" title="See all posts with tag 'database'">database</a>
    
      <a href="/tag/sql" title="See all posts with tag 'sql'">sql</a>
    
  </div>
</div>
          </header>

          <div class="article-content">
            <p>SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다.<br />
3부에서는 DML(Data Manipulation Language)에 대해 다룬다.</p>

<!--more-->

<p><br /></p>

<h2 id="14장-모르는-것에-대한-두려움-누락된-값-구분하기">14장 모르는 것에 대한 두려움: 누락된 값 구분하기</h2>

<p><code class="language-plaintext highlighter-rouge">NULL</code> 을 포함하는 컬럼에 대해 쿼리를 작성해야 한다.<br />
아래는 쿼리에서 <code class="language-plaintext highlighter-rouge">NULL</code> 값을 생산적으로 사용하는 방법이다.</p>

<ul>
  <li>행을 생성할 때 값을 알수 없는 곳에 <code class="language-plaintext highlighter-rouge">NULL</code> 사용</li>
  <li>적용 가능한 값이 없는 경우 <code class="language-plaintext highlighter-rouge">NULL</code> 사용</li>
  <li>유효하지 않은 값이 입력되는 경우 <code class="language-plaintext highlighter-rouge">NULL</code> 사용</li>
  <li>외부 조인에서 매치되지 않는 행의 컬럼 값을 채우는 경우 <code class="language-plaintext highlighter-rouge">NULL</code> 사용</li>
</ul>

<h3 id="안티패턴-null-을-일반-값처럼-사용">안티패턴: NULL 을 일반 값처럼 사용</h3>

<p>SQL 에서 <code class="language-plaintext highlighter-rouge">NULL</code> 을 <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">false</code>, 빈문자열과 다른 특별한 값으로 취급한다.<br />
<code class="language-plaintext highlighter-rouge">NULL</code> 값은 특별한 규칙을 따른다.</p>

<ul>
  <li><strong>수식에서 NULL 사용</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NULL</code> 에 숫자를 더해도 알지 못하는 값이기 때문에 결과는 <code class="language-plaintext highlighter-rouge">NULL</code>
        <ul>
          <li>ex) <code class="language-plaintext highlighter-rouge">SELECT NULL + 1 -&gt; NULL</code></li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">NOT</code> 같은 불리언 수식 결과는 <code class="language-plaintext highlighter-rouge">NULL</code></li>
    </ul>
  </li>
  <li><strong>NULL 을 가질 수 있는 컬럼 검색</strong>
    <ul>
      <li>여집합(<code class="language-plaintext highlighter-rouge">NOT</code>)으로 검색해도 값이 <code class="language-plaintext highlighter-rouge">NULL</code> 인 행은 검색되지 않음</li>
      <li>동등 조건으로 검색해도 값이 <code class="language-plaintext highlighter-rouge">NULL</code> 인 행은 검색되지 않음
        <ul>
          <li>ex) <code class="language-plaintext highlighter-rouge">WHERE column = NULL</code>, <code class="language-plaintext highlighter-rouge">WHERE column &lt;&gt; NULL</code> 조건은 모두 <code class="language-plaintext highlighter-rouge">NULL</code> 인 행을 반환하지 않음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>쿼리 파라미터로 NULL 사용</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NULL</code> 을 일반적인 값처럼 사용하기 어려워 파라미터로 사용 불가
        <ul>
          <li>ex) <code class="language-plaintext highlighter-rouge">WHERE column = ?</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>문제 회피하기</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NULL</code> 을 금지하기 위해 다른 값(ex. <code class="language-plaintext highlighter-rouge">-1</code>, <code class="language-plaintext highlighter-rouge">''</code>…)으로 대체하면 문제가 될 수 있음
        <ul>
          <li>해당되는 값이 어떤 컬럼에서는 중요한 값이 될 수 있음</li>
          <li>FK 설정이 어려워짐 (없는 값에 대한 행추가가 필요)</li>
          <li>해당 값에 대한 의미를 기억하거나 문서화 필요</li>
        </ul>
      </li>
      <li>누락된 값은 <code class="language-plaintext highlighter-rouge">NULL</code> 로 표현하는 것이 좋음</li>
    </ul>
  </li>
</ul>

<h4 id="사용이-합당한-경우">사용이 합당한 경우</h4>

<ul>
  <li>외부 데이터를 불러오거나(import) 내보내기(export) 하는 경우</li>
  <li>누락된 값에 대해 특별한 구분이 있는 경우</li>
</ul>

<h3 id="해법-유일한-값으로-null을-사용하라">해법: 유일한 값으로 NULL을 사용하라</h3>

<ul>
  <li><strong>스칼라 수식에서의 NULL</strong>
    <ul>
      <li>다음 모든 수식의 결과는 <code class="language-plaintext highlighter-rouge">NULL</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">NULL + 1</code></li>
          <li><code class="language-plaintext highlighter-rouge">NULL = 1</code></li>
          <li><code class="language-plaintext highlighter-rouge">NULL &lt;&gt; 1</code></li>
          <li><code class="language-plaintext highlighter-rouge">NULL || 'string'</code></li>
          <li><code class="language-plaintext highlighter-rouge">NULL = NULL</code> (모르는 값과 모르는 값은 같은지 알 수 없음)</li>
          <li><code class="language-plaintext highlighter-rouge">NULL &lt;&gt; NULL</code> (모르는 값과 모르는 값은 다른지 알 수 없음)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>불리언 수식에서의 NULL</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NULL AND TRUE</code> -&gt; <code class="language-plaintext highlighter-rouge">NULL</code></li>
      <li><code class="language-plaintext highlighter-rouge">NULL AND FALSE</code> -&gt; <code class="language-plaintext highlighter-rouge">FALSE</code> (어떤 값이든 FALSE와 AND 연산하면 FALSE)</li>
      <li><code class="language-plaintext highlighter-rouge">NULL OR TRUE</code> -&gt; <code class="language-plaintext highlighter-rouge">TRUE</code> (어떤 값이든 TRUE와 OR 연산하면 TRUE)</li>
      <li><code class="language-plaintext highlighter-rouge">NULL OR FALSE</code> -&gt; <code class="language-plaintext highlighter-rouge">NULL</code></li>
      <li><code class="language-plaintext highlighter-rouge">NOT NULL</code> -&gt; <code class="language-plaintext highlighter-rouge">NULL</code></li>
    </ul>
  </li>
  <li><strong>NULL 검색하기</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NULL</code> 을 검색하기 위해서는 다른 연산 필요
        <ul>
          <li><code class="language-plaintext highlighter-rouge">IS NULL</code>, <code class="language-plaintext highlighter-rouge">IS NOT NULL</code></li>
          <li><code class="language-plaintext highlighter-rouge">IS DISTINCT FROM</code> 을 사용하면 <code class="language-plaintext highlighter-rouge">IS NULL</code> 확인 조건이 포함됨
            <ul>
              <li>MySQL 에서는 <code class="language-plaintext highlighter-rouge">IS DISTINCT FROM</code> 대신 <code class="language-plaintext highlighter-rouge">&lt;=&gt;</code> 지원</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>칼럼을 NOT NULL 로 선언하기</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NULL</code> 값이 정책 위반 또는 의미가 없는 경우 <code class="language-plaintext highlighter-rouge">NOT NULL</code> 선언 권장</li>
    </ul>
  </li>
  <li><strong>동적 디폴트</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">COALESCE</code> 을 통해 특정 쿼리에서만 디폴트 값 설정</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="15장-애매한-그룹-그룹당-최댓값을-가진-행-얻기">15장 애매한 그룹: 그룹당 최댓값을 가진 행 얻기</h2>

<p>그룹의 최댓값(또는 최솟값, 평균 값)과 함께 해당되는 다른 속성도 포함되는 쿼리를 작성하고자 한다.<br />
<code class="language-plaintext highlighter-rouge">GROUP BY</code> 를 활용하면 값을 쉽게 구할 수 있지만 다른 속성의 값은 해당되는 행에 대한 값이 아닐 수 있다.</p>

<h3 id="안티패턴-그룹되지-않은-컬럼-참조">안티패턴: 그룹되지 않은 컬럼 참조</h3>

<ul>
  <li><strong>단일 값 규칙(Single-Value Rule)</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SELECT</code> 목록의 모든 컬럼은 그룹당 하나의 값을 가져야 함</li>
      <li>하나의 값을 가지지 못한 경우 단일 값 규칙 위반이 됨</li>
    </ul>
  </li>
  <li><strong>내 뜻대로 동작하는 쿼리</strong>
    <ul>
      <li>다른 컬럼에서도 최대값에 대한 행을 가져온다면 다음과 같은 경우 추론 불가능
        <ul>
          <li>최댓값을 구하는 컬럼의 값이 같은 행이 여러 개인 경우</li>
          <li>집계함수가 여러 개인 경우 (ex. <code class="language-plaintext highlighter-rouge">MAX(date_reported), MIN(date_reported)</code>)</li>
          <li>매칭되는 행이 존재하지 않는 경우 (ex. <code class="language-plaintext highlighter-rouge">SUM(hours) AS total, bug_id</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="사용이-합당한-경우-1">사용이 합당한 경우</h4>

<ul>
  <li>함수 종속(functional dependency) 인 경우
    <ul>
      <li>ex) 외래키 그룹과 참조된 테이블의 속성을 가져오는 경우</li>
    </ul>
  </li>
</ul>

<h3 id="해법-컬럼을-모호하게-사용하지-않기">해법: 컬럼을 모호하게 사용하지 않기</h3>

<ul>
  <li><strong>함수 종속인 컬럼만 쿼리하기</strong>
    <ul>
      <li>모호한 컬럼을 쿼리에서 제거</li>
    </ul>
  </li>
  <li><strong>상호 연관된 서브쿼리 사용하기</strong>
    <ul>
      <li>더이상 큰(작은) 값이 없는 데이터을 서브 쿼리로 검색</li>
      <li>성능상 최적의 방법은 아님</li>
    </ul>
  </li>
  <li><strong>유도 테이블(derived table) 사용하기</strong>
    <ul>
      <li>유도 테이블 = 인라인 뷰: 테이블이 들어갈 자리에 서브쿼리 사용</li>
      <li>서브쿼리 사용하는 방법보다 확장적응성(scalability)이 좋음</li>
      <li>임시 테이블에 중간 결과를 저장하므로 성능상 최적의 방법은 아님</li>
    </ul>
  </li>
  <li><strong>조인 사용하기</strong>
    <ul>
      <li>대응되는 행이 없을 수도 있는 행의 집합에 대해 외부 조인 사용</li>
      <li>개념이 어렵고 유지보수가 어려움</li>
      <li>확장적응성(scalability)이 좋음</li>
    </ul>
  </li>
  <li><strong>다른 컬럼에 집계 함수 사용하기</strong>
    <ul>
      <li>집계 함수를 사용하여 단일 값 규칙을 따르도록 함</li>
    </ul>
  </li>
  <li><strong>각 그룹에 대해 모든 값 연결하기</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">GROUP_CONCAT</code> 함수를 사용하여 모든 값을 연결하여 조회</li>
      <li>대응되는 값은 보여주지 않음</li>
      <li>표준 SQL 은 아님</li>
      <li>단일 값 규칙이 위반되는 경우 사용될 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="16장-임의의-선택-샘플-행-가져오기">16장 임의의 선택: 샘플 행 가져오기</h2>

<p>대량의 집합에서 샘플 데이터를 요청하는 일은 흔하다.<br />
임의의 샘플 데이터만 리턴할 수 있는 SQL 쿼리를 작성하고자 한다.</p>

<h3 id="안티패턴-데이터를-임의로-정렬하기">안티패턴: 데이터를 임의로 정렬하기</h3>

<ul>
  <li>임의의 행을 고르기 위해 <code class="language-plaintext highlighter-rouge">RAND()</code> 로 정렬하여 데이터를 임의로 선택
    <ul>
      <li>일반적인 정렬에 비해 인덱스를 사용할 수 없음</li>
      <li>데이터가 많은 경우 매우 많은 비용이 발생</li>
    </ul>
  </li>
</ul>

<h4 id="사용이-합당한-경우-2">사용이 합당한 경우</h4>

<ul>
  <li>데이터 집합이 적은 경우</li>
  <li>데이터가 늘어날 일이 거의 없는 경우</li>
</ul>

<h3 id="해법-테이블-전체-정렬-피하기">해법: 테이블 전체 정렬 피하기</h3>

<p>임의 정렬은 매우 많은 비용이 발생되므로 대안이 필요함</p>

<ul>
  <li><strong>1과 MAX 사이에서 임의의 키 값 고르기</strong>
    <ul>
      <li>PK 값이 1부터 연속적으로 존재한다고 가정하여 사이의 난수 생성</li>
    </ul>
  </li>
  <li><strong>다음으로 큰 키 값 고르기</strong>
    <ul>
      <li>빈틈이 있는 경우를 위해 찾아내는 키 값의 이상인 행을 찾음
        <ul>
          <li>ex) <code class="language-plaintext highlighter-rouge">WHERE id &gt;= {random_number}</code></li>
        </ul>
      </li>
      <li>빈틈 바로 앞에 있는 키 값이 자주 선택될 수 있는 단점</li>
      <li>동일한 빈도로 선태되는 것이 중요하지 않으면 유용</li>
    </ul>
  </li>
  <li><strong>모든 키 값의 목록을 구한 다음, 임의로 하나 고르기</strong>
    <ul>
      <li>애플리케이션 코드에서 모든 키만을 조회하여 임의로 하나를 선택</li>
      <li>또 다른 비용이 발생
        <ul>
          <li>모든 키를 조회하기 때문에 메모리 자원을 넘어설 수 있음</li>
          <li>쿼리가 두 번 발생됨</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>오프셋을 이용해 임의로 고르기</strong>
    <ul>
      <li>행의 개수를 세고 임의의 수를 고르고 오프셋</li>
      <li><code class="language-plaintext highlighter-rouge">LIMIT</code> 절에 의존</li>
      <li>키 값이 연속적이지 않아도 됨</li>
      <li>각 행이 선택될 확률을 같아야 하는 경우 유용</li>
    </ul>
  </li>
  <li><strong>벤더 종속적인 방법</strong>
    <ul>
      <li>Oracle: <code class="language-plaintext highlighter-rouge">SAMPLE</code> 절</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="17장-가난한-자의-검색-엔진-전체-텍스트-검색">17장 가난한 자의 검색 엔진: 전체 텍스트 검색</h2>

<p>텍스트 검색의 기능이 필요한데 성능과 확장 적응성이 필요하다.<br />
하지만 SQL 에서 부분문자열(substring)을 비교하는 것은 비효율적이거나 부정확하다.</p>

<h3 id="안티패턴-패턴-매칭-사용">안티패턴: 패턴 매칭 사용</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">LIKE</code> 또는 <code class="language-plaintext highlighter-rouge">REGEXP</code> 연산자 사용
    <ul>
      <li>많은 테이블 스캔 비용 발생</li>
      <li>일반적인 인덱스 사용 불가</li>
      <li>단순한 패턴 매칭을 원하지 않는 경우가 있음
        <ul>
          <li>ex) <code class="language-plaintext highlighter-rouge">LIKE '%one%'</code> 는 <code class="language-plaintext highlighter-rouge">money</code>, <code class="language-plaintext highlighter-rouge">prone</code> 포함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="사용이-합당한-경우-3">사용이 합당한 경우</h4>

<ul>
  <li>간단한 경우의 패턴인 경우</li>
  <li>아주 가끔씩만 실행되는 경우</li>
</ul>

<h3 id="해법-작업에-맞는-올바른-도구-찾기">해법: 작업에 맞는 올바른 도구 찾기</h3>

<ul>
  <li><strong>전체 텍스트 검색(full-text search)</strong>
    <ul>
      <li>MySQL: <code class="language-plaintext highlighter-rouge">FULLTEXT</code> 인덱스
        <ul>
          <li><code class="language-plaintext highlighter-rouge">CHAR</code>, <code class="language-plaintext highlighter-rouge">VARCHAR</code>, <code class="language-plaintext highlighter-rouge">TEXT</code> 타입의 컬럼에 정의 가능</li>
          <li>전체 텍스트 인덱스의 컬럼 지정 필요</li>
        </ul>
      </li>
      <li>Oracle
        <ul>
          <li><code class="language-plaintext highlighter-rouge">CONTEXT</code>: 하나의 텍스트 컬럼에 대해 정의, <code class="language-plaintext highlighter-rouge">CONTRAINS()</code> 연산자 사용</li>
          <li><code class="language-plaintext highlighter-rouge">CTXCAT</code>: 짧은 텍스트 샘플과 다른 컬럼 함께 사용, <code class="language-plaintext highlighter-rouge">CATSEARCH()</code> 연산자 사용</li>
          <li><code class="language-plaintext highlighter-rouge">CTXXPATH</code>: XML 문서 검색, <code class="language-plaintext highlighter-rouge">existsNode()</code> 연산자 사용</li>
          <li><code class="language-plaintext highlighter-rouge">CTXRULE</code>: 문서 분석하여 분류하는 규칙 설계</li>
        </ul>
      </li>
      <li>PostgreSQL
        <ul>
          <li><code class="language-plaintext highlighter-rouge">TSVECTOR</code> 타입: 텍스트 검색을 위한 인덱스</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>직접 만들기</strong>
    <ul>
      <li>전치 인덱스(inverted index)를 만들어서 검색
        <ul>
          <li>검색할 모든 단어의 목록을 저장하여 연관 시킴 (다대다 관계)</li>
          <li>키워드에 대한 검색을 쉽게 하기 위해 저장 프로시저 작성
            <ul>
              <li><code class="language-plaintext highlighter-rouge">LIKE</code> 또는 <code class="language-plaintext highlighter-rouge">REGEXP</code> 연산자를 사용하여 검색하여 매칭 여부 결정</li>
              <li>검색된 적이 있다면 키워드를 포함한 데이터를 매핑 테이블에 저장</li>
              <li>검색된 적이 없다면 검색이 오래 걸릴 수 있음</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="18장-스파게티-쿼리-sql-쿼리-줄이기">18장 스파게티 쿼리: SQL 쿼리 줄이기</h2>

<p>SQL 프로그래머들은 흔하게 복잡한 문제를 하나의 쿼리로 해결하려고 한다.<br />
복잡한 문제를 단순화하는 방법을 찾아본다.</p>

<h3 id="안티패턴-복잡한-문제를-한-번에-풀기">안티패턴: 복잡한 문제를 한 번에 풀기</h3>

<p>모든 작업을 한 줄의 코드로 해치워야 한다는 접근 방법은 좋지 않다.</p>

<ul>
  <li><strong>의도하지 않은 제품</strong>
    <ul>
      <li>흔하게 카테시안 곱(Cartesian product)이 발생
        <ul>
          <li>쿼리에 사용된 두 테이블의 관계 제한 조건이 없는 경우 발생</li>
          <li>훨씬 많은 행이 반환되어 성능 저하</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>그래도 충분하지 않다면</strong>
    <ul>
      <li>작성, 수정, 디버깅이 어려움</li>
      <li>개선하는 데 많은 비용과 시간이 발생</li>
      <li>복잡한 SQL 쿼리는 엔진이 최적화하여 실행하기 어려움
        <ul>
          <li>여러 개의 단순한 쿼리 사용이 좋음</li>
        </ul>
      </li>
    </ul>

    <h4 id="사용이-합당한-경우-4">사용이 합당한 경우</h4>
    <ul>
      <li>프레임워크나 비주얼 컴포넌트 라이버리를 사용하는 경우</li>
      <li>모든 결과에 대해 정렬된 순서로 봐야하는 경우</li>
    </ul>
  </li>
</ul>

<h3 id="해법-분할해서-정복하기">해법: 분할해서 정복하기</h3>

<p>동일한 결과 집합을 만드는 여러 쿼리 중에 단순한 쿼리를 선택해야 한다.<br />
하지만 너무 많은 SQL 쿼리나 명령문 실행은 가장 효율적인 방법은 아닐 수 있으므로 균형을 잘 유지해야 함</p>

<ul>
  <li><strong>한 번에 하나씩</strong>
    <ul>
      <li>쿼리를 여러 개로 분할
        <ul>
          <li>원치 않은 카테시안 곱 방지</li>
          <li>간단한 쿼리 추가가 쉬워짐</li>
          <li>SQL 엔진은 단순한 쿼리를 최적화</li>
          <li>쿼리 설명이 쉬워짐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>UNION 연산</strong>
    <ul>
      <li>여러 쿼리의 겨과를 하나의 집합으로 묶을 수 있음</li>
      <li>결과를 구분할 수 있는 컬럼 추가 필요</li>
    </ul>
  </li>
  <li><strong>상사의 문제 해결하기</strong>
    <ul>
      <li>원하는 값들을 분리해서 쿼리를 작성</li>
    </ul>
  </li>
  <li><strong>SQL 을 이용한 SQL 자동 생성</strong>
    <ul>
      <li>여러 쿼리로 나누면 데이터 값에 따라 변하는 비슷한 쿼리가 나올 수 있음</li>
      <li>코드 생성을 통해 출력하는 코드를 작성하면 반복 잡업 제거 가능</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="19장-암묵적-컬럼-타이핑-줄이기">19장 암묵적 컬럼: 타이핑 줄이기</h2>

<p>와일드카드(<code class="language-plaintext highlighter-rouge">*</code>)는 암묵적으로 컬럼을 조회하하는데 사용한다.<br />
쿼리를 간결하게 하는 데 도움이 되지만 위험이 따른다.</p>

<h3 id="안티패턴-지름길-좋아하면-길을-잃은다">안티패턴: 지름길 좋아하면 길을 잃은다.</h3>

<ul>
  <li><strong>리팩터링 방해</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">INSERT</code> 에 엉뚱한 값이 할당될 수 있음</li>
      <li><code class="language-plaintext highlighter-rouge">SELECT</code> 에서 컬럼 순서가 바뀌면 결과가 달라질 수 있음
        <ul>
          <li>오류 추적이 어려움</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>숨겨진 비용</strong>
    <ul>
      <li>성능과 확장적응성(scalability) 저하
        <ul>
          <li>보다 더 많은 데이터가 전달될 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>요청한 것을 얻은 것이다</strong>
    <ul>
      <li>모든 컬럼을 요청하거나 칼럼의 목록을 명시적으로 나열해야 함</li>
    </ul>
  </li>
</ul>

<h4 id="사용이-합당한-경우-5">사용이 합당한 경우</h4>

<ul>
  <li>테스트를 위한 데이터 확인 용도의 임시 쿼리</li>
</ul>

<h3 id="해법-명시적으로-컬럼-이름-지정하기">해법: 명시적으로 컬럼 이름 지정하기</h3>

<p>항상 필요한 컬럼을 나열 해야 함</p>

<ul>
  <li><strong>오류 검증</strong>
    <ul>
      <li>테이블 컬럼 위치가 바뀌어도 결과가 바뀌지 않음</li>
      <li>컬럼이 추가되어도 결과에 나타나지 않음</li>
      <li>컬럼이 삭제되면, 쿼리에서 에러 발생</li>
    </ul>
  </li>
  <li><strong>그거 필요하지 않을 꺼야</strong>
    <ul>
      <li>자연히 불필요한 컬럼을 쓰지 않게 됨</li>
      <li>대역폭을 보다 효율적으로 사용</li>
    </ul>
  </li>
  <li><strong>어쨌든 와일드카드를 포기해야 돼</strong>
    <ul>
      <li>와일드카드를 사용하면 컬럼 하나씩 다루기 어려움</li>
      <li>처음부터 와일드카드를 사용하지 않으면 쿼리 변경이 쉬워짐</li>
    </ul>
  </li>
</ul>

<p>관련 코드는 <a href="https://github.com/devyonghee/sql-anti-pattern-study">깃허브</a> 참고</p>

<h2 id="출처">출처</h2>
<ul>
  <li>SQL AntiPatterns</li>
</ul>

          </div>
          <div class="article-share">
            
            
            <a href="https://twitter.com/home?status=[SQL+AntiPattern]+3%EB%B6%80+%EC%BF%BC%EB%A6%AC+%EC%95%88%ED%8B%B0%ED%8C%A8%ED%84%B4%20-%20https://devyonghee.github.io/book/2023/09/19/sql-anti-pattern-part3/" title="Share on Twitter" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6 -18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6 0.8 15 2.5 22.1 -80.5-4-151.9-42.6-199.6-101.3 -8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7C67 210.7 52 206.3 39 199c0 0.4 0 0.8 0 1.2 0 47 33.4 86.1 77.7 95 -8.1 2.2-16.7 3.4-25.5 3.4 -6.2 0-12.3-0.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3 -33.1 26-74.9 41.5-120.3 41.5 -7.8 0-15.5-0.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-0.1-8.4-0.3-12.5C462.6 146 479 129 492 109.5z"/></svg>
            </a>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://devyonghee.github.io/book/2023/09/19/sql-anti-pattern-part3/" title="Share on Facebook" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M288 192v-38.1c0-17.2 3.8-25.9 30.5-25.9H352V64h-55.9c-68.5 0-91.1 31.4-91.1 85.3V192h-45v64h45v192h83V256h56.4l7.6-64H288z"/></svg>
            </a>
          </div>
          
            <script src="https://utteranc.es/client.js"
                    repo="devyonghee/devyonghee.github.io"
                    issue-term="pathname"
                    theme="preferred-color-scheme"
                    crossorigin="anonymous"
                    async>
            </script>
          
        </article>
        <footer class="footer scrollappear">
  <p>
    Chalk is a high quality, completely customizable, performant and 100% free
    blog template for Jekyll built by
    <a href="/about" title="About me">Nielsen Ramon</a>. Download it <a href="https://github.com/nielsenramon/chalk" rel="noreferrer noopener" target="_blank" title="Download Chalk">here</a>.
  </p>
</footer>

      </div>
    </div>
  </main>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7PS3PZYZ6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Q7PS3PZYZ6');
  </script>


  <script src="/javascripts/application.f8aad56336bbc2752062.js"></script>


  <script src="/javascripts/scrollappear.964ae3fd7af0dfd85a7e.js"></script>




  <script src="/javascripts/themetoggle.b54b8a02c0c26756418e.js"></script>

</body>
</html>
