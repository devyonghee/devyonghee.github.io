<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>devyonghee blog | HTTP/0.9 부터 HTTP/3 까지</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="HTTP/0.9 부터 HTTP/3 까지">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://devyonghee.github.io/theory/2021/12/15/http-version-point/">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="devyonghee blog">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://devyonghee.github.io/theory/2021/12/15/http-version-point/">
  <meta name="twitter:title" content="HTTP/0.9 부터 HTTP/3 까지">
  <meta name="twitter:description" content="">

  
    <meta name="google-site-verification" content="1DbhSO778Ec8l_4qztuQgVDcPhc_ya64RGP-nwD_bj0" />
  

  
    <meta property="og:image" content="">
    <meta name="twitter:image" content="">
  

  <link href="https://devyonghee.github.io/feed.xml" type="application/rss+xml" rel="alternate" title="devyonghee blog Last 10 blog posts" />
  <link rel="stylesheet" type="text/css" href="/css/fonts.css">


  <link rel="icon" type="image/x-icon" href="/icons/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  

    
      <link rel="stylesheet" type="text/css" title="light" id="light" href="/css/light.css">
      <link rel="stylesheet" type="text/css" title="dark" id="dark" href="/css/dark.css" disabled="false">
    

  

</head>

<body>
  <main>
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav scrollappear">
  <a href="/" class="header-logo" title="devyonghee blog">devyonghee blog</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-about">
  <use href="/icons/about.svg#icon-about"
       xlink:href="/icons/about.svg#icon-about">
  </use>
</svg>

        </a>
      </li>
    

    
    <li>
      <a href="/tags" title="Tags">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon-tag">
  <use href="/icons/tag.svg#icon-tag"
       xlink:href="/icons/tag.svg#icon-tag">
  </use>
</svg>

      </a>
    </li>
    

    
    
    
    
      <li>
        <a href="https://github.com/devyonghee" rel="noreferrer noopener" target="_blank" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-github">
  <use href="/icons/github.svg#icon-github"
       xlink:href="/icons/github.svg#icon-github">
  </use>
</svg>

        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="mailto:devyonghee@gmail.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-email">
  <use href="/icons/email.svg#icon-email"
       xlink:href="/icons/email.svg#icon-email">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a href="/feed.xml" rel="noreferrer noopener" target="_blank" title="RSS">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-rss">
  <use href="/icons/rss.svg#icon-rss"
       xlink:href="/icons/rss.svg#icon-rss">
  </use>
</svg>

        </a>
      </li>
    
    
      <li>
        <a id="toggleBtn" title="Toggle Theme">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon-theme">
  <use href="/icons/theme.svg#icon-theme"
       xlink:href="/icons/theme.svg#icon-theme">
  </use>
</svg>

        </a>
      </li>
    
  </ul>
</nav>
        <article class="article scrollappear">
          <header class="article-header">
            <h1>HTTP/0.9 부터 HTTP/3 까지</h1>
            <p></p>
            <div class="article-list-footer">
  <span class="article-list-date">
    December 15, 2021
  </span>
  <span class="article-list-divider">-</span>
  <span class="article-list-minutes">
    
    
      9 minute read
    
  </span>
  <span class="article-list-divider">-</span>
  <div class="article-list-tags">
    
      <a href="/tag/http" title="See all posts with tag 'http'">http</a>
    
      <a href="/tag/network" title="See all posts with tag 'network'">network</a>
    
  </div>
</div>
          </header>

          <div class="article-content">
            <p>웹 상에서 서버와 클라이언트간 통신하기 위해 http 를 사용합니다.<br />
이러한 http의 역사와 버전별로 특징에 대해서 알아보도록 하겠습니다.</p>

<!--more-->

<h2 id="http09---원라인-프로토콜">HTTP/0.9 - 원라인 프로토콜</h2>

<p>1991년에 <a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html">문서화</a> 된 최초의 http 버전이 나왔으며 이 버전이 http/0.9 입니다.
http 초기 버전으로 버전 번호가 없었지만 다른 버전과 구별하기 위해 버전이 붙여졌습니다. <br />
http 헤더, 상태, 오류 코드 등이 존재하지 않으며 HTML 파일만 전송 가능합니다.</p>

<h3 id="요청">요청</h3>
<ul>
  <li>CRLF(carriage return, line feed)으로 끝나는 ASCII 문자열로 문서 요청됩니다.</li>
  <li>메소드는 <code class="language-plaintext highlighter-rouge">GET</code>이 유일합니다.</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /mypage.html
</code></pre></div></div>

<h3 id="응답">응답</h3>
<ul>
  <li>ASCII 문자로 이루어진 HTML 메세지입니다.</li>
  <li>오류 응답도 HTML 구문의 사람이 읽을 수 있는 텍스트입니다.</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;HTML&gt;
A very simple HTML page
&lt;/HTML&gt;
</code></pre></div></div>

<h2 id="http10">HTTP/1.0</h2>

<p>1996년 5월 HTTP-WG는 Http/1.0 대해 문서화한 <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a> 발표되었습니다.</p>

<ul>
  <li>request header 에 버전 정보가 추가되었습니다.</li>
  <li>응답 헤더 뒤에 응답 상태가 추가되었습니다.</li>
  <li>HTTP 헤더 개념이 도입되어, 메타데이터 전송을 허용하고 프로토콜을 유연하고 확장 가능하도록 만들어졌습니다.</li>
  <li>HTTP 헤더의 <code class="language-plaintext highlighter-rouge">Content-Type</code> 도움으로 HTML 이외에 다른 파일도 전송이 가능해졌습니다.</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
&lt;HTML&gt;
A page with an image
  &lt;IMG SRC="/myimage.gif"&gt;
&lt;/HTML&gt;
</code></pre></div></div>

<h2 id="http11">HTTP/1.1</h2>

<p>HTTP/1.0 발표된지 몇달 후, 1997년 1월에 HTTP/1.1 의 초기 버전 <a href="https://datatracker.ietf.org/doc/html/rfc2068">RFC2068</a> 이 발표되었습니다.<br />
그리고 2년 정도 뒤인 1999년 5월에 몇가지 개선과 업데이트가 되고 <a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC2616</a> 이 발표되었습니다.</p>

<ul>
  <li>커넥션을 재사용할 수 있게 되어, 사용된 커넥션을 다시 활용할 수 있습니다.</li>
  <li>파이프라이닝이 추가되어, 첫번째 요청에 대해 응답을 받기 전에 다음 요청이 가능해졌습니다.</li>
  <li>추가적인 캐시 제어 메커니즘 도입되었습니다.</li>
  <li>content, encoding, language, character set, cookie 등 요청에 대해 협상 가능한 12가지 기능 추가되었습니다.</li>
  <li>청크된 응답 가능합니다.</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /en-US/docs/Glossary/Simple_header HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Wed, 20 Jul 2016 10:55:30 GMT
Etag: "547fa7e369ef56031dd3bff2ace9fc0832eb251a"
Keep-Alive: timeout=5, max=1000
Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
Server: Apache
Transfer-Encoding: chunked
Vary: Cookie, Accept-Encoding

(content)


GET /static/img/header-background.png HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
Age: 9578461
Cache-Control: public, max-age=315360000
Connection: keep-alive
Content-Length: 3077
Content-Type: image/png
Date: Thu, 31 Mar 2016 13:34:46 GMT
Last-Modified: Wed, 21 Oct 2015 18:27:50 GMT
Server: Apache

(image content of 3077 bytes)

</code></pre></div></div>

<h3 id="파이프라이닝pipelining">파이프라이닝(pipelining)</h3>

<figure>
    <a href="/images/theory/http-version-point/http-pipe-lining.png">
        <img src="/images/theory/http-version-point/http-pipe-lining.png" data-rjs="/images/theory/http-version-point/http-pipe-lining.png" class="zooming" alt="파이프 라이닝" />
    </a>
    
    <figcaption>
        파이프 라이닝
        
        (출처: MDN Web Docs)
        
    </figcaption>
    
</figure>

<p>기본적으로 HTTP는 순차적으로 요청됩니다. 현재 요청에 대해 응답을 받아야 다음 요청을 할 수 있었습니다. 
하지만 이러한 방식은 네트워크 지연이 발생되고 대역폭 제한에 걸려 딜레이가 생기게 됩니다.</p>

<p>이러한 문제를 개선하기 위해 HTTP/1.1에서 파이프라이닝이 추가되었습니다. 
파이프라이닝은 응답을 기다리지 않고 단일 TCP 연결을 통해 여러 요청을 보낼 수 있습니다. 
이 요청 방식으로 커넥션 지연을 피할 수 있고 성능을 향상시킬 수 있습니다.</p>

<p>모든 요청이 아닌 <code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">HEAD</code>, <code class="language-plaintext highlighter-rouge">PUT</code>, <code class="language-plaintext highlighter-rouge">DELETE</code> 메서드 같은 멱등성을 가진 메서드에서만 사용이 가능합니다.</p>

<figure>
    <a href="/images/theory/http-version-point/head-of-line-blocking.png">
        <img src="/images/theory/http-version-point/head-of-line-blocking.png" data-rjs="/images/theory/http-version-point/head-of-line-blocking.png" class="zooming" alt="head of line blocking" />
    </a>
    
    <figcaption>
        head of line blocking
        
    </figcaption>
    
</figure>

<p>하지만 HTTP/1.1에서 파이프라이닝이 추가되면서 성능을 높일 수 있었지만 큰 문제가 있었습니다. 
첫번째 요청의 응답이 지연된다면 그 다음 요청에 대해서도 지연이 발생됩니다. 
이러한 현상을 HOL(Head of line) Blocking 이라고 합니다.</p>

<p>응답 순서가 요청 순서에 따라야 하는 규칙이 있기 때문에 이러한 문제가 있습니다. 
하지만 이 문제는 HTTP/2 에서 바이너리 프레이밍 메커니즘이 도입되면서 해소되었습니다.</p>

<h2 id="http2">HTTP/2</h2>

<p>2009년에 구글에서 개발한 시험용 프로토콜인 SPDY가 발표되었습니다. 
HTTP/1.1 의 성능 제한을 해결하여 웹페이지 로드 지연시간을 줄이는 것이 목표였습니다.<br />
SPDY가 점차 사용되는 곳이 많아지면서 HTTP-WG는 이를 발판으로 더 나은 프로토콜을 빌드하여 개선했습니다.
그렇게 2015년 5월 RFC 7540(HTTP/2)가 발행되었습니다.</p>

<h3 id="바이너리-프레이밍-계층">바이너리 프레이밍 계층</h3>

<figure>
    <a href="/images/theory/http-version-point/binary-framing.png">
        <img src="/images/theory/http-version-point/binary-framing.png" data-rjs="/images/theory/http-version-point/binary-framing.png" class="zooming" alt="바이너리 프레이밍 계층" />
    </a>
    
    <figcaption>
        바이너리 프레이밍 계층
        
        (출처: 구글)
        
    </figcaption>
    
</figure>

<p>HTTP/2 에서 성능 향상 중 가장 핵심은 새로운 바이너리 프레이밍 계층입니다. 
메시지가 캡슐화되어 클라이언트와 서버 사이에 전송되는 방식을 규정합니다.</p>

<p>클라이언트와 서버는 새 바이너리 인코딩 메커니즘을 사용해야 합니다. 
그러므로 HTTP/1.x 클라이언트는 HTTP/2 전용 서버를 이해하지 못합니다.</p>

<h3 id="스트림-메시지-프레임">스트림, 메시지, 프레임</h3>

<figure>
    <a href="/images/theory/http-version-point/stream-message-frame.png">
        <img src="/images/theory/http-version-point/stream-message-frame.png" data-rjs="/images/theory/http-version-point/stream-message-frame.png" class="zooming" alt="스트림 메시지 프레임" />
    </a>
    
    <figcaption>
        스트림 메시지 프레임
        
        (출처: 구글)
        
    </figcaption>
    
</figure>

<p>바이너리 프레이밍 메커니즘이 도입되어 데이터 교환 방식이 변경되었습니다.</p>

<ul>
  <li>스트림 : 구성된 연결 내에서 전달되는 양방향 흐름, 하나 이상의 메세지가 존재 가능합니다.
    <ul>
      <li>모든 통신은 단일 TCP 연결에서 수행됩니다.</li>
      <li>전달될 수 있는 양방향 스트림의 수는 제한이 없습니다.</li>
      <li>각 스트림에는 메시지 전달에 사용되는 고유 식별자와 우선순위 정보가 있습니다.</li>
    </ul>
  </li>
  <li>메시지 : 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스입니다.
    <ul>
      <li>각 메시지는 하나의 논리적 HTTP 메시지입니다.</li>
      <li>메시지는 하나 이상의 프레임으로 구성됩니다.</li>
    </ul>
  </li>
  <li>프레임 : HTTP/2 통신의 최소 단위. 프레임 헤더가 포함되며, 최소한으로 프레임이 속하는 스트림을 식별합니다.
    <ul>
      <li>다른 스트림들의 프레임을 끼워넣을 있으며, 스트림 식별자를 통해 다시 조립할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="요청-및-응답-다중화">요청 및 응답 다중화</h3>

<figure>
    <a href="/images/theory/http-version-point/http2-connection.png">
        <img src="/images/theory/http-version-point/http2-connection.png" data-rjs="/images/theory/http-version-point/http2-connection.png" class="zooming" alt="HTTP 2.0 통신" />
    </a>
    
    <figcaption>
        HTTP 2.0 통신
        
        (출처: 구글)
        
    </figcaption>
    
</figure>

<p>HTTP/1.x의 경우 병렬 요청을 수행하려면 여러 TCP 연결이 필요합니다. 
연결당 하나의 응답만 전달되고 Head-of-Line 차단이 발생됩니다. 
TCP 연결의 비효율적인 사용이 초래됩니다.</p>

<p>HTTP/2의 경우 바이너리 프레이밍 계층의 도입으로 위와 같은 제한을 개선했고 
전체 요청 및 응답 다중화를 지원합니다.
HTTP 메시지를 독립된 프레임으로 세분화하고, 인터리빙한 다음, 다른 쪽에서 다시 조립하도록 허용합니다.</p>

<ul>
  <li>여러 요청과 응답을 차단하지 않고 병렬로 인터리빙할 수 있습니다.</li>
  <li>단일 연결로 요청과 응답을 병렬로 전달이 가능합니다.</li>
  <li>연결된 파일, 이미지 스프라이트, 도메인 분할 같은 불필요한 HTTP/1.x 임시 방편을 제거합니다.</li>
  <li>불필요한 지연 시간을 제거하고 네트워크 용량 활용도를 개선하여 페이지 로드 시간을 줄입니다.</li>
</ul>

<h3 id="스트림-우선순위-지정">스트림 우선순위 지정</h3>

<figure>
    <a href="/images/theory/http-version-point/stream-priority.png">
        <img src="/images/theory/http-version-point/stream-priority.png" data-rjs="/images/theory/http-version-point/stream-priority.png" class="zooming" alt="스트림 우선순위" />
    </a>
    
    <figcaption>
        스트림 우선순위
        
        (출처: 구글)
        
    </figcaption>
    
</figure>

<p>프레임이 인터리빙되면서 전달되는 순서도 중요해졌습니다. 
그래서 HTTP/2 에서는 각 스트림이 연관된 가중치와 종속성이 갖도록 되었습니다.</p>

<ul>
  <li>각 스트림은 1~256 사이의 정수 가중치가 할당될 수 있습니다.</li>
  <li>다른 스트림에 대한 명시적 종속성 부여가 가능합니다.</li>
  <li>종속성과 가중치 조합을 통해서 클라이언트가 ‘우선순위 지정 트리’를 구성하고 통신할 수 있습니다.</li>
  <li>서버가 CPU, 메모리 및 기타 리소스의 할당을 제어하여 스트림 처리의 우선순위를 지정합니다.</li>
  <li>우선순위가 높은 응답이 클라이언트에게 최적으로 전달되도록 대역폭을 할당합니다.</li>
</ul>

<h4 id="종속성">종속성</h4>
<ul>
  <li>스트림 종속성은 다른 스트림의 고유 식별자를 상위 요소로 참조하는 방식으로 선언됩니다.</li>
  <li>고유 식별자가 생략되면 ‘루트 스트림’에 종속됩니다.</li>
  <li>상위 요소 스트림에 종속성보다 리소스가 먼저 할당되어야 합니다. (C보다 D 먼저 처리)</li>
</ul>

<h4 id="가중치">가중치</h4>
<ul>
  <li>상위 요소를 공유하는 스트림은 가중치에 비례하여 리소스가 할당됩니다. (A는 3/4, B는 1/4 수신)</li>
</ul>

<h3 id="출처당-하나의-연결">출처당 하나의 연결</h3>

<ul>
  <li>모든 HTTP/2 연결은 영구적이고 출처당 하나의 연결만 필요합니다.</li>
  <li>동일한 연결을 재사용하여 TCP 연결을 효율적으로 사용합니다.</li>
  <li>전반적인 프로토콜 오버헤드를 대폭 줄일 수 있습니다.</li>
  <li>적은 연결로 메모리와 처리량이 감소됩니다. (운영 비용 절감, 네트워크 활용도와 용량 개선)</li>
</ul>

<h3 id="흐름-제어">흐름 제어</h3>

<p>HTTP/2는 TCP 연결내에서 다중화 되기 때문에 흐름제어가 정교하지 못하며, 
개별 스트림의 전달을 제어하는데 필요한 애플리케이션 수준 API 제공하지 못합니다.</p>

<p>이 문제를 해결하기 위해 HTTP/2 단순한 빌딩 블록 세트를 제공하여, 
스트림 수준과 연결 수준에서 흐름 제어를 구현할 수 있습니다.</p>

<ul>
  <li>흐름 제어는 크레딧 기반입니다. 각 수신기는 자체의 초기 연결과 스트림 흐름제어 창을 알립니다.</li>
  <li>비활성화 될 수 없습니다. 연결이 구성되면 <code class="language-plaintext highlighter-rouge">SETTINGS</code> 프레임을 교환합니다.</li>
  <li>흐름 제어는 종단간 방식이 아닌 홉 방식입니다. 중개자가 자체적인 기준과 추론에 따라 리소스를 제어하고 할당 메커니즘 구현이 가능합니다.</li>
</ul>

<h3 id="서버-푸시">서버 푸시</h3>

<figure>
    <a href="/images/theory/http-version-point/server-push.png">
        <img src="/images/theory/http-version-point/server-push.png" data-rjs="/images/theory/http-version-point/server-push.png" class="zooming" alt="서버 푸시" />
    </a>
    
    <figcaption>
        서버 푸시
        
        (출처: 구글)
        
    </figcaption>
    
</figure>

<p>HTTP/2 에서는 클라이언트가 요청하지 않아도 서버가 추가적인 리소스를 보낼 수 있습니다.</p>

<p>일반적인 웹 애플리케이션은 여러 개의 리소스로 구성됩니다. 
리소스들은 클라이언트에 의해 검색되고 서버가 검사하게 되는데 
서버 푸시를 사용하면 이 지연시간을 줄일 수 있습니다.</p>

<p>데이터 URI를 통해 <a href="https://hpbn.co/http1x/#resource-inlining">리소스 인라인 처리</a> 를 사용해봤다면 
서버 푸시를 사용해본 것입니다.</p>

<p>푸시 리소스의 경우 다음과 같습니다.</p>
<ul>
  <li>클라이언트에 의해 캐시</li>
  <li>다른 페이지에서 재사용</li>
  <li>다른 리소스와 함께 다중화</li>
  <li>서버에서 우선 순위 지정</li>
  <li>클라리언트에 의한 거부</li>
</ul>

<h3 id="헤더-압축-ietf-hpack---http2의-헤더-압축">헤더 압축 (<a href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-compression">IETF HPACK - HTTP/2의 헤더 압축</a>)</h3>

<figure>
    <a href="/images/theory/http-version-point/header-compression.png">
        <img src="/images/theory/http-version-point/header-compression.png" data-rjs="/images/theory/http-version-point/header-compression.png" class="zooming" alt="헤더 압축" />
    </a>
    
    <figcaption>
        헤더 압축
        
        (출처: 구글)
        
    </figcaption>
    
</figure>

<p>HTTP 전송에서는 리소스와 속성을 설명하는 헤더 세트를 전달하게 됩니다. 
HTTP/1.x 에서는 일반 텍스트로 전송되고, 전송당 500~800바이트의 오버헤드가 추가됩니다. (<a href="https://hpbn.co/http1x/#measuring-and-controlling-protocol-overhead">프로토콜 오버헤드</a>)</p>

<p>HTTP/2 에서는 이 오버헤드를 줄이고 성능을 개선하기 위해 HPACK 압축 형식을 사용하여 헤더 메타데이터를 압축합니다. 
압축 형식에는 다음 두 기술을 사용합니다.</p>
<ul>
  <li>전송되는 헤더 필드를 정적 Huffman 코드로 인코딩 합니다.
    <ul>
      <li>개별 전송 크기를 줄여줍니다.</li>
    </ul>
  </li>
  <li>이전에 표시된 헤더 필드의 색인 목록을 서버와 클라이언트가 유지하고 업데이트하도록 요구합니다.
    <ul>
      <li>이전에 전송된 값을 효육적으로 인코딩합니다.</li>
    </ul>
  </li>
</ul>

<p>HPACK 압축 컨텍스트는 정적 및 동적 테이블로 구성됩니다.</p>
<ul>
  <li>정적 테이블
    <ul>
      <li>사양에 정의됩니다.</li>
      <li>모든 연결에 사용될 가능성이 있는 공용 HTTP 헤더 필드를 제공합니다.</li>
    </ul>
  </li>
  <li>동적 테이블
    <ul>
      <li>처음에는 비어있습니다.</li>
      <li>특정 연결에서 교환되는 값에 따라 업데이트 됩니다.</li>
    </ul>
  </li>
</ul>

<h2 id="http3">HTTP/3</h2>

<figure>
    <a href="/images/theory/http-version-point/http2-vs-http3.svg">
        <img src="/images/theory/http-version-point/http2-vs-http3.svg" data-rjs="/images/theory/http-version-point/http2-vs-http3.svg" class="zooming" alt="http2 vs http3" />
    </a>
    
    <figcaption>
        http2 vs http3
        
        (출처: 위키피디아)
        
    </figcaption>
    
</figure>

<p>HTTP/3는 HTTP의 3번째 메이저 버전으로  2015년에 HTTP/2 가 발표된지 4년만에 나왔습니다. (<a href="https://datatracker.ietf.org/doc/html/rfc9000">rfc9000</a>)
기존의 HTTP 와 가장 큰 차이점은 <code class="language-plaintext highlighter-rouge">TCP</code> 가 아닌 <code class="language-plaintext highlighter-rouge">UDP</code> 기반의 <code class="language-plaintext highlighter-rouge">QUIC</code>을 이용하여 통신을 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">QUIC</code>은 Quick UDP Internet Connection 의 약자로 전송 프로토콜인 UDP 기반으로 동작합니다. 
클라이언트와 서버의 연결 수를 줄이고 대역폭을 에상해서 패킷 혼잡을 피한다는 것이 주요 특징입니다.</p>

<h3 id="qpack">QPACK</h3>

<p>HTTP/2 에서 헤더 메타데이터 압축을 위해 HPACK 압축 형식을 이용했습니다. <br />
HTTP/3 에서는 이 HPACK의 핵심 개념을 이용하긴 했지만, 
HPACK 알고리즘은 TCP 위에서 사용되기 때문에 스트림 전달 순서에 의존하고 있었습니다.</p>

<p>QUIC은 UDP 위에서 통신하기 때문에 QPACK 압축 형식으로 개선되었습니다.
압축 형식으로 순서에 의존하지 않고, head of line blocking 문제 개선, 최적의 압축비를 고려하여 재설계 되었습니다. 
HPACK을 QUIC 맞게 사용할 수 있도록 수정된 것이 QPACK이라 볼 수 있습니다. (<a href="https://datatracker.ietf.org/doc/html/draft-ietf-quic-qpack-09">QPACK: Header Compression for HTTP/3</a>)</p>

<h3 id="연결-지연-감소">연결 지연 감소</h3>

<figure>
    <a href="/images/theory/http-version-point/rtt-comparison.gif">
        <img src="/images/theory/http-version-point/rtt-comparison.gif" data-rjs="/images/theory/http-version-point/rtt-comparison.gif" class="zooming" alt="RTT 비교" />
    </a>
    
    <figcaption>
        RTT 비교
        
        (출처: <a href="https://cloudplatform.googleblog.com/2018/06/Introducing-QUIC-support-for-HTTPS-load-balancing.html" target="_blank"> 구글 클라우드 플랫폼 블로그 </a>)
        
    </figcaption>
    
</figure>

<p>RTT(Round Trip Time)는 패킷이 목적지에 도달하고 응답이 돌아오기까지의 시간, 즉 패킷 왕복 시간을 의미합니다.</p>

<p>HTTP + TLS + TCP 에서 TCP는 서버와 클라이언트 연결을 설정하기 위해서 핸드쉐이크가 필요하고 
TLS 사용한 보안 설정을 위해 자체 핸드쉐이크가 필요하기 때문에 총 3 RTT가 필요합니다.</p>

<p>반면, <code class="language-plaintext highlighter-rouge">QUIC</code> 은 보안 세션 설정을하기 위해 단일 핸드쉐이크(1 RTT)만 필요합니다. 
이것이 가능한 이유는 첫번째 핸드셰이크가 이뤄질 때, 연결 설정과 함께 데이터를 보내기 때문입니다. 
TCP + TLS 에서는 연결과 암호화에 필요한 정보를 교환하고 유효성을 검사한 뒤에 데이터를 교환하지만 
QUIC 에서는 세션 키를 교환하기도 전에 데이터를 교환하게 됩니다.</p>

<p>한번 연결에 성공했다면 서버는 그 설정을 캐싱하고 있습니다. 
다음 연결부터는 이 캐싱된 설정을 이용해서 연결이 되기 때문에 0 RTT 만으로도 통신을 할 수 있습니다. 
<code class="language-plaintext highlighter-rouge">QUIC</code> 핸드쉐이크에 대해 더 자세히 알고 싶다면 <a href="https://www.youtube.com/watch?v=vXgbPZ-1-us">Rovert Lychv 발표</a>를 참고해주세요.</p>

<h3 id="패킷-손실-감지-시간-감소">패킷 손실 감지 시간 감소</h3>

<p>에러를 복구하는 방식은 다양합니다. 
그중에서 에러가 발생하면 수신 측이 에러 발생을 송신 측에 통보하여 송신 측에서 
에러 프레임을 재전송하는 방식을 ARQ(Automatic Repeat reQuest)라고 합니다.
QUIC, TCP 는 기본적으로 이러한 ARQ 방식을 사용하기 때문에 패킷에 대해 흐름 제어가 필요합니다.</p>

<p>TCP 는 그중에서도 Stop and Wait ARQ 방식을 이용하고 있습니다.
송신 측이 패킷을 보냈는데 일정 시간이 경과해도 수신 측 답변이 없으면 손실로 판단하고 해당 패킷을 다시 보내는 방식입니다.
하지만, Stop and Wait ARQ 방식은 패킷 손실 감지를 하기 위해서 언제 타임 아웃낼지 동적 계산이 필요합니다. 
이 시간을 RTO(Retransmission Time Out) 이라고 하며, 이 계산을 위해서는 RTT(Round Trip Time) 샘플이 필요합니다.</p>

<p>하지만 타임아웃을 통해 패킷 손실이 발생하면 RTT 계산이 애매해지고, 
ACK 이 어느 패킷에 대한 응답인지 알기 위해서 별도의 방법과 패킷 검사가 필요합니다.
이른 재전송 모호성(Retransmission Ambiguity)라고 합니다.</p>

<p>이 문제를 개선하기 위해 QUIC 에서는 전송 순서를 나타내는 패킷 번호 공간이 부여됐습니다. 
재전송 시, 동일한 번호로 보내는 시퀀스 번호와 다르게 매전송마다 패킷 번호가 증가하기 때문에 쉽게 순서를 파악할 수 있습니다. 
이 고유한 패킷 번호를 통해 패킷 손실 감지에 필요한 시간을 단축할 수 있습니다. 
(<a href="http://www.watersprings.org/pub/id/draft-ietf-quic-recovery-02.html#monotonically-increasing-packet-numbers">참고 자료</a>)</p>

<h3 id="멀티-플렉싱">멀티 플렉싱</h3>

<figure>
    <a href="/images/theory/http-version-point/http2-head-of-line-block.png">
        <img src="/images/theory/http-version-point/http2-head-of-line-block.png" data-rjs="/images/theory/http-version-point/http2-head-of-line-block.png" class="zooming" alt="head of line block" />
    </a>
    
    <figcaption>
        head of line block
        
        (출처: <a href="https://blog.cloudflare.com/ko-kr/http3-the-past-present-and-future-ko-kr/" target="_blank"> cloudflare 블로그 </a>)
        
    </figcaption>
    
</figure>

<p>HTTP/2 에서 스트림의 개념이 도입되면서 TCP 연결을 더 효율적으로 사용할 수 있도록 개선되었습니다. 
하지만 여기에서도 마찬가지로 문제가 있습니다.</p>

<p>복수의 요청/응답을 단일 TCP 연결에서 사용하기 때문에 
패킷 손실된 하나의 요청에만 관계되도 모든 응답/요청이 영향을 받게 된다는 것입니다. 
TCP 패킷이 네트워크 경로상에서 손실되면 스트림에 누락 구간이 생기고, TCP는 손실이 탐지되면 영향받은 패킷만을 재전송하려고 합니다. 
이 과정에서 다른 요청에 대해서도 전달받지 못하여 불필요한 지연이 발생됩니다. 
그러므로 HoLB(head of line blocking) 문제가 남아있는 것입니다.</p>

<figure>
    <a href="/images/theory/http-version-point/quic-stream-multiplexing.png">
        <img src="/images/theory/http-version-point/quic-stream-multiplexing.png" data-rjs="/images/theory/http-version-point/quic-stream-multiplexing.png" class="zooming" alt="head of line block" />
    </a>
    
    <figcaption>
        head of line block
        
        (출처: <a href="https://ably.com/topic/http3" target="_blank"> ably </a>)
        
    </figcaption>
    
</figure>

<p>TCP에서의 HoLB 문제를 개선하고자 QUIC에서는 단일 연결에서 다중 스트림의 개념을 도입했습니다. 
다중 스트림을 지원하여 손실된 UDP 패킷이 속한 스트림에만 영향을 미치도록 합니다. 
다른 스트림에서 수신된 데이터는 계속해서 재조립되어 애플리케이션에 전달될 수 있습니다.</p>

<h3 id="연결-id">연결 ID</h3>

<p>TCP 의 경우, 서버와 클라이언트의 IP 주소와 포트로 연결을 식별합니다. 
그러므로 IP가 변경된다면 연결이 끊어지게 되고 다시 연결하기 위해 3 way handshake 과정이 필요하게 되어 지연이 발생됩니다.</p>

<p>반면, QUIC은 각 연결에 대해 Connection ID를 가지게 되는데 이를 통해 연결을 식별합니다. 
이 Connection ID는 하위 프로토콜 계층(UDP, IP 혹은 그 하위 계층)에서 주소가 변경되더라도 정상적으로 전달받을 수 있습니다. 
즉, 다운로드 진행 도중 셀룰러에서 와이파이 혹은 반대로 전환되어도 연결 마이그레이션이 되어 계속 진행할 수 있습니다.</p>

<h2 id="참조">참조</h2>
<ul>
  <li><a href="https://ko.wikipedia.org/wiki/HTTP">https://ko.wikipedia.org/wiki/HTTP</a></li>
  <li><a href="https://kyun2da.dev/CS/http%EC%9D%98-%EC%97%AD%EC%82%AC%EC%99%80-http2%EC%9D%98-%EB%93%B1%EC%9E%A5/">https://kyun2da.dev/CS/http%EC%9D%98-%EC%97%AD%EC%82%AC%EC%99%80-http2%EC%9D%98-%EB%93%B1%EC%9E%A5/</a></li>
  <li><a href="https://developers.google.com/web/fundamentals/performance/http2?hl=ko#%EC%8A%A4%ED%8A%B8%EB%A6%BC_%EB%A9%94%EC%8B%9C%EC%A7%80_%EB%B0%8F_%ED%94%84%EB%A0%88%EC%9E%84">https://developers.google.com/web/fundamentals/performance/http2?hl=ko#%EC%8A%A4%ED%8A%B8%EB%A6%BC_%EB%A9%94%EC%8B%9C%EC%A7%80<em>%EB%B0%8F</em>%ED%94%84%EB%A0%88%EC%9E%84</a></li>
  <li><a href="https://hpbn.co/brief-history-of-http">https://hpbn.co/brief-history-of-http</a></li>
  <li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></li>
  <li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x">https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x</a></li>
  <li><a href="https://m.blog.naver.com/sehyunfa/221680799006">https://m.blog.naver.com/sehyunfa/221680799006</a></li>
  <li><a href="https://velog.io/@ziyoonee/HTTP1-%EB%B6%80%ED%84%B0-HTTP3-%EA%B9%8C%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0">https://velog.io/@ziyoonee/HTTP1-%EB%B6%80%ED%84%B0-HTTP3-%EA%B9%8C%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</a></li>
  <li><a href="https://evan-moon.github.io/2019/10/08/what-is-http3/">https://evan-moon.github.io/2019/10/08/what-is-http3/</a></li>
  <li><a href="https://blog.cloudflare.com/ko-kr/http3-the-past-present-and-future-ko-kr/">https://blog.cloudflare.com/ko-kr/http3-the-past-present-and-future-ko-kr/</a></li>
  <li><a href="https://http3-explained.haxx.se/ko/the-protocol/feature-http">https://http3-explained.haxx.se/ko/the-protocol/feature-http</a></li>
  <li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf">https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf</a></li>
</ul>

          </div>
          <div class="article-share">
            
            
            <a href="https://twitter.com/home?status=HTTP/0.9+%EB%B6%80%ED%84%B0+HTTP/3+%EA%B9%8C%EC%A7%80%20-%20https://devyonghee.github.io/theory/2021/12/15/http-version-point/" title="Share on Twitter" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6 -18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6 0.8 15 2.5 22.1 -80.5-4-151.9-42.6-199.6-101.3 -8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7C67 210.7 52 206.3 39 199c0 0.4 0 0.8 0 1.2 0 47 33.4 86.1 77.7 95 -8.1 2.2-16.7 3.4-25.5 3.4 -6.2 0-12.3-0.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3 -33.1 26-74.9 41.5-120.3 41.5 -7.8 0-15.5-0.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-0.1-8.4-0.3-12.5C462.6 146 479 129 492 109.5z"/></svg>
            </a>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://devyonghee.github.io/theory/2021/12/15/http-version-point/" title="Share on Facebook" rel="noreferrer noopener" target="_blank">
              <svg viewBox="0 0 512 512"><path d="M288 192v-38.1c0-17.2 3.8-25.9 30.5-25.9H352V64h-55.9c-68.5 0-91.1 31.4-91.1 85.3V192h-45v64h45v192h83V256h56.4l7.6-64H288z"/></svg>
            </a>
          </div>
          
            <script src="https://utteranc.es/client.js"
                    repo="devyonghee/devyonghee.github.io"
                    issue-term="pathname"
                    theme="preferred-color-scheme"
                    crossorigin="anonymous"
                    async>
            </script>
          
        </article>
        <footer class="footer scrollappear">
  <p>
    Chalk is a high quality, completely customizable, performant and 100% free
    blog template for Jekyll built by
    <a href="/about" title="About me">Nielsen Ramon</a>. Download it <a href="https://github.com/nielsenramon/chalk" rel="noreferrer noopener" target="_blank" title="Download Chalk">here</a>.
  </p>
</footer>

      </div>
    </div>
  </main>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7PS3PZYZ6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Q7PS3PZYZ6');
  </script>


  <script src="/javascripts/application.f8aad56336bbc2752062.js"></script>


  <script src="/javascripts/scrollappear.964ae3fd7af0dfd85a7e.js"></script>




  <script src="/javascripts/themetoggle.b54b8a02c0c26756418e.js"></script>

</body>
</html>
