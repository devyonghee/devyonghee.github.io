---
title: 이펙티브 자바 Chapter4. 클래스와 인터페이스
tags: [book, effective-java]
categories: book
---


이펙티브 자바 4장에서는 클래스와 인터페이스 설계 요소에 대해 설명하고 있다.   
견고하고 유연한 코드를 위해 자세하게 알아보도록 한다.

<!--more-->

## 아이템15. 클래스와 멤버의 접근 권한을 최소화하라

모든 클래스와 멤버의 접근성을 가능한한 좁혀야 함 (정보 은닉 핵심)  
외부에서 쓸 이유가 없다면 ￿`package-private` 선언

- 권장 사항
  - `public` 클래스의 어떠한 필드도 `public` 이면 안됨 (가변 필드를 가진 클래스는 스레드 안전하지 않음)
  - `public static final` 배열 필드나 이를 반환하는 메서드 제공하면 안됨 (불변 리스트 or 복사본 반환 사용)

- **정보 은닉** 장점
  - 여러 컴포넌트 병렬 개발로 속도 향상
  - 컴포넌트 교체 부담 감소, 빠른 디버깅으로 관리 비용 하락
  - 다른 컴포넌트 영향없이 해당 컴포넌트만 최적화 가능
  - 새로운 환경에서도 유용하게 쓰일 수 있어 재상용성 증가
  - 개변 컴포넌트 동작 검증 가능하여 큰 시스템 제작 난이도 감소

- 접근 범위
  - `private` : 멤버를 선언한 톱레벨 클래스에서만 접근
  - `package-private` : 소속된 패키지 안의 모든 클래스에서 접근 (명시하지 않으면 적) 
  - `protected` : `package-private` 포함, 하위 클래스에서도 접근 
  - `private` : 모든 곳에서 접근
  
<br/>

## 아이템16. `public`클래스에서는 `public`필드가 아닌 접근자 메서드를 사용하라

패키지 바깥에서 접근할 수 있으면 접근자를 제공
`package-private`, `private` 클래스라면 데이터 필드 노출해도 문제 없음

<br/>

## 아이템17. 변경 가능성을 최소화하라

**클래스**는 필요한 경우가 아니라면 **불변** 
불변으로 만들 수 없다면 변경 부분을 **최소한**으로 

- 불변 클래스 규칙
  - 객체 상태 변경 메서드 제공금지
  - 클래스 확장 금지(`final` 클래스 선언)
  - 모든 필드 `final` 선언
  - 모든 필드 `private` 선언
  - 내부 가변 컴포넌트에 접근 방지
  
- 불변 객체 장점
  - 객체가 단순
  - 스레드 안전, 동기화 필요 없음
  - 불변 객체끼리 내부데이터 공유 가능
  - 실패 원자성(메서드 예외 발생해도 객체는 유효) 제공

- 불변 객체는 값이 다르면 독립 객체 생성해야 한다는 단점 존재 (중간 단계에서 쓰고 버려지는 객체 발생)
  - 다단계 연산들을 예측하여 기본 기능 제공
  - 가변 동반 클래스를 `public`으로 제공(ex. `StringBuilder`)
  
<br/>

## 아이템18. 상속보다는 컴포지션을 사용하라

> 이번 아이템은 인터페이스 상속과 무관

확장 대신 `private` 필드로 **인스턴스 참조** 사용(composition; 컴포지션)  
기존 클래스의 대응 메서드를 호출하는 방식을 **forwarding** 방식이라고 하며, 새 클래스의 메서드는 **forwarding method**
  
**상속**은 정말 **하위 타입인 상황**에서만 사용

- 상속 단점
  - 캡슐화가 깨짐
  - 상위 클래스 메서드 다시 구현이 어렵고, 오류가 나거나 성능이 떨어질 수 있음
  - 하위 클래스에서 콜렉션에 허용되지 않는 원소를 추가
  - 하위 클래스 반환타입이 다르면 컴파일 불가능
  - 불변식을 해칠 수 있음

- 컴포지션
  - 인터페이스 활용으로 설계가 견고하고 유연
  - 래퍼클래스 : 다른 인스턴스를 감싸고 있음
  - 데코레이터 패턴 : 기능을 덧씌움
  - 컴포지션과 전달의 조합은 넓은 의미로 위임

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

내부적으로 어떻게 이용되고 있는지 문서화(Implementation Requirements)가 되어 있어야 함  
Implementation Requirements 절은 `@implSpec` 태그를 붙이면 자바독 도구가 생성

- 효율적인 하위 클래스를 만들려면 내부동작 과정 중 훅을 선별하여 `protected` 메서드 형태로 공개
- 상속용 클래스의 생성자는 재정의 가능 메서드를 호출하면 안됨 (초기화 전에 메서드가 호출될 수 있음)
- `clone`, `readObject` 메서드는 생성자와 비슷한 역할, 재정의 가능 메서드를 호출하면 안됨

- 상속 금지
  - 클래스를 `final` 선언
  - 모든 생성자를 `private` or `package-private` 선언, 정적 팩토리 메서드 이용

<br/>

## 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

> 믹스인: 주된 타입 이외에 특정 선택정 행위를 제공 (ex. Comparable)

- 자바는 단일 상속만 지원되므로 추상 클래스 방식은 큰 제약    
- 인터페이스는 기존 클래스에도 쉽게 구현 가능  
- 인터페이스는 믹스인(mixin) 정의에 안성맞춤 
- 인터페이스는 계층구조가 없는 타입 프레임워크(ex. SingerSongWriter) 만들 수 있음 (클래스로 만든다면 조합 폭발 발생)
- 래퍼 클래스를 이용하면 안전하게 기능 향상 가능 (추상 클래스에서 기능 추가하려면 상속뿐)
- 디폴트 메서드를 제공한다면 `@implSpec` 태그로 문서화
- 인터페이스와 추상 골격 구현(skeletal implementation)으로 두 가지 장점을 모두 취할 수도 있음 (ex. `AbstractCollection`, `AbstractSet`...)
  - 관례상 골격 구현 클래스의 이름은 `Abstract{인터페이스 명}`
- 골격 구현 대신 단순 구현(simple implementation)도 가능 (골격 구현과 다르게 추상클래스가 아님 ex.`SimpleEntry`)


