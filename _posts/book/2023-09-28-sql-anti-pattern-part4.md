---
title: '[SQL AntiPattern] 4부 애플리케이션 개발 안티패턴'
tags: [book, sql anti pattern, database, sql]
categories: book
---

SQL 을 효과적으로 활용하기 위해 SQL AntiPattern 의 내용을 정리한다.  
4부에서는 애플리케이션에서 SQL 을 다루는 방법에 대해 알아본다.  

<!--more-->

<br/>

## 20장 읽을 수 있는 패스워드: 패스워드를 복구하거나 재설정하기

대부분 사용자가 패스워드를 잊어버린 경우, 
이메일 피드백을 통해 패스워드를 복구하거나 재설정하는 기능을 제공한다. 

### 안티패턴: 패스워드를 평문으로 저장하기

패스워드를 평문으로 담은 이메일로 제공해준다면, 
심각한 보안 결함이 되고 접근 권한을 제공해줄 수 있기 때문에 위험하다.  

- **패스워드 저장**
  - 패스워드를 평문으로 저장하거나 평문 상태로 전달하면 안전하지 않음
  - 해커가 네트워크 패킷을 가로채 SQL 문 확인 가능
  - 데이터베이스 서버에서 접근 권한을 제공해줄 수 있음
  - 백업 데이터를 읽을 수 있음
- **패스워드 인증**
  - 패스워드가 평문으로 저장되어 있으면 평문으로 비교 수행
  - 공격자에게 패스워드가 노출될 위험이 있음
- **이메일로 패스워드 보내기**
  - 이메일은 해커가 가로채거나, 로깅, 저장할 수 있음

#### 사용이 합당한 경우

- 애플리케이션이 다른 서드파티 서비스에 접근해야 하는 경우
- 인트라넷 애플리케이션인 경우

### 해법: 패스워드의 소금 친 해시 값을 저장한다

- **해시 함수 이해하기**
  - 일방향 해시 함수로 패스워드 부호화(encode)
    - ex) SHA-256 알고리즘을 사용하면 문자열 길이가 항상 같음
  - 역을 구하기 어려움
- **SQL 에서 해시 사용하기**
  - `SHA2()` 함수를 사용해 해시 값을 생성
  - 해시 함수가 리턴할 수 없는 값(16진수가 아닌 값)으로 변경하면 계정을 잠글 수 있음
    - ex) `noaccess`
- **해시에 소금 추가하기**
  - 소금(salt): 일방향 함수의 입력값에 덧붙이는 랜덤비트
  - 해시 값을 구하기 전에 패스워드에 덧붙이는 무의미한 바이트열임 (8바이트면 충분)
  - 데이터베이스에서 해커가 해시 값과 비교하여 찾을 수 없도록 임의아 값을 추가
- **SQL 에서 패스워드 숨기기**
  - 네트워크 패킷 또는 SQL 로그 파일을 가로챈다면 패스워드가 노출될 수 있음
  - 애플리케이션 코드에서 해시 값을 계산해 SQL 에서 활용
  - 브라우저와 웹 애플리케이션 서버에서는 HTTPS 같은 보안 프로토콜 사용
- **패스워드 복구가 아닌 패스워드 재설정 사용하기**
  - 해시 값이 저장되어 있으므로 복구 불가능
  - 이메일로 패스워드 대신 임시 패스워드를 보냄
    - 짧은 시간이 지나면 만료시킬 수 있음
  - 아이디에 유일한 토큰을 할당하여 이메일로 보내 패스워드 재설정
- 안전한 암호학 기술
  - PBKDF2: 키 강화 표준
  - Bcrypt: 적응성 해시 함수 구현

<br/>

## 21장 SQL 인젝션: 동적 SQL 쿼리 작성하기

쿼리 문자열과 애플리케이션 변수를 섞어 SQL 문자열로 만드는 것을 동적 SQL(dynamic SQL) 이라고 한다.  
안전하게 동적 SQL 을 만드는 방법에 대해 알아본다.  

### 안티패턴: 검증되지 않은 입력을 코드로 실행하기

SQL 인젝션: 어떤 내용을 SQL 쿼리 문자열에 삽입하여 쿼리의 동작을 의도와 다르게 수정하는 것  

- **사고는 발생할 것이다**
  - 이름에 `'` 이 포함되면 의도하지 않은 형태로 바뀔 수 있음
  - 의도하지 않은 동작이 실행될 수 있음
- **최고의 웹 보안 위협**
  - SQL 문이 파싱되기 전에 동적인 부분을 삽입하면 SQL 인젝션 위험이 있음
- **치료를 위한 탐구**
  - 값을 이스케이프하기
    - 따옴표 문자를 두 개 또는 역슬래시를 추가하여 문자 리터럴로 변경
    - 문자열 삽입하기 전에 애플리케이션 데이터를 변환
  - 쿼리 파라미터
    - 동적 값 삽입 대신 쿼리를 만들 때 파라미터 자리를 미리 정의하여 실행할 때 값 제공
    - 이스케이프할 필요도 없고 이스케이프 함수의 결함을 고려하지 않아도 됨
    - 보편적인 해결 방법은 될 수 없음
      - 값의 목록을 하나의 파라미터로 전달 불가능
      - 테이블 이름은 파라미터로 전달 불가능
      - 컬럼 이름을 파라미터로 전달 불가능
      - SQL 키뤄드를 파라미터로 전달 불가능
  - 저장 프로시저
    - 보통 고정된 SQL 을 포함하며, 프로시저 정의할 때 파싱
    - 애플리케이션 코드에서 동적 SQL 사용하는 것처럼 위험함
  - 데이터 접근 프레임워크
    - 어떤 프레임워크든 안전한 SQL 코드만 작성하도록 강제 불가능

#### 사용이 합당한 경우

- 있을 수 없음
- 코드를 방어적으로 작성해야 함

### 해법: 아무도 믿지 마라

- **입력 값 필터링**
  - 입력에 대해 유효하지 않은 문자 모두 제거
    - 정수가 필요하다면, 정수에 맞는 내용만 사용
- **파라미터를 통한 값 전달**
  - 쿼리의 동적 부분이 단순한 값이라면 SQL 표현과 파라미터 분리 필요
- **동적 값 인용하기**
  - 쿼리 파라미터 사용으로 옵티마이저의 인덱스 사용이 잘못될 수 있음
  - 특별한 경우 SQL 문제 해당 값을 직접 삽입하는 것이 나을 수 있음
    - 성숙된 문자열 인용 함수를 사용하여 방어적으로 작성
- **사용자의 입력을 코드와 격리하기**
  - 요청 파라미터로 미리 값을 정의하여 SQL 쿼리에 사용
    - ex) 정렬 목록 또는 방향의 리스트를 정의 (`up` => `ASC`, `down` => `DESC`)
  - 사용자의 입력을 SQL 쿼리와 직접 엮지 않아 안전
  - SQL의 어느 부분이든 동적으로 생성 가능
  - 사용자의 입력이 유효한지 검증 가능
  - 쿼리의 내용을 사용자 인터페이스에서 분리
- **코드 검토를 함께할 동료 구하기**
  - SQL 인젝션 위험에 익숙한 동료에게 검사

<br/>

## 22장 가상키 편집증: 데이터 정돈하기

수열 중간에 숫자가 몇 개 빠지면 불편한 것은 데이터베이스 기술에 대한 이해나 확인이 부족한 것이 보통이다.

### 안티패턴: 모든 틈 메우기

- **시퀀스에서 벗어난 번호 할당하기**
  - 새로운 행에 키 값을 할당할 때 사용되지 않은 첫번째 값을 사용하고 싶을 수 있음
    - 동시성 문제 발생될 수 있음
  - 비효율적이며 에러가 발생될 수 있음
- **기존 행의 번호를 다시 매기기**
  - 기존 행에 대한 키 값을 업데이트해 틈을 메우고 연속적으로 만들 수 있음
    - 사용되지 않은 키 값을 찾아야 함
    - PK 값을 재할당하기 위해 `UPDATE` 문 실행 필요
    - 동시성 문제 발생될 수 있음
    - 외래키가 있다면 제약조건을 비활성화하고 자식 행까지 업데이트 필요
  - 업데이트해도 디폴트 가상키 생성기를 사용하면 틈이 메워지지 않음
- **데이터 불일치 만들기**
  - PK 를 재사용하는 것을 위험함
  - 가상키에 빈 값이 있다고 재할당하면 안됨

#### 사용이 합당한 경우

- 가상키 값을 바꿔야할 이유는 없음
- PK 칼럼의 값이 의미를 가진다면 자연키임

### 해법: 극복하라

행을 식별하는 데 연속적인 숫자일 필요는 없음

- **행에 번호 매기기**
  - 행 번호는 PK 와 대응되는 것이 아님
  - 페이지 처리하는데 유용
  - `ROW_NUMBER()` 윈도 함수를 사용하면 쿼리 결과 집합에 대한 연속된 번호 확인 가능
- **GUID 사용하기**
  - GUID(Global Unique Identifier): 128비트 의사난수로 32자리 16진수
  - 장점
    - 중복 걱정없이 동시에 가상키 생성 가능
    - 틈에 대한 불평이 없음
  - 단점
    - 키 값이 길어짐
    - 값이 랜덤하여 패턴 추론이 어렵고, 큰 값이 최근 행을 나타내지 않음
    - 공간도 많이 차지하고 속도도 느림
- **가장 중요한 문제**
  - 데이터베이스를 정리를 해결하기 위해서는 커뮤티케이션도 중요
    - 기술 설명
    - 비용을 명확하게 함
    - 자연키 사용하기

<br/>

## 23장 나쁜 것 안 보기: 코드를 적게 작성하기

간결한 코드를 작성해야 하는 이유

- 작동하는 애플리케이션 코딩을 빨리 끝낼 수 있음
- 테스트화, 문서화, 동료 검토할 코드 양 감소
- 코드양이 적으면 버그도 적음

### 안티패턴: 짚 없이 벽돌 만들기

- **진단 없는 진료**
  - 함수로부터 리턴된 상태값 체크 필요
    - ex) db 커넥션, 잘못된 쿼리 등
- **읽기간 행**
  - SQL 쿼리를 문자열로 생성하는 애플리케이션 코드를 보는 것은 매우 어려움
  - 디버깅할 때, SQL 자체를 보고 판단하는 것이 빠름

#### 사용이 합당한 경우

- 에러에 대해 할 것이 없다면 에러 검사 생략 가능
- 예외를 던져 호출 스택의 위로 전달될 수 있도록 함

### 해법: 에러에서 우아하게 복구하기

- **리듬 유지하기**
  - API 호출 후 리턴 상태나 예외 확인 
  - 에러가 발생할 수 있는 모든 호출에 대해 상태 확인
- **스텝 되짚기**
  - API 메서드의 인수에서 SQL 쿼리를 만들지 말고 변수를 사용해서 만들기
    - 변수 값 확인할 수 있음
  - SQL 을 따로 출력하도록 함
    - ORM 프레임워크를 사용하면 디버깅이 복잡해질 수 있음
  - SQL 쿼리를 HTML 주석으로 출력하면 안됨
    - 해커가 데이터베이스 구조를 파악할 수 있음