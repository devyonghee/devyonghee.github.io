---
title: 이펙티브 자바 Chapter12. 직렬화
tags: [book, effective-java]
categories: book
---


이펙티브 자바 12장에서는 직렬화에 대해서 소개한다.   
객체를 바이트 스트림으로 인코딩하고 디코딩하면서 생기는 위험에 대해 최소화하는 방법을 알아본다.

<!--more-->

<br/>

## 아이템 85. 자바 직렬화의 대안을 찾으라

**직렬화**는 공격 범위가 너무 넓어 **방어가 어려움**
- 역 직렬화 과정에서 타입안의 모든 코드를 수행할 수 있음
- 신뢰할 수 없는 스트림을 역직렬화하면 원격 코드 실행(RCE), 서비스 거부(DOS) 등 공격 가능
- 위험을 피하기 위해 아무것도 **역직렬화 하지 않아야 함**
- 새로운 시스템에서 자바 직렬화를 사용하지 않아야 함

자바 직렬화 위험을 회피, 다양한 플랫폼 지원, 성능 우수 등 이점이 있는 **크로스 플랫폼 구조화된 데이터 표현** 사용 추천
- 대표적인 **크로스 플랫폼 구조화된 데이터 표현** 은 JSON 과 프로토콜 버퍼
- **JSON** 은 **텍스트 기반**이라 읽을 수 있음
- **프로토콜 버퍼**는 이진 표현이라 **효율이 높음**

직렬화가 필요하고 역직렬화가 안전한지 모른다면 **객체 역직렬화 필터링**(`java.io.ObjectInputFilter`) 사용
- **객체 역직렬화 필터링**은 역직렬화되기 전에 **필터**를 설치하는 기능
- 특정 클래스를 받아들이거나 거부 가능, **화이트리스트** 방식 추천 (안전하다고 알려진 클래스만 수용)

<br/>

## 아이템 86. `Serializable`을 구현할지는 신중히 결정하라

`Serializable` 구현한 뒤에는 **수정이 어려움**
- 직렬화 가능한 클래스가 퍼진다면 직렬화 형태를 **영원히 지원**해야 됨
- 클래스의 private, package-private 필드들이 공개 됨(**캡슐화 깨짐**)
- 내부 구현을 수정하면 기존 직렬화 형태와 달라짐 (신버전 클래스로 역직렬화 하면 깨짐)
- 고유 식별 번호(`static final long serialVersionUID`) 명시하지 않으면 자동 생성되므로 **호환성이 쉽게 깨짐**

**버그**와 **보안 구멍**이 생길 위험이 생김
- 역직렬화는 **숨은 생성자**가 됨 (불벽식 깨짐, 허가되지 않은 접근에 노출)

해당 클래스의 신버전을 릴리즈할 때 **테스트**할 것이 늘어남
- 신버전, 구버전의 **직렬화**/**역직렬화** 가능 테스트
- 객체의 **복제 가능** 테스트

**상속용 클래스**는 `Serializable` 구현 금지, **인터페이스**는 `Serializable` 확장 금지
- 확장하거나 구현할 때 큰 부담을 주게 됨
- 구현한 예로는 `Throwable`, `Component`가 존재
- 직렬화를 지원하지 않는 상속용 클래스의 하위 클래스가 직렬화하려면 상위 클래스에서 **매개변수 없는 생성자**가 필요함
  - 생성자 지원하지 않으면 **직렬화 프록시 패턴**을 사용

직렬화가 가능하다면 주의해야 할 점
- `finalize` 메서드로 재정의하지 못하게 해야 함 (finalizer 공격 방지)
- 불변식이 있다면 `readObjectNoData` 메서드 추가 (직렬화 가능 상위 클래스를 추가하기 위한 메서드)

**내부 클래스**는 직렬화 구현 금지
- 내부 클래스에 대한 기본 직렬화 형태가 분명하지 않음
- 정적 멤버 클래스는 `Serializable` 구현 가능
