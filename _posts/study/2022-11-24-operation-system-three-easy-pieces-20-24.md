---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 20장~24장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 20장부터 24장까지의 내용을 정리한다. 

<!--more-->

## 20장. 페이징: 더 작은 테이블

페이징의 두번째 문제는 **페이지 테이블의 크기**다.  
페이지 테이블이 크면 많은 메모리 공간을 차지한다.  


### 20.1 간단한 해법: 더 큰 페이지

페이지 크기를 증가시키면 페이지 테이블의 크기를 줄일 수 있다.  
페이지 크기가 4배 증가되면 페이지 테이블의 크기는 1/4로 줄어든다.  

하지만 부작용으로 **내부 단편화(internal fragmentation)** 가 발생한다.  
페이지 내부의 낭비 공간이 증가하는 것이다.  
할당받은 페이지의 일부분만 사용하게 되기 때문에 메모리가 금방 고갈되는 현상이 발생된다.

### 20.2 하이브리드 접근 방법: 페이징과 세그멘트

페이징과 세그멘트 방법을 조합하는 것을 **하이브리드(hybrid)** 라고 한다.  
두 방법을 결합하여 테이블 크기를 줄이는 것이다.  

프로세스의 전체 주소 공간을 위한 페이지 테이블 대신, 논리 세그멘트마다 따로 페이지 테이블을 둔다.  
세그멘테이션은 물리 주속 시작 위치를 나타내는 **베이스(base)** 레지스터, 크기를 나타내는 **바운드(bound)** 또는 **리미트(limit)** 레지스터가 존재한다.  
여기서 베이스 레지스터는 세그먼트 시작 주소가 아니라 **세그멘트의 페이지 테이블의 시작 주소**를 갖는다.

TLB 미스가 발생한 경우 다음과 같이 동작한다. (하드웨어 기반으로 가정)

1. 하드웨어가 세그멘트 비트(SN) 을 사용하여 어떤 베이스와 바운드 쌍을 사용할지 결정
2. 레지스터에 있는 물리 주소를 VPN과 페이지 테이블 항목(PTE) 주소 획득

```text
SN           = (VirtualAddress & SEG_MASK) >> SN_SHIFT
VPN          = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
``` 

#### 문제점

- 세그멘테이션을 사용
  - 빈 공간이 많은 힙의 경우 페이지 테이블의 낭비를 면치 못함

- 외부 단편화 유발
  - 페이지 테이블 크기에 제한이 없어 다양한 크기를 가짐
  - 메모리상에서 테이블용 공간을 확보하는 것이 복잡


### 20.3 멀티 레벨 페이지 테이블


{% include image.html alt="선형(좌)과 멀티 레벨(우) 페이지 테이블" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/multi-level-page-table.png" %}

세그멘테이션을 사용하지 않고 페이지 테이블 크기를 줄이는 또 다른 방법은 **멀티 레벨 페이지 테이블(multi-level page table)** 이다.  
멀티 레벨 페이지 테이블에서는 선형 페이지 테이블을 트리 구조로 표현한다.  

멀티 레벨 페이지 테이블 개념은 다음과 같다. 

- 페이지 테이블을 페이지 크기의 단위로 나눈다.
- **페이지 디렉터리(page directory)** 자료 구조로 각 페이지의 할당 여부와 위치 파악
   - 페이지 디렉터리에는 페이지 테이블의 구성요소인 각 페이지의 존재 여부와 위치 정보를 가지고 있음
- 페이지 디렉터리는 **페이지 디렉터리 항목(page directory entries, PDE)** 들로 구성, 페이지 테이블의 한 페이지 표현 
  - PDE 의 구성은 PTE 와 유사, **유효 비트(valid)** 와 **페이지 프레임 번호(page frame number, PFN)** 를 가짐

{% include image.html alt="멀티 레벨 페이지 테이블 가상 주소 공간" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/multi-level-page-table-virtual-address-space.png" %}

- VPN 에서 페이지-디렉터리 인덱스(page-directory index, PDIndex) 추출하여 PDE 주소 찾음
  - `PDEAddr = PageDirBase + (PDIndex * sizeof(PDE))`
- PDE 가 유효하다면 VPN 나머지 주소로 **페이지-테이블 인덱스 (page-table index, PTIndex)**
  - `PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))`
- `PhysAddr = (PTE.PFN << SHIFT) + offset`
- 2단계 이상인 경우 페이지 디렉터리가 추가되면서 가상 주소가 새로운 PD Index 로 추가 분할

#### 장점

- 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간 할당
  - 작은 크기의 페이지 테이블로 주소 공간 표현 가능
- 페이지 테이블을 페이지 크기로 분할하여 메모리 관리 용이
  - 페이지 테이블이 산재해 있어도 페이지 디렉터리로 위치 파악이 가능하므로 공간 할당이 유연

#### 문제점

- 추가 비용 발생
  - TLB 미스 시, 주소 변환을 위해 두 번의 메모리 로드 발생 (페이지 디렉터리 와 PTE 접근)
  - TLB 히트 시 성능은 동일, TLB 미스 시 두 배의 시간 소요
- 복잡도
  - 메모리 자원 절약을 위해, 페이지 테이블 검색이 복잡


### 20.4 역 페이지 테이블

또 다른 공간 절약 방법으로 **역 페이지 테이블(inverted page table)** 이 존재한다.    
여러 개의 페이지 테이블(프로세스당 하나씩) 대신 시스템에 단 하나의 페이지를 두는 것이다.  

- 물리 페이지를 가상 주소 상의 페이지로 변환
- 각 항목은 물리 페이지를 사용중인 **프로세스 번호**, 해당 **가상 페이지 번호** 를 가지고 있음
- 주소 변환을 위해 전체 테이블 검색
  - 탐색 속도 향상을 위해 주로 해시 테이블 사용

### 20.5 페이지 테이블을 디스크로 스와핑하기

모든 페이지 테이블을 메모리에 상주하기에는 너무 크다.  
어떤 시스템들은 페이지 테이블들을 커널 가상 메모리에 위치시키고, 메모리가 부족하면 디스크에 **스왑(swap)** 한다. 

