---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 20장~24장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 20장부터 24장까지의 내용을 정리한다. 

<!--more-->

## 20장. 페이징: 더 작은 테이블

페이징의 두번째 문제는 **페이지 테이블의 크기**다.  
페이지 테이블이 크면 많은 메모리 공간을 차지한다.  


### 20.1 간단한 해법: 더 큰 페이지

페이지 크기를 증가시키면 페이지 테이블의 크기를 줄일 수 있다.  
페이지 크기가 4배 증가되면 페이지 테이블의 크기는 1/4로 줄어든다.  

하지만 부작용으로 **내부 단편화(internal fragmentation)** 가 발생한다.  
페이지 내부의 낭비 공간이 증가하는 것이다.  
할당받은 페이지의 일부분만 사용하게 되기 때문에 메모리가 금방 고갈되는 현상이 발생된다.

### 20.2 하이브리드 접근 방법: 페이징과 세그멘트

페이징과 세그멘트 방법을 조합하는 것을 **하이브리드(hybrid)** 라고 한다.  
두 방법을 결합하여 테이블 크기를 줄이는 것이다.  

프로세스의 전체 주소 공간을 위한 페이지 테이블 대신, 논리 세그멘트마다 따로 페이지 테이블을 둔다.  
세그멘테이션은 물리 주속 시작 위치를 나타내는 **베이스(base)** 레지스터, 크기를 나타내는 **바운드(bound)** 또는 **리미트(limit)** 레지스터가 존재한다.  
여기서 베이스 레지스터는 세그먼트 시작 주소가 아니라 **세그멘트의 페이지 테이블의 시작 주소**를 갖는다.

TLB 미스가 발생한 경우 다음과 같이 동작한다. (하드웨어 기반으로 가정)

1. 하드웨어가 세그멘트 비트(SN) 을 사용하여 어떤 베이스와 바운드 쌍을 사용할지 결정
2. 레지스터에 있는 물리 주소를 VPN과 페이지 테이블 항목(PTE) 주소 획득

```text
SN           = (VirtualAddress & SEG_MASK) >> SN_SHIFT
VPN          = (VirtualAddress & VPN_MASK) >> VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
``` 

#### 문제점

- 세그멘테이션을 사용
  - 빈 공간이 많은 힙의 경우 페이지 테이블의 낭비를 면치 못함

- 외부 단편화 유발
  - 페이지 테이블 크기에 제한이 없어 다양한 크기를 가짐
  - 메모리상에서 테이블용 공간을 확보하는 것이 복잡


### 20.3 멀티 레벨 페이지 테이블


{% include image.html alt="선형(좌)과 멀티 레벨(우) 페이지 테이블" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/multi-level-page-table.png" %}

세그멘테이션을 사용하지 않고 페이지 테이블 크기를 줄이는 또 다른 방법은 **멀티 레벨 페이지 테이블(multi-level page table)** 이다.  
멀티 레벨 페이지 테이블에서는 선형 페이지 테이블을 트리 구조로 표현한다.  

멀티 레벨 페이지 테이블 개념은 다음과 같다. 

- 페이지 테이블을 페이지 크기의 단위로 나눈다.
- **페이지 디렉터리(page directory)** 자료 구조로 각 페이지의 할당 여부와 위치 파악
   - 페이지 디렉터리에는 페이지 테이블의 구성요소인 각 페이지의 존재 여부와 위치 정보를 가지고 있음
- 페이지 디렉터리는 **페이지 디렉터리 항목(page directory entries, PDE)** 들로 구성, 페이지 테이블의 한 페이지 표현 
  - PDE 의 구성은 PTE 와 유사, **유효 비트(valid)** 와 **페이지 프레임 번호(page frame number, PFN)** 를 가짐

{% include image.html alt="멀티 레벨 페이지 테이블 가상 주소 공간" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/multi-level-page-table-virtual-address-space.png" %}

- VPN 에서 페이지-디렉터리 인덱스(page-directory index, PDIndex) 추출하여 PDE 주소 찾음
  - `PDEAddr = PageDirBase + (PDIndex * sizeof(PDE))`
- PDE 가 유효하다면 VPN 나머지 주소로 **페이지-테이블 인덱스 (page-table index, PTIndex)**
  - `PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))`
- `PhysAddr = (PTE.PFN << SHIFT) + offset`
- 2단계 이상인 경우 페이지 디렉터리가 추가되면서 가상 주소가 새로운 PD Index 로 추가 분할

#### 장점

- 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간 할당
  - 작은 크기의 페이지 테이블로 주소 공간 표현 가능
- 페이지 테이블을 페이지 크기로 분할하여 메모리 관리 용이
  - 페이지 테이블이 산재해 있어도 페이지 디렉터리로 위치 파악이 가능하므로 공간 할당이 유연

#### 문제점

- 추가 비용 발생
  - TLB 미스 시, 주소 변환을 위해 두 번의 메모리 로드 발생 (페이지 디렉터리 와 PTE 접근)
  - TLB 히트 시 성능은 동일, TLB 미스 시 두 배의 시간 소요
- 복잡도
  - 메모리 자원 절약을 위해, 페이지 테이블 검색이 복잡


### 20.4 역 페이지 테이블

또 다른 공간 절약 방법으로 **역 페이지 테이블(inverted page table)** 이 존재한다.    
여러 개의 페이지 테이블(프로세스당 하나씩) 대신 시스템에 단 하나의 페이지를 두는 것이다.  

- 물리 페이지를 가상 주소 상의 페이지로 변환
- 각 항목은 물리 페이지를 사용중인 **프로세스 번호**, 해당 **가상 페이지 번호** 를 가지고 있음
- 주소 변환을 위해 전체 테이블 검색
  - 탐색 속도 향상을 위해 주로 해시 테이블 사용

### 20.5 페이지 테이블을 디스크로 스와핑하기

모든 페이지 테이블을 메모리에 상주하기에는 너무 크다.  
어떤 시스템들은 페이지 테이블들을 커널 가상 메모리에 위치시키고, 메모리가 부족하면 디스크에 **스왑(swap)** 한다. 

<br/>

## 21장. 물리 메모리 크기의 극복: 메커니즘

다수의 프로세스들이 동시에 큰 주소 공간을 사용하는 상황을 가정한다.  
이를 위해 메모리 계층에 레이어 추가가 필요하다.  
현대 시스템에서는 보통 **하드 디스크 드라이브**를 큰 주소 공간을 보관해두는 공간으로 사용된다.   

편리함과 사용 용이성을 위해 프로세스에게 주소 공간을 충분히 제공해야 한다.  
**스왑 공간** 을 사용하면 프로세스들에게 큰 가상 메모리가 있는 것 같은 환상을 줄 수 있다.  

### 21.1 스왑 공간

**스왑 공간(swap space)** 은 디스크에 페이지들을 저장할 수 있는 일정 공간이다.  

- 스왑 공간의 입출력 단위는 페이지라고 가정
  - swap out: 메모리 페이지를 읽어서 스왑 공간에 저장
  - swap in: 페이지를 읽어 메모리에 탑재
- 운영체제는 스왑 공간에 있는 모든 페이지들의 **디스크 주소** 를 저장해야 함  
- 스왑 공간을 이용하면, 실제 물리메모리 공간보다 많은 공간이 존재하는 것처럼 가장 가능
- 스왑 공간에만 스왑을 할 수 있는 것은 아님
  - 코드 영역의 물리 페이지는 다른 페이지가 사용할 수 있는데 이는 파일 시스템 영역을 스왑 목적으로 사용하는 것임  


### 21.2 Present Bit

하드웨어 기반 TLB 를 사용하는 시스템에서 메모리 참조 과정을 다시 살펴본다.  

#### TLB 히트

1. 가상 주소에서 VPN 추출
2. TLB 에 정보가 있는지 검사(TLB 히트)
3. 물리 주소 얻은 후 메모리로 가져옴

#### TLB 미스

1. 가상 주소에서 VPN 추출
2. TLB 에 정보가 있는지 검사(TLB 미스)
3. 페이지 테이블의 메모리 주소 파악(페이지 테이블 베이스 레지스터 이용)
4. VPN 을 인덱스로 **페이지 테이블 항목(PTE)** 추출
5. 물리메모리에 존재하면 PTE 에서 PFN 정보 추출 후 TLB 탑재
6. 명령어 재실행

페이지가 디스크로 스왑되기 위해서 **present bit** 를 이용하여 PTE 에서 페이지가 물리 메모리에 존재하는지 여부를 표시한다.  
1 이라면 물리 메모리에 페이지 존재, 0이면 디스크 어딘가에 존재하는 것이다.  

물리 메모리에 존재하지 않는 페이지를 접근하는 행위는 **페이지 폴트(page fault)** 라고 한다.
페이지 폴트가 발생하면 운영체제로 제어권이 넘어가며 **페이지 폴트 핸들러(page-fault handler)** 가 실행된다.


### 21.3 페이지 폴트

페이지 폴트가 발생하면 운영체제의 **페이지 폴트 핸들러** 가 처리한다.  
페이지 폴트 발생 시, 운영체제는 페이지 테이블 항목(PTE) 에서 페이지의 디스크상 위치를 파악하여, 메모리로 탑재한다.  

1. 디스크 I/O 가 완료되면 운영체제는 PTE 의 PFN 값을 탑재된 페이지의 메모리 위치로 갱신
2. 페이지 폴트를 발생시킨 명령어 재실행
3. 재실행으로 인해 TLB 미스가 발생되면 TLB 미스 처리 과정이후 TLB 값 갱신(페이지 폴트 처리시 함께 갱신도 가능)
4. 재실행 시에 TLB 에서 주소 변환 정보 찾고 물리 주소에서 데이터 가져옴

I/O 실행은 시간이 많이 소요되므로 프로세스는 **차단된(blocked)** 상태가 된다.    
멀티 프로그램된 시스템에서는 다른 프로세스의 실행을 **중첩(overlap)** 시킬 수 있다.  

### 21.4 메모리에 빈 공간이 없으면?

스왑 공간으로부터 **페이지를 가져오기 위한 (page-in)** 여유 메모리가 부족하면, 다른 페이지들을 먼저 **페이지 아웃(page-out)** 할 수 있다.  
**교체(replace)** 페이지를 선택하는 것이 **페이지 교체 정책(page-replacement policy)** 라고 한다.  


### 21.5 페이지 폴트의 처리 

1. 탑재할 페이지를 위한 물리 프레임 확보
2. 여유 프레임이 없으면 교체 알고리즘으로 페이지 아웃(page-out) 으로 여유 공간 확보
3. I/O 요청ㅇ로 스왑 영역에서 페이지 읽어옴
4. 페이지 테이블을 갱신하고 명령어 재실행
5. 재실행하면 TLB 미스가 발생하며, 다시 재시도할 때 TLB 히트


### 21.6 교체는 실제 언제 일어나는가

교체 알고리즘은 효율적이지 않기 때문에 운영체제는 항상 여유 메모리 공간을 확보하고 있어야 한다.  
그래서 대부분의 운영체제들은 여유 공간에 관련된 **최댓값(high watermark, HW)** 과 **최솟값(low watermark, LW)** 을 설정하여 교체 알고리즘 작동에 활용한다.  
여유 공간의 크기가 **최솟값보다 작아지면** 여유 공간 확보를 위한 백그라운드 쓰레드가 **최댓값에 이를 때까지** 페이지를 제거한다.
백그라운드 쓰레드는 **스왑 데몬(swap daemon)** 또는 **페이지 데몬(page daemon)** 이라고 불린다.  

많은 시스템들은 성능을 높이기 위해 페이지들을 **클러스터(cluster)** 나 **그룹(group)** 으로 묶어 스왑 파티션에 저장하여 디스크의 효율을 높인다.  

<br/>

## 22장. 물리 메모리 크기의 극복: 정책

