---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 29장~33장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 병행성에 대해 다룬 29장부터 33장까지의 내용을 정리한다. 

<!--more-->

## 29장. 락 기반의 병행 자료 구조

자료 구조에 락을 추가하면 경쟁조건으로 부터 안전한 **쓰레드 안전(thread safe)** 자료 구조로 만들 수 있다.  
어떤 방식으로 병행 자료 구조를 다뤄야하는지 알아본다.  

### 29.1 병행 카운터 

카운터는 보편적으로 사용되면서 가장 간단한 자료 구조이다.  

#### 간단하지만 확장성이 없음

```c
typedef struct __counter_t {
    int value;
    pthread_mutex_t lock;
} counter_t;
 
void increment(counter_t *c) {
    Pthread_mutex_lock(&c->lock);
    c->value++;
    Pthread_mutex_unlock(&c->lock);
}
void decrement(counter_t *c) {
    Pthread_mutex_lock(&c->lock);
    c->value++;
    Pthread_mutex_unlock(&c->lock);
}
void get(counter_t *c) {
    Pthread_mutex_lock(&c->lock);
    int rc = c->value;
    Pthread_mutex_unlock(&c->lock);
    return rc;
}
```

- 간단하지만 정확하게 동작, 병행 자료 구조의 보편적인 디자인 패턴
- **모니터(monitor)** 를 사용하여 만든 자료구조와 유사
- 쓰레드 개수가 늘어날 수록 성능이 나빠짐

**완벽한 확장성(perfect scaling)** 이 보장된 환경에서는 작업양이 CPU 개수에 비례해서 증가해도 전체 완료 시간이 늘어나지 않는다.

#### 확장성 있는 카운팅

확장성 있는 카운터를 만들기 위해 **근사 카운터(approximate counter)** 기법을 사용한다.  
근사 카운터는 하나의 논리적 카운터로 표현되는데 CPU 코어마다 하나의 물리적인 **지역 카운터**와 하나의 **전역 카운터**로 구성되어있다.  

쓰레드는 지역 카운터를 증가시켜 지역 락으로 보호한다.  
CPU 마다 지역 카운터를 갖기 때문에 CPU 들에 분산된 쓰레드들은 지역 카운터를 경쟁 없이 갱신할 수 있다. (확장성) 

주기적으로 지역 카운터 값을 전역 카운터에 반영하고 쓰레드는 전역 카운터를 읽어 카운터 값을 판단한다.  
전역 락을 사용하면 지역 카운터의 값을 전역 카운터 값에 더하고, 지역 카운터의 값은 0으로 초기화 한다.  

## 29.2 병행 연결 리스트

연결 리스트를 병행적으로 다루기 위해 삽입 연산을 시작하기 전에 락을 획득하고 리턴 직전에 해제한다.  

### 확장성 있는 연결리스트

병행 가능한 연결 리스트는 확장성이 좋지 않다.  
이를 개선하기 위해 hand-over-hand locking (또는 lock coupling) 기법 개발

전체 리스트에 하나의 락이 아니라 노드마다 락을 추가하는 것이다.  
리스트를 순회하면서 다음 노드의 락을 획득하고 지금 노드의 락을 해제한다.  
하지만 락을 획득하고 해제하는 오버헤드가 크기 때문에 속도 개선이 쉽지 않다.  

## 29.3 병행 큐

병행 큐는 큐의 헤드와 테일에 락을 사용한다.  
큐에 삽입과 추출 연산에 병행성을 부여하는 것이다.  

하지만 이 락만 존재하는 큐는 쓰레드가 대기하는 기능이 없기 때문에 실제로 사용할 수 없다. 

## 29.4 병행 해시 테이블

병행 해시 테이블은 전체 자료 구조에 하나의 락이 아닌 해시 버켓마다 락을 사용했기 때문에 병행 리스트에 비해 병행성이 좋다.  


### 29.5 요약

카운터, 리스트, 큐 해시 테이블 병행 자료 구조들을 소개했다.  
락 획득과 해제 코드에 대해 주의를 기울여야 하는데,   
성능 개선은 **미숙한 최적화(premature optimization)** 를 피하기 위해 성능에 문제가 생길 경우에만 고려해야 한다. 


<br/>

## 30장. 컨디션 변수

병행 프로그램을 제작하는데 락 이외에도 특정 **조건** 의 만족 여부를 검사하는 기법도 존재한다. 


### 30.1 컨디션 변수의 개념과 관련 루틴

쓰레드 실행 시, 특정 조건이 만족될 때까지 대기를 위해 **컨디션 변수(conditional variable)** 를 사용할 수 있다.  
컨디션 변수는 쓰레드 실행에서 특정 조건이 만족되기를 대기하는 큐 자료 구조다.  

슬립에서 깨어난 프로세스는 리턴하기 전에 락을 재획득 해야 한다.  
대기상태에서 깨어났어도 락 획득에 실패하면 다시 sleep 상태로 들어간다.  

## 30.2 생산자/소비자(유한 버퍼) 문제

동기화 문제인 **생산자/소비자(producer/consumer)** 또는 **유한 버퍼(bounded 버퍼)** 문제에 대해 살펴본다.  
생산자 쓰레드는 데이터 만들어 버퍼에 넣고, 소비자 쓰레드는 버퍼에서 데이터를 꺼내 사용한다.  

유한 버퍼는 공유 자원으로 경쟁 조건이 발생되지 않도록 동기화가 필요하다.  

## 30.3 포함 조건(Covering Condition)

다수의 쓰레드가 메모리 공간의 발생을 대기하고 있는 경우 어떤 쓰레드를 깨워야할지 선택해야 한다.  
이 문제를 해결하기 위해 대기 중인 모든 쓰레드에게 시그널을 보내 대기상태에서 준비상태로 전이하여 모든 쓰레드를 깨워서 실행한다.  
깨어난 쓰레드들은 조건을 검사하고 만족하지 않으면 다시 대기모드로 들어가고 만족하면 실행을 계속한다.  
이러한 방식을 **포함 조건(Covering Condition)** 이라고 한다.

하지만 불필요하게 많은 쓰레드를 깨우기 때문에 불필요한 문맥 전환이 발생될 수 있다는 것이 단점이다.  


