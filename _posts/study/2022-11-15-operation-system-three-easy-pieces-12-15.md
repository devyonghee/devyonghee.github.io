---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 12장~15장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 12장부터 15장까지의 내용을 정리한다. 

<!--more-->

## 12장. 메모리 가상화에 관한 대화

- 가상 메모리 관리자의 동작
  - 베이스-바운드
  - TLB 와 멀티 레벨 페이지 테이블 문제 해결 방법
- 사용자 프로그램이 생성하는 모든 주소는 **가상 주소**
  - 사용하기 쉬운 시스템을 제공하기 위함
  - 프로세스에게 대용량 연속된 주소 공간(address space)을 가지고 있다고 시각을 제공
  - 고립(isolation) 과 보호(protection)
    - 다른 프로세스의 메모리를 읽거나 변경할 수 없음


<br/>

## 13장. 주소 공간의 개념

사용자들은 컴퓨터 시스템에 "사용자 편이", "고성능", "신뢰성" 등에 대해 기대한다. 

### 13.1 초기 시스템

{% include image.html alt="운영체제: 초기" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/early-operating-system.png" %}

초기 컴퓨터에서는 물리 메모리는 위 의 그림과 같이 생겼다.  
물리 메모리 하나에 실행 중인 프로그램이 존재하고 운영체제는 나머지 메모리를 사용했다.  

### 13.2 멀티프로그래밍과 시분할

{% include image.html alt="세 개의 프로세스: 공유 메모리" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/process-share-memory.png" %}

**멀티프로그래밍(multi-programming)** 이 나오면서 운영체제는 여러 프로세스를 전환하며 실행했다.  
더 많이 사용하기 위해 **시분할(time-sharing)** 이 시작되면서 현재 실행 중인 작업의 응답을 받기 위해 **대화식 이용(interactivity)** 의 개념이 중요하게 되었다.

시분할을 구현하기 위해 하나의 프로세스를 짧게 수행하게 된다.  
프로세스 중단 시점의 모든 상태를 물리 메모리를 포함한 디스크 장치에 저장하고 다른 프로세스를 탑재한다.   
하지만 이런 방식은 메모리가 커질수록 특히 더 느리게 동작하기 때문에 문제가 있다. 

또한, 프로그램이 메모리에 동시에 존재하기 위해서는 다른 프로세스의 데이터를 읽거나 갱신하지 않도록 **보호(protection)** 문제도 중요하다.  


### 13.3 주소 공간

{% include image.html alt="주소 공간 예" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/address-space.png" %}

메모리를 보호하기 위해 만든 개념이 **주소 공간(address space)** 이다.  
주소 공간은 코드(명령어), 스택(현재 위치, 지역 변수, 함수 인자 등), 힙(동적으로 할당) 같은 프로그램의 모든 메모리 상태를 가지고 있다.  

코드는 정적이기 때문에 메모리에 저장하기 쉽다.
스택과 힙은 모두 확장할 수 있어야 하기 때문에 양 끝단에 배치해야 한다. 
하지만 이는 관례일 뿐 여러 쓰레드가 공존할 때 이렇게 나누면 동작하지 않는다.  

주소 공간은 운영체제가 실행중인 프로그램에게 제공하는 **개념(abstraction)** 인 것이다.  
프로그램은 실제로 물리주소 0~16KB 가 아닌 임의의 물리 주소에 탑재된다.
이를 **메모리 가상화(virtualizing memory)** 한다고 한다.  

결국 실행중인 프로그램은 특정 주소 메모리에 탑재되고 매우 큰 주소 공간을 가지고 있다고 생각한다.  

### 13.4 목표

가상 메모리 시스템의 목표는 다음과 같다. 

- **투명성(transparency)**
  - 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하고 물리 메모리를 소유한 것처럼 구현

- **효율성(efficiency)**
  - 시간적 측면: 너무 느리게 실행되서는 안됨
  - 공간적 측면: 가상화를 위한 구조를 위해 많은 메모리를 사용하면 안됨

- **보호(protection)**
  - 다른 프로세스가 메모리에 접근하지 못하도록 보호 (격리, isolate)

<br/>

## 14장. 막간: 메모리관리 API

Unix 의 메모리 관리 인터페이스에 대해 알아본다.

### 14.1 메모리 공간의 종류

프로그램이 실행되면 두 가지 유형의 메모리 공간이 할당

- 스택(stack) 메모리
  - 할당과 반환은 컴파일러에 의해 암묵적으로 수행 (자동 메모리라고도 불림)

```c 
void func() {
    int x; // 스택에 int 형 선언
    ...    // 리턴하면 컴파일러가 메모리 반환
}
```

- 힙 메모리(heap)
  - 할당과 반환이 프로그래머에 의해 처리
  - 많은 버그의 원인이 될 수 있음

```c 
void func() {
    int *x = (int *) malloc(sizeof(int));   // 스택과 힙 모두 할당
}
```


### 14.2 malloc() 함수

```c 
#include <stdlib.h>
...
void *malloc(size_t size);
```

힙에 요청할 공간의 바이트 크기를 넘겨주면 할당된 공간에 대한 포인터 반환 (실패하면 NULL)  

```c 
double *d = (double *) malloc(sizeof(double));
```

이 호출에서는 정확한 크기의 공간을 요청하기 위해 `sizeof` 연산자 사용  
인자의 크기는 컴파일 시간에 결정 (함수 호출이 아님)

### 14.3 free() 함수

```c 
int *x = malloc(10 * sizeof(int));
...
free(x);
```

더 이상 사용되지 않는 힙 메모리를 해제하기 위해 `free()` 호출  
`malloc()` 에서 반환된 포인터 받음

### 14.4 흔한 오류

올바른 메모리 관리를 위해 많은 새로운 언어들이 쓰레기 수집기를 통해 자동 메모리 관리(automatic memory management)를 지원한다.

#### 메모리 할당 잊어버리기

다음과 같이 메모리 할당을 하지 않으면 **세그멘테이션 폴트(segmentation fault)** 가 발생할 가능성이 높다.

```c 
char *src = "hello";
char *dst;
strcpy(dst, src);
```

메모리 할당을 하기 위해서 다음과 같이 코드를 작성해야 한다.

```c 
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src);
```


#### 메모리를 부족하게 할당받기

메모리를 부족하게 할당받는 것을 **버퍼 오버플로우(buffer overflow)** 라고 한다.  
이러한 오버플로우가 유해할 수 있고 많은 시스템에서 보안 취약점의 원인이 될 수 있다.  

```c 
char *src = "hello";
char *dst = (char *) malloc(strlen(src));  // 너무 작음
strcpy(dst, src);
```

#### 할당받은 메모리 초기화하지 않기

`malloc()` 하면 할당 받은 데이터 타입에 특정 값을 넣어야 한다.  
초기화하지 않으면 프로그램은 **초기화되지 않은 읽기(uninitialized read)** 로 힙으로부터 알 수 없는 값을 읽을 수 있다.


#### 메모리 해제하지 않기

메모리 해제를 잊었을 때 **메모리 누수(memory leak)** 가 발생된다.  
메모리 청크 사용이 끝나면 반드시 해제해야 한다.  
한 바이트라도 할당받았으면 해제하는 습관이 중요하다.  

#### 메모리 사용이 끝나기 전에 메모리 해제하기

메모리 사용이 끝나기전에 메모리를 해제하는 것은 `dangling pointer` 라고 하며 심각한 실수다.  
이후에 이 포인터를 이용하면 프로그램을 크래시 시키거나 메모리 영역을 덮어쓸 수 있다.  

#### 반복적으로 메모리 해제하기 

메모리를 한번 이상 해제하는 경우를 이중 해제(double free) 라고 한다.  
크래시 같은 다양한 문제를 일으킬 수 있다.

#### free() 잘못 호출하기

`malloc()` 을 호출한 포인터가 아닌 다른 값을 `free()` 에 전달하면 **유효하지 않은 해제(invalid frees)** 가 발생된다.


### 14.5 운영체제의 지원

`malloc()` 과 `free()` 는 시스템콜이 아니라 라이브러리 함수다.  
`malloc` 라이브러리가 가상 주소 공간 안의 공간을 관리하지만 시스템에게 더 많은 메모리를 요구하고 반환하는 시스템 콜을 기반으로 구축된다.  

이러한 시스템 콜 중 하나가 `brk` 시스템 콜로 프로그램의 `break` 위치를 힙의 마지막 위치로 변경하는데 사용된다.  

또한, `mmap()` 함수를 사용하여 `anonymous` 의 메모리 영역을 만들어 메모리를 얻을수도 있다.  
`anonymous` 영역은 특정 파일과 연결되어 있지 않고 스왑 공간(swap space)에 연결된 영역이다.  


### 14.6 기타함수들

- `calloc()`
  - 메모리 할당 영역을 0으로 채워 반환
  - 초기화 하는 것을 잊어버리는 오류 방지
- `realloc()`
  - 할당된 공간에 대해 추가 공간이 필요할 때 유용
  - 이전 영역의 내용을 복사하여 더 큰 새로운 영역을 확보하고 포인터 반환


