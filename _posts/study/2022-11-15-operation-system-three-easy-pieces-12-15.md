---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 12장~15장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 12장부터 15장까지의 내용을 정리한다. 

<!--more-->

## 12장. 메모리 가상화에 관한 대화

- 가상 메모리 관리자의 동작
  - 베이스-바운드
  - TLB 와 멀티 레벨 페이지 테이블 문제 해결 방법
- 사용자 프로그램이 생성하는 모든 주소는 **가상 주소**
  - 사용하기 쉬운 시스템을 제공하기 위함
  - 프로세스에게 대용량 연속된 주소 공간(address space)을 가지고 있다고 시각을 제공
  - 고립(isolation) 과 보호(protection)
    - 다른 프로세스의 메모리를 읽거나 변경할 수 없음


<br/>

## 13장. 주소 공간의 개념

사용자들은 컴퓨터 시스템에 "사용자 편이", "고성능", "신뢰성" 등에 대해 기대한다. 

### 13.1 초기 시스템

{% include image.html alt="운영체제: 초기" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/early-operating-system.png" %}

초기 컴퓨터에서는 물리 메모리는 위 의 그림과 같이 생겼다.  
물리 메모리 하나에 실행 중인 프로그램이 존재하고 운영체제는 나머지 메모리를 사용했다.  

### 13.2 멀티프로그래밍과 시분할

{% include image.html alt="세 개의 프로세스: 공유 메모리" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/process-share-memory.png" %}

**멀티프로그래밍(multi-programming)** 이 나오면서 운영체제는 여러 프로세스를 전환하며 실행했다.  
더 많이 사용하기 위해 **시분할(time-sharing)** 이 시작되면서 현재 실행 중인 작업의 응답을 받기 위해 **대화식 이용(interactivity)** 의 개념이 중요하게 되었다.

시분할을 구현하기 위해 하나의 프로세스를 짧게 수행하게 된다.  
프로세스 중단 시점의 모든 상태를 물리 메모리를 포함한 디스크 장치에 저장하고 다른 프로세스를 탑재한다.   
하지만 이런 방식은 메모리가 커질수록 특히 더 느리게 동작하기 때문에 문제가 있다. 

또한, 프로그램이 메모리에 동시에 존재하기 위해서는 다른 프로세스의 데이터를 읽거나 갱신하지 않도록 **보호(protection)** 문제도 중요하다.  


### 13.3 주소 공간

{% include image.html alt="주소 공간 예" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/address-space.png" %}

메모리를 보호하기 위해 만든 개념이 **주소 공간(address space)** 이다.  
주소 공간은 코드(명령어), 스택(현재 위치, 지역 변수, 함수 인자 등), 힙(동적으로 할당) 같은 프로그램의 모든 메모리 상태를 가지고 있다.  

코드는 정적이기 때문에 메모리에 저장하기 쉽다.
스택과 힙은 모두 확장할 수 있어야 하기 때문에 양 끝단에 배치해야 한다. 
하지만 이는 관례일 뿐 여러 쓰레드가 공존할 때 이렇게 나누면 동작하지 않는다.  

주소 공간은 운영체제가 실행중인 프로그램에게 제공하는 **개념(abstraction)** 인 것이다.  
프로그램은 실제로 물리주소 0~16KB 가 아닌 임의의 물리 주소에 탑재된다.
이를 **메모리 가상화(virtualizing memory)** 한다고 한다.  

결국 실행중인 프로그램은 특정 주소 메모리에 탑재되고 매우 큰 주소 공간을 가지고 있다고 생각한다.  

### 13.4 목표

가상 메모리 시스템의 목표는 다음과 같다. 

- **투명성(transparency)**
  - 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하고 물리 메모리를 소유한 것처럼 구현

- **효율성(efficiency)**
  - 시간적 측면: 너무 느리게 실행되서는 안됨
  - 공간적 측면: 가상화를 위한 구조를 위해 많은 메모리를 사용하면 안됨

- **보호(protection)**
  - 다른 프로세스가 메모리에 접근하지 못하도록 보호 (격리, isolate)





