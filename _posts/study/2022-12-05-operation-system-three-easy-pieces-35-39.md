---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 35장~39장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 영속성에 대해 다룬 35장부터 39장까지의 내용을 정리한다. 

<!--more-->

## 35장. 영속성에 관한 대화

컴퓨터가 멈추고 디스크가 고장나고 전원이 꺼져도 정보를 그대로 유지해야 한다.  

<br/>

## 36장. I/O 장치

**입력/출력 장치(I/O)** 의 개념과 이 장치가 운영체제와 상호 작용하는 방법을 알아본다.

### 36.1 시스템 구조

{% include image.html alt="시스템 구조 모형" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/simple-system-structure.png" %}

CPU 와 주메모리는 메모리 버스로 연결되어 있다.  
몇몇 장치들은 범용 **I/O 버스** 에 연결되어 있는데, 현대 시스템에서는 **PCI** 를 사용한다.
그 아래에는 SCSI, SATA(Serial ATA), USB 와 같은 **주변 장치용 버스** 가 있고 이를 통해 디스크, 마우스, 키보드 같은 장치가 연결된다.  

{% include image.html alt="현대식 시스템 구조" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/modern-system-structure.png" %}

현대식 시스템은 칩셋들과 점대점 연결 방식을 늘리고 있다.

- DMI(Direct Media Interface)
  - CPU가 이 기술로 I/O 칩에 연결
- eSATA(external SATA)
  - 하드 디스크들이 연결
- ATA(AT attachment, 고급 기술 결합)
- SATA(Serial ATA)
- PCIe(Peripheral Component Interconnect Express, 주변 장치 연결 익스프레스)


### 36.2 표준 장치 

가상의 표준 장치를 효율적 활용하기 위한 두 가지 요소가 있다.  

- 하드웨어 인터페이스 (레지스터 상태, 명령, 데이터)
  - 인터페이스를 제공하여 시스템 소프트웨어가 동작을 제어할 수 있도록 해야 함
- 내부 구조(CPU, 메모리, 하드웨어에 특화된 칩)
  - 장치의 기능을 추상화하여 시스템 제공하에 목적에 맞게 동작 해야 함

### 36.3 표준 방식

장치의 인터페이스는 세 개의 레지스터로 구성되어 있다.

- **상태(status)** 레지스터
  - 장치의 현재 상태를 읽음
- **명령(command)** 레지스터
  - 장치가 데이터를 보내거나 받거나 할 때 사용
- **데이터(data)** 레지스터
  - 장치에 데이터를 보내거나 받거나 할 때 사용

장치가 동작을 할 때 다음과 같은 방식을 따른다.  

```c 
While (STATUS == BUSY)
    ; // 장치가 바쁜 상태가 아닐 때까지 대기
데이터를 DATA 레지스터에 쓰기
명령어를 COMMAND 레지스터에 쓰기 (장치가 명령어 실행)
While (STATUS == BUSY)
    ; // 요청을 완료할 때까지 대기        
```

1. 반복적으로 상태 레지스터를 읽어서 명령의 수신 여부 판단 (**polling** 방식, 비효율적)
2. 운영체제가 데이터 레지스터에 데이터 전달 (데이터 전송에 메인 CPU 가 관여하게 되면 **programmed I/O** 라고 함)
3. 운영체제가 명령 레지스터에 명령어 기록
4. 디바이스가 처리 완료되었는지 폴링하면서 대기

### 36.4 인터럽트를 이용한 CPU 오버헤드 개선

폴링 대신 입출력 작업을 요청한 프로세스를 블록시키고 CPU 를 다른 프로세스에게 양도한다.  
장치가 작업을 끝마치고 나면 하드웨어 인터럽트를 발생시키고 
CPU 는 **인터럽트 서비스 루틴(interrupt service routine, ISR)** 또는 **인터럽트 핸들러(interrupt handler)** 를 실행한다.

#### 단점 

- 문맥 교환 비용 또한 비싸기 때문에 폴링이 빠른 장치라면 폴링 방식이 더 좋을 수 있음
  - 장치 속도를 모른다면 짧은 시간동안만 폴링 하다가 인터럽트를 사용하는 **하이브리드 방식** 을 사용하는 것이 좋음
- 인터럽트만 처리하다가 프로세스 요청을 처리할 수 없도록 **무한반복(livelock)** 에 빠질 수 있음
  - 폴링을 사용하면 보다 효율적으로 제어할 수 있음
  - **병합(coalescing)** 기법으로 잠시 기다렸다가 한번만 인터럽트를 발생시키는 방법으로 처리할 수 있음


### 36.5 DMA를 이용한 효율적인 데이터 이동

많은 양의 데이터를 디스크로 전달하기 위해 prodgrammed I/O(PIO) 를 사용하면 CPU 를 이용하기 때문에 비효율적이다.  
**직접 메모리 접근 방식(Direct Memory Access, DMA)** 을 사용하면 CPU 간섭없이 메모리와 장치 간에 전송할 수 있다.  

#### 동작 과정

1. 데이터를 장치로 전송한다고 하면 DMA 엔진에 메모리상의 데이터 위치와 전송할 데이터의 크기와 대상 장치를 프로그램
2. 이 시점에 운영체제는 다른 작업을 수행
3. DMA 동작이 끝나면 DMA 컨트롤러가 인터럽트를 발생시켜 완료되었다고 알림


### 36.6 디바이스와 상호작용하는 방법

장치와 운영체제가 정보를 교환하는 기본적인 방법 두 가지를 알아본다.  

- **I/O** 명령을 명시적으로 사용
  - 운영체제가 특정 장치 레지스터에 데이터 전송할 수 있음
  - 대부분이 **특권(privileged)** 명령어 운영체제가 장치를 제어
- **맵 입출력(memory mapped I/O)**
  - 장치의 레지스터들이 메모리 상에 존재하는 것처럼 만듦
  - load/store 명령어가 주 메모리 대신 장치로 연결되도록 함

### 36.7 운영체제에 연결하기: 디바이스 드라이버

서로 다른 인터페이스를 가진 장치들과 운영체제를 연결시키는 방법으로 **추상화(abstraction)** 가 있다.    

- **디바이스 드라이버(device driver)**
  - 장치의 동작 방식을 알고 있는 운영체제 최하위 계층의 일부 소프트웨어
  - 자세한 상호작용은 내부에 있음
  - 어떤 장치에도 필요하기 때문에 커널 코드의 대부분을 차지함
  - 특정 장치의 특별한 기능을 사용할 수 없을 수 있음
