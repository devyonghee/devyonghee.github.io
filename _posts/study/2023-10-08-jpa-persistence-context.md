---
title: '[JPA] JPA 영속성 콘텍스트'
tags: [study, book, jpa, persistence]
categories: study
---

ORM 라이브러리를 사용하다보면 영속성에 대한 이해가 필요하다.
JPA 에서 영속성 컨텍스트에 대한 특징과 어떻게 관리되는지 알아본다.

<!--more-->

구현과 관련된 부분은 하이네이트 기준이다.  

<br/>

## 엔티티 매니저

- 엔티티 매니저는 엔티티 매니저 팩토리(entity manager factory) 에 의해 생성됨
  - 엔티티 매니저 팩토리는 애플리케이션 전체에서 한 번만 생성되고 공유되어 사용되어야 함
  - 엔티티 매니저 팩토리를 생성할 때 커넥션 풀도 만들게 됨
- 엔티티 매니저는 동시성 문제가 발생될 수 있으므로 스레드 간에 절대 공유하면 안됨
  - 새로운 엔티티 매니저는 `EntityManagerHoler` 객체에 주입되어 `ThreadLocal` 에서 관리
- 보통 트랜잭션을 시작할 때 커넥션 획득

## 영속성 컨텍스트

- 엔티티 매니저에서 엔티티를 보관하고 관리하는 환경
- 논리적인 개념에 가까우며 엔티티 매니저 생성할 때 하나 만들어짐
  - 트랜잭션이 같으면 다른 엔티티 매니저에서도 같은 영속성 컨텍스트 사용
  - 같은 엔티티 매니저여도 트랜잭션이 다르면 다른 영속성 컨텍스트 사용
  - 스프링 컨테이너에서는 스레드마다 다른 트랜잭션 할당
- 영속성 컨텍스트는 엔티티를 식별자 값(`@Id`) 기준으로 구분
  - 영속 상태는 반드시 식별자 값이 있어야 함
- 영속성 컨텍스트에 있는 엔티티는 트랜잭션을 커밋(`flush`)하는 순간 데이터베이스에 반영
- 장점
  - 1차 캐시
    - 영속성 컨텍스트 내부에 저장된 캐시
    - 식별자 값(`@Id`)이 키인 `Map
    - 캐시에 찾는 엔티티가 없다면 데이터베이스에서 조회
  - 동일성 보장
    - 캐시에 있는 엔티티를 공유하기 때문에 동일한 인스턴스를 반환하게 됨
  - 트랜잭션을 지원하는 쓰기 지연
    - 커밋하면 영속성 컨텍스트에 플러시하면서 모아둔 쿼리를 한 번에 보내게 됨
    - 성능 최적화 가능
  - 변경 감지
    - 최초의 상태 복사하여 스냅샷을 남김
    - 엔티티의 변경사항을 데이터베이스에 자동으로 반영
    - 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용
    - 기본적으로 모든 필드에 대해 업데이트 수행
      - 애플리케이션에서 수정 쿼리 미리 생성하고 재사용 가능
      - 데이터베이스에서 파싱된 쿼리 재사용 가능
      - 필드가 너무 많거나 내용이 너무 크면 수정된 데이터만 동적 변경 가능(`@DynamicUpdate`)
  - 지연 로딩


## 엔티티의 생명주기

- 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 저장되지 않은 순수 객체 상태
- 영속(managed): 영속성 컨텍스트에 저장된 상태
  - 영속성 컨텍스트가 관리하는 엔티티의 상태
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 관리하지 않는 상태(`em.detach(entity)`)
- 삭제(removed): 삭제된 상태
  - 영속성 컨텍스트와 데이터베이스에서 삭제 상태(`em.remove(entity)`)


## OSIV(Open Session In View)

영속성 컨텍스트를 뷰까지 열어두는 기능 (뷰에서도 지연 로딩 가능하도록 함)

- 클라이언트 요청이 들어올 때 영속성 컨텍스트를 생성하여 요청이 끝날 때까지 유지
- 영속성 컨텍스트를 여러 트랜잭션에서 공유될 수 있음
- 엔티티 수정은 트랜잭션이 있는 계층에서만 동작
  - 지연 로딩을 포함한 조회만 가능
  - 프레젠테이션 계층에서 엔티티를 수정하고 트랜잭션이 있는 로직을 실행하면 데이터베이스에 반영되는 문제가 있음
  - 비즈니스 로직을 먼저 수행하고 프레젠테이션 계층에서 수정하면 변경되지 않음

    
