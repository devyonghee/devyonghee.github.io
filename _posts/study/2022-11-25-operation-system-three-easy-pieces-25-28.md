---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 25장~28장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 병행성에 대해 다룬 25장부터 28장까지의 내용을 정리한다. 

<!--more-->

## 25장. 병행성에 관한 대화

멀티쓰레드 프로그램에서 각 쓰레드는 독립된 객체로 프로그램을 대신하여 일을 한다.  
쓰레드들은 동시에 메모리에 접근하게 되는데 이를 조정하지 않으면 예상치 못한 문제가 발생될 수 있다. 

### 운영체제와 병행성

- **락(lock)** 과 **컨디션 변수(conditional variable)** 같은 기본 동작으로 멀티 쓰레드 프로그램을 지원해야 함  
- 운영체제 역시 최초의 동시 프로그램 (메모리 영역도 조심스럽게 접근 필요)

<br/>

## 26장. 병행성: 개요

멀티 쓰레드 프로그램은 하나 이상의 실행 지점을 가지고 있다.  
**쓰레드(Thread)** 들은 주소 공간을 공유하기 때문에 동일한 값에 접근할 수 있다.  

쓰레드의 상태는 프로세스와 유사하며, 명령어를 가져오는 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가지고 있다.   
두 쓰레드가 하나의 프로세서에서 실행중이라면 **문맥 교환(context switch)** 를 통해 실행중인 쓰레드와 교체된다.  
여기서 교환되는 상태를 **프로세스 제어 블럭(process control block, PCB)** 에 저장하듯이 **쓰레드 제어 블럭(thread control block, TCB)** 을 사용한다.  
프로세스와 달리 쓰레드간의 문맥 교환은 주소 공간(페이지 테이블)을 그대로 사용한다.  

{% include image.html alt="단일 쓰레드와 멀티 쓰레드의 주소 공간" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/single-multi-thread-address-space.png" %}

멀티 쓰레드 프로세스의 경우, 주소 공간에 쓰레드마다 스택이 할당되어 있다.  
로컬 변수, 매개변수, 리턴 값, 그외 스택에 넣는 것들은 해당 쓰레드의 스택인 **쓰레드-로컬 저장소(thread-local storage)** 에 저장된다.  


### 26.1 왜 쓰레드를 사용하는가?

쓰레드를 사용해야 하는 이유 2가지

- **병렬 처리(parallelism)**
  - 단일 쓰레드(single-threaded) 프로그램을 멀티프로세서 프로그램으로 변환하는 작업을 **병렬화(parallelization)** 라고 함
  - 작업의 일부분을 나눠서 실행하여 실행 속도를 높일 수 있음
- I/O 로 인해 프로그램 실행이 멈추지 않도록 함
  - 하나의 쓰레드가 대기하는 동안 다른 쓰레드로 전환 가능
  - 쓰레딩은 하나의 프로그램 안에서 다른 작업이 중첩(overlap) 될 수 있게 함 (멀티 프로그래밍과 비슷)


### 26.2 예제: 쓰레드 생성

```c
void *mythread(void *arg) {
  printf("%s\n", (char *) arg);
  return NULL;
} 

int
main(int argc, char *argv[]) {
    pthread_t p1, p2;
    int rc;
    printf("main: begin\n");
    Pthread_create(&p1, NULL, mythread, "A");
    Pthread_create(&p2, NULL, mythread, "B");
    // 대기 중인 쓰레드 병합
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);
    printf("main: end\n");
    return 0;
}
```

{% include image.html alt="쓰레드 실행 추적" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/thread-creation-code-execute.png" %}

실행 가능 순서는 유일하지 않다.  
다음에 실행될 쓰레드는 **OS 스케줄러(scheduler)** 에 의해 결정된다.  
하지만 어떤 쓰레드가 언제 실행되는지 알기 어렵기 때문에 병행성이 더 어려워진다.  


### 26.3 훨씬 더 어려운 이유: 데이터 공유

각 쓰레드에서 공유 변수에 접근하여 수정하게 된다면 예상치 못한 결과가 나온다.  
예를 들어, 두 쓰레드에서 공유 변수에 +1 하는 과정을 10000번을 반복한다면 20000 이 나오지 않는 문제가 발생한다.  

### 26.4 문제의 핵심: 제어 없는 스케줄링

위 문제처럼 명령어의 실행 순서에 따라 결과가 달라지는 상황을 **경쟁 조건(race condition)** 또는 **데이터 경쟁(data race)** 이라고 한다.  
문맥 교환이 적절하게 실행되지 않으면 잘못된 결과가 나온다.  
이처럼 실행할 때마다 결과가 다른 경우를 **비결정적(indeterminate)** 인 결과라고 한다.

공유 변수를 접근하고 하나 이상의 쓰레드에서 동시에 실행되면 안 되는 코드를 **임계 영역(critical section)** 이라고 한다.    
이러한 코드에서는 **상호 배제(mutual exclusion)** 속성이 필요하다.  
한 쓰레드에서 임계 영역 내의 코드를 실행 중일 때 다른 쓰레드가 실행할 수 없도록 보장하는 것이다.  

### 26.5 원자성에 대한 바람

임계 영역 문제 해결 방법 중 하나로 원자적으로 실행되는 명령어 한개를 수행하여, 수행 도중에 인터럽트 발생 가능성을 차단하는 것이다.
따라서 하드웨어에 **동기화 함수(synchronization primitives)** 구현에 필요한 명령어를 요청한다.    
하드웨어 지원을 사용하고 운영체제의 도움을 받아 하나의 쓰레드만 임계 영역에서 실행해야 한다.  


### 26.6 또 다른 문제: 상대 기다리기

하나의 쓰레드가 다른 쓰레드의 동작이 끝날 때까지 대기해야 하는 상황도 발생한다.  
디스크 I/O 로 요청으로 인해 잠든 경우, I/O 완료 후 쓰레드가 일어나 이후의 작업을 진행하도록 해야 한다.  

### 26.7 정리: 왜 운영체제에서?

운영체제는 최초의 병행 프로그램으로 운영체제 내에서 사용하기 위해 이러한 기법들이 생성되었다.  
멀티 쓰레드 프로그램이 등장하면서 응용 프로그래머들도 비슷한 문제를 고민하게 되었다.  


### 주요 용어

- **임계 영역(critical section)**
  - 변수나 자료 구조와 같은 공유 자원을 접하는 코드의 일부분
- **경쟁 조건(race condition)** 혹은 **데이터 경쟁(data race)**
  - 멀티 쓰레드가 동시에 임계 영역을 실행하려고 할 때 발생
  - 공유 자료 구조에 대해 동시에 접근하면 예상치 못한 결과 발생
- **비결정적(indeterminate)**
  - 프로그램의 실행 결과가 실행할 때마다 다름
- **상호 배제(mutual exclusion)**
  - 임계 영역에 대해 한 번에 하나의 쓰레드만 접근할 수 있도록 보장
  - 경쟁을 피할 수 있고 실행결과를 결정론적으로 얻을 수 있음

