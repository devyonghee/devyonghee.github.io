---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 영속성에 대해 다룬 35장부터 40장까지의 내용을 정리한다. 

<!--more-->

## 35장. 영속성에 관한 대화

컴퓨터가 멈추고 디스크가 고장나고 전원이 꺼져도 정보를 그대로 유지해야 한다.  

<br/>

## 36장. I/O 장치

**입력/출력 장치(I/O)** 의 개념과 이 장치가 운영체제와 상호 작용하는 방법을 알아본다.

### 36.1 시스템 구조

{% include image.html alt="시스템 구조 모형" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/simple-system-structure.png" %}

CPU 와 주메모리는 메모리 버스로 연결되어 있다.  
몇몇 장치들은 범용 **I/O 버스** 에 연결되어 있는데, 현대 시스템에서는 **PCI** 를 사용한다.
그 아래에는 SCSI, SATA(Serial ATA), USB 와 같은 **주변 장치용 버스** 가 있고 이를 통해 디스크, 마우스, 키보드 같은 장치가 연결된다.  

{% include image.html alt="현대식 시스템 구조" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/modern-system-structure.png" %}

현대식 시스템은 칩셋들과 점대점 연결 방식을 늘리고 있다.

- DMI(Direct Media Interface)
  - CPU가 이 기술로 I/O 칩에 연결
- eSATA(external SATA)
  - 하드 디스크들이 연결
- ATA(AT attachment, 고급 기술 결합)
- SATA(Serial ATA)
- PCIe(Peripheral Component Interconnect Express, 주변 장치 연결 익스프레스)


### 36.2 표준 장치 

가상의 표준 장치를 효율적 활용하기 위한 두 가지 요소가 있다.  

- 하드웨어 인터페이스 (레지스터 상태, 명령, 데이터)
  - 인터페이스를 제공하여 시스템 소프트웨어가 동작을 제어할 수 있도록 해야 함
- 내부 구조(CPU, 메모리, 하드웨어에 특화된 칩)
  - 장치의 기능을 추상화하여 시스템 제공하에 목적에 맞게 동작 해야 함

### 36.3 표준 방식

장치의 인터페이스는 세 개의 레지스터로 구성되어 있다.

- **상태(status)** 레지스터
  - 장치의 현재 상태를 읽음
- **명령(command)** 레지스터
  - 장치가 데이터를 보내거나 받거나 할 때 사용
- **데이터(data)** 레지스터
  - 장치에 데이터를 보내거나 받거나 할 때 사용

장치가 동작을 할 때 다음과 같은 방식을 따른다.  

```c 
While (STATUS == BUSY)
    ; // 장치가 바쁜 상태가 아닐 때까지 대기
데이터를 DATA 레지스터에 쓰기
명령어를 COMMAND 레지스터에 쓰기 (장치가 명령어 실행)
While (STATUS == BUSY)
    ; // 요청을 완료할 때까지 대기        
```

1. 반복적으로 상태 레지스터를 읽어서 명령의 수신 여부 판단 (**polling** 방식, 비효율적)
2. 운영체제가 데이터 레지스터에 데이터 전달 (데이터 전송에 메인 CPU 가 관여하게 되면 **programmed I/O** 라고 함)
3. 운영체제가 명령 레지스터에 명령어 기록
4. 디바이스가 처리 완료되었는지 폴링하면서 대기

### 36.4 인터럽트를 이용한 CPU 오버헤드 개선

폴링 대신 입출력 작업을 요청한 프로세스를 블록시키고 CPU 를 다른 프로세스에게 양도한다.  
장치가 작업을 끝마치고 나면 하드웨어 인터럽트를 발생시키고 
CPU 는 **인터럽트 서비스 루틴(interrupt service routine, ISR)** 또는 **인터럽트 핸들러(interrupt handler)** 를 실행한다.

#### 단점 

- 문맥 교환 비용 또한 비싸기 때문에 폴링이 빠른 장치라면 폴링 방식이 더 좋을 수 있음
  - 장치 속도를 모른다면 짧은 시간동안만 폴링 하다가 인터럽트를 사용하는 **하이브리드 방식** 을 사용하는 것이 좋음
- 인터럽트만 처리하다가 프로세스 요청을 처리할 수 없도록 **무한반복(livelock)** 에 빠질 수 있음
  - 폴링을 사용하면 보다 효율적으로 제어할 수 있음
  - **병합(coalescing)** 기법으로 잠시 기다렸다가 한번만 인터럽트를 발생시키는 방법으로 처리할 수 있음


### 36.5 DMA를 이용한 효율적인 데이터 이동

많은 양의 데이터를 디스크로 전달하기 위해 prodgrammed I/O(PIO) 를 사용하면 CPU 를 이용하기 때문에 비효율적이다.  
**직접 메모리 접근 방식(Direct Memory Access, DMA)** 을 사용하면 CPU 간섭없이 메모리와 장치 간에 전송할 수 있다.  

#### 동작 과정

1. 데이터를 장치로 전송한다고 하면 DMA 엔진에 메모리상의 데이터 위치와 전송할 데이터의 크기와 대상 장치를 프로그램
2. 이 시점에 운영체제는 다른 작업을 수행
3. DMA 동작이 끝나면 DMA 컨트롤러가 인터럽트를 발생시켜 완료되었다고 알림


### 36.6 디바이스와 상호작용하는 방법

장치와 운영체제가 정보를 교환하는 기본적인 방법 두 가지를 알아본다.  

- **I/O** 명령을 명시적으로 사용
  - 운영체제가 특정 장치 레지스터에 데이터 전송할 수 있음
  - 대부분이 **특권(privileged)** 명령어 운영체제가 장치를 제어
- **맵 입출력(memory mapped I/O)**
  - 장치의 레지스터들이 메모리 상에 존재하는 것처럼 만듦
  - load/store 명령어가 주 메모리 대신 장치로 연결되도록 함

### 36.7 운영체제에 연결하기: 디바이스 드라이버

서로 다른 인터페이스를 가진 장치들과 운영체제를 연결시키는 방법으로 **추상화(abstraction)** 가 있다.    

- **디바이스 드라이버(device driver)**
  - 장치의 동작 방식을 알고 있는 운영체제 최하위 계층의 일부 소프트웨어
  - 자세한 상호작용은 내부에 있음
  - 어떤 장치에도 필요하기 때문에 커널 코드의 대부분을 차지함
  - 특정 장치의 특별한 기능을 사용할 수 없을 수 있음


<br/>

## 37장. 하드 디스크 드라이브

시스템의 영구적인 데이터 저장소로 사용되는 하드 디스크 드라이브에 대해 알아본다.

### 37.1 인터페이스

드라이브는 읽고 쓸 수 있는 많은 수의 섹터(512byte 블럭)들로 이루어져있다.  
그래서 디스크를 섹터들의 배열로 볼 수 있으며 드라이브의 **주소 공간**이 된다.

많은 파일 시스템들은 한번에 4KB 를 읽거나 쓸 수 있지만,
드라이브는 512byte 쓰기만 **원자성** 을 보장하기 때문에 일부만 작성될 수 있다. (**찢어 쓰기(torn write)**)

### 37.2 기본 구조

- **플래터(platter)**
  - 원형의 딱딱한 표면
  - 자기적 성질을 변형하여 데이터 지속
  - 디스크는 하나 또는 여러 개의 플래터를 갖고 있으며 각각은 2개의 표면(surface) 를 가짐
- **회전축(spindle)**
  - 플래터들을 고정
  - 모터와 연결되어 있어서 플래터를 회전
  - **분당 회전수(rotation per minute, RPM)** 로 측정 되며 보통 7,200 ~ 15,000RPM
- **트랙(track)**
  - 표면에 동심원을 따라 섹터들 위에 데이터가 부호화되는데 이 동심원 하나를 트랙이라고 함
  - 표면에 트랙들이촘촘하게 붙어 있음
- **디스크 헤드(disk head)**
  - 디스크의 자기적 패턴을 감지하거나 변형을 유도하는 장치
- **디스크 암(disk arm)**
  - 디스크 헤드를 트랙 위로 움직이는 장치

### 37.3 간단한 디스크 드라이브

{% include image.html alt="트랙 하나와 헤드" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/one-track-disk.png" %}

이 트랙에는 12개의 섹터가 있고 각 섹터는 512 byte 크기를 갖고 있다.  
주소 영역은 0 부터 11까지(0 ~ n-1)로 이루어져 있다.

#### 단일 트랙 지연 시간: 회전 지연

**회전형 지연(rotational delay)** 또는 **회전 지연(rotation delay)** 은 디스크 헤드 아래에 원하는 섹터가 위치할 때까지 기다리는 것을 의미한다.

#### 멀티 트랙: 탐색 시간

{% include image.html alt="탐색을 포함한 트랙과 헤드" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/disk-track-seek.png" %}

**탐색(seek)** 은 읽기 요청을 처리하기 위해 드라이브를 디스크 암을 올바른 트랙 위에 위치시키는 과정니다.
탐색은 여러 단계로 이루어져 있다.

1. 가속 단계: 디스크의 암이 움직이기 시작
2. 활주 단계: 디스크 암이 최고 속도로 움직이는 단계
3. 감속 단계: 디스크 암의 속도가 줄어드는 단계
4. 안정화 단계: 정확한 트랙 위에 위치하는 단계 (**안정화 시간(settling time)** 이 중요, 보통 0.5 ~ 2msec)

#### 그 외의 세부사항

{% include image.html alt="트랙 스큐" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/disk-track-skew.png" %}

- **트랙 비틀림(track skew)**
  - 트랙의 경계를 지나 순차적으로 존재하는 섹터들을 읽을 수 있는 기술
  - 트랙으로 넘어갈 때 읽어야 할 블럭을 놓치지 않고 읽을 수 있음

- **멀티 구역(multi-zoned)**
  - 디스크 드라이브는 바깥 측 트랙들이 안쪽 트랙들보다 많은 섹터들이 있는 트랙
  - 여러 구역으로 나뉘어 있으며 한 구역은 연속적으로 존재하는 트랙들의 집합
  - 각 구역 내의 트랙은 같은 수의 섹터들을 포함하고 있음

- **캐시(cache)** 또는 **트랙 버퍼(track buffer)**
  - 일반적으로 8 또는 16MB 정도 크기의 메모리
  - 드라이브가 디스크에서 읽거나 쓴 데이터를 보관하는 데 사용

- 쓰기 요청의 완료 보고
  - write-back 캐싱(즉시 보고(immediate reporting)): 메모리에 데이터가 기록된 시점에 쓰기가 완료되었다고 보고
    - 빠르게 보일 수 있지만 위험할 수 있음
  - write-through: 디스크에 실제로 기록된 시점에 쓰기가 완료되었다고 보고


### 37.4 I/O 시간 계산

I/O 시간을 나타내는 식

T<sub>I/O</sub> = T<sub>seek</sub> + T<sub>rotation</sub> + T<sub>transfer</sub>


I/O 속도(rate, R<sub>I/O</sub>)를 나타내는 식

R<sub>I/O</sub> = Size<sub>Transfer</sub> / T<sub>I/O</sub>


### 37.5 디스크 스케줄링

운영체제가 디스크에게 I/O 요청을 하면 **디스크 스케줄러**는 다음에 어떤 I/O를 처리할 지 결정한다.  
디스크 스케줄링은 요청 작업이 얼마나 길지 예측이 가능하기 때문에 **SFJ(shotest job first, 짧은 작업 우선)** 원칙을 따르려고 한다.

#### SSTF: 최단 탐색 시간 우선

초기 디스크 스케줄링은 **최단 탐색 시간 우선(shortest seek time first, SSTF)** (또는 **최단 탐색 우선(shortest-seek-first, SSF)** 이라고도 불림) 을 사용했다.  
SSTF 는 트랙을 기준으로 I/O 요청 큐를 정렬하여 가까운 트랙의 요청을 먼저 처리한다.

###### 문제점
- 드라이브의 구조는 호스트 운영체제에게 공개되어 있지 않고 운영체제는 블럭들의 배열로 인식하는 문제
  - 이 문제를 해결하기 위해 운영체제는 SSTF 대신 **가장 가까운 블럭 우선(Nearest-block-first, NBF)** 방식을 사용
- 기아 현상(starvation)
  - 다른 트랙에 있는 요청들이 무시될 수 있음

#### 엘리베이터(SCAN 또는 C-SCAN 이라고 함)

- **SCAN** 알고리즘
  - 트랙의 순서에 따라 디스크를 앞뒤로 가로지르며(스위프(sweep)) 요청을 서비스
  - 가까운 층이 아닌 위, 아래로 이동하는 엘리페이터와 같다하여 엘리페이터 알고리즘
- **F-SCAN** 알고리즘
  - 스위프하는 동안에 큐를 동결
  - 늦게 도착한 요청들의 처리를 지연시켜 요청에 대한 기아 현상을 없앰
- **C-SCAN** 알고리즘 (Circular SCAN)
  - 스위프하는 방향이 양 방향이 아닌, 밖에서 안으로만 스위프

##### 문제점

- SJF 원칙을 지키기 위해 최선을 다하지 않음 (회전 무시)

#### SPTF: 최단 위치 잡기 우선

디스크 회전 비용을 고려하기 위해
**최단 위치 잡기 우선(shortest positioning time first, SPTF)** (또는 **최단 접근 시간 우선(shortest access time first, SATF)**) 을 이용한다.

탐색과 회전에 걸리는 시간이 다르기 때문에 상황에 따라 다음 차례가 달라진다.  
SPTF가 유용하고 성능을 개선할 수 있다.   
하지만 운영체제가 트랙의 경계 또는 디스크 헤드가 어디있는지 알 수 없기 때문에 드라이브 내부에서 실행된다.

#### 다른 스케줄링 쟁점들

- 디스크는 상세한 트랙 배치 정보와 헤드의 위치 정보로 최선의 순서(SPTF)로 정렬
- **I/O 병합(I/O merging)**
  - 디스크로 내려보내는 요청의 개수를 줄여 오버헤드 감소
- **작업 보전(work-conserving)**
  - 디스크가 유휴 상태가 되지 않도록 함
- **작업 비보전(non-work-conserving)**
  - **예측 디스크 스케줄링(anticipatory disk scheduling)** 으로 잠시 기다리는 것이 더 좋을 수 있음
