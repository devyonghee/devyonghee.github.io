---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 35장~40장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 영속성에 대해 다룬 35장부터 40장까지의 내용을 정리한다. 

<!--more-->

## 35장. 영속성에 관한 대화

컴퓨터가 멈추고 디스크가 고장나고 전원이 꺼져도 정보를 그대로 유지해야 한다.  

<br/>

## 36장. I/O 장치

**입력/출력 장치(I/O)** 의 개념과 이 장치가 운영체제와 상호 작용하는 방법을 알아본다.

### 36.1 시스템 구조

{% include image.html alt="시스템 구조 모형" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/simple-system-structure.png" %}

CPU 와 주메모리는 메모리 버스로 연결되어 있다.  
몇몇 장치들은 범용 **I/O 버스** 에 연결되어 있는데, 현대 시스템에서는 **PCI** 를 사용한다.
그 아래에는 SCSI, SATA(Serial ATA), USB 와 같은 **주변 장치용 버스** 가 있고 이를 통해 디스크, 마우스, 키보드 같은 장치가 연결된다.  

{% include image.html alt="현대식 시스템 구조" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/modern-system-structure.png" %}

현대식 시스템은 칩셋들과 점대점 연결 방식을 늘리고 있다.

- DMI(Direct Media Interface)
  - CPU가 이 기술로 I/O 칩에 연결
- eSATA(external SATA)
  - 하드 디스크들이 연결
- ATA(AT attachment, 고급 기술 결합)
- SATA(Serial ATA)
- PCIe(Peripheral Component Interconnect Express, 주변 장치 연결 익스프레스)


### 36.2 표준 장치 

가상의 표준 장치를 효율적 활용하기 위한 두 가지 요소가 있다.  

- 하드웨어 인터페이스 (레지스터 상태, 명령, 데이터)
  - 인터페이스를 제공하여 시스템 소프트웨어가 동작을 제어할 수 있도록 해야 함
- 내부 구조(CPU, 메모리, 하드웨어에 특화된 칩)
  - 장치의 기능을 추상화하여 시스템 제공하에 목적에 맞게 동작 해야 함

### 36.3 표준 방식

장치의 인터페이스는 세 개의 레지스터로 구성되어 있다.

- **상태(status)** 레지스터
  - 장치의 현재 상태를 읽음
- **명령(command)** 레지스터
  - 장치가 데이터를 보내거나 받거나 할 때 사용
- **데이터(data)** 레지스터
  - 장치에 데이터를 보내거나 받거나 할 때 사용

장치가 동작을 할 때 다음과 같은 방식을 따른다.  

```c 
While (STATUS == BUSY)
    ; // 장치가 바쁜 상태가 아닐 때까지 대기
데이터를 DATA 레지스터에 쓰기
명령어를 COMMAND 레지스터에 쓰기 (장치가 명령어 실행)
While (STATUS == BUSY)
    ; // 요청을 완료할 때까지 대기        
```

1. 반복적으로 상태 레지스터를 읽어서 명령의 수신 여부 판단 (**polling** 방식, 비효율적)
2. 운영체제가 데이터 레지스터에 데이터 전달 (데이터 전송에 메인 CPU 가 관여하게 되면 **programmed I/O** 라고 함)
3. 운영체제가 명령 레지스터에 명령어 기록
4. 디바이스가 처리 완료되었는지 폴링하면서 대기

### 36.4 인터럽트를 이용한 CPU 오버헤드 개선

폴링 대신 입출력 작업을 요청한 프로세스를 블록시키고 CPU 를 다른 프로세스에게 양도한다.  
장치가 작업을 끝마치고 나면 하드웨어 인터럽트를 발생시키고 
CPU 는 **인터럽트 서비스 루틴(interrupt service routine, ISR)** 또는 **인터럽트 핸들러(interrupt handler)** 를 실행한다.

#### 단점 

- 문맥 교환 비용 또한 비싸기 때문에 폴링이 빠른 장치라면 폴링 방식이 더 좋을 수 있음
  - 장치 속도를 모른다면 짧은 시간동안만 폴링 하다가 인터럽트를 사용하는 **하이브리드 방식** 을 사용하는 것이 좋음
- 인터럽트만 처리하다가 프로세스 요청을 처리할 수 없도록 **무한반복(livelock)** 에 빠질 수 있음
  - 폴링을 사용하면 보다 효율적으로 제어할 수 있음
  - **병합(coalescing)** 기법으로 잠시 기다렸다가 한번만 인터럽트를 발생시키는 방법으로 처리할 수 있음


### 36.5 DMA를 이용한 효율적인 데이터 이동

많은 양의 데이터를 디스크로 전달하기 위해 prodgrammed I/O(PIO) 를 사용하면 CPU 를 이용하기 때문에 비효율적이다.  
**직접 메모리 접근 방식(Direct Memory Access, DMA)** 을 사용하면 CPU 간섭없이 메모리와 장치 간에 전송할 수 있다.  

#### 동작 과정

1. 데이터를 장치로 전송한다고 하면 DMA 엔진에 메모리상의 데이터 위치와 전송할 데이터의 크기와 대상 장치를 프로그램
2. 이 시점에 운영체제는 다른 작업을 수행
3. DMA 동작이 끝나면 DMA 컨트롤러가 인터럽트를 발생시켜 완료되었다고 알림


### 36.6 디바이스와 상호작용하는 방법

장치와 운영체제가 정보를 교환하는 기본적인 방법 두 가지를 알아본다.  

- **I/O** 명령을 명시적으로 사용
  - 운영체제가 특정 장치 레지스터에 데이터 전송할 수 있음
  - 대부분이 **특권(privileged)** 명령어 운영체제가 장치를 제어
- **맵 입출력(memory mapped I/O)**
  - 장치의 레지스터들이 메모리 상에 존재하는 것처럼 만듦
  - load/store 명령어가 주 메모리 대신 장치로 연결되도록 함

### 36.7 운영체제에 연결하기: 디바이스 드라이버

서로 다른 인터페이스를 가진 장치들과 운영체제를 연결시키는 방법으로 **추상화(abstraction)** 가 있다.    

- **디바이스 드라이버(device driver)**
  - 장치의 동작 방식을 알고 있는 운영체제 최하위 계층의 일부 소프트웨어
  - 자세한 상호작용은 내부에 있음
  - 어떤 장치에도 필요하기 때문에 커널 코드의 대부분을 차지함
  - 특정 장치의 특별한 기능을 사용할 수 없을 수 있음


<br/>

## 37장. 하드 디스크 드라이브

시스템의 영구적인 데이터 저장소로 사용되는 하드 디스크 드라이브에 대해 알아본다.

### 37.1 인터페이스

드라이브는 읽고 쓸 수 있는 많은 수의 섹터(512byte 블럭)들로 이루어져있다.  
그래서 디스크를 섹터들의 배열로 볼 수 있으며 드라이브의 **주소 공간**이 된다.

많은 파일 시스템들은 한번에 4KB 를 읽거나 쓸 수 있지만,
드라이브는 512byte 쓰기만 **원자성** 을 보장하기 때문에 일부만 작성될 수 있다. (**찢어 쓰기(torn write)**)

### 37.2 기본 구조

- **플래터(platter)**
  - 원형의 딱딱한 표면
  - 자기적 성질을 변형하여 데이터 지속
  - 디스크는 하나 또는 여러 개의 플래터를 갖고 있으며 각각은 2개의 표면(surface) 를 가짐
- **회전축(spindle)**
  - 플래터들을 고정
  - 모터와 연결되어 있어서 플래터를 회전
  - **분당 회전수(rotation per minute, RPM)** 로 측정 되며 보통 7,200 ~ 15,000RPM
- **트랙(track)**
  - 표면에 동심원을 따라 섹터들 위에 데이터가 부호화되는데 이 동심원 하나를 트랙이라고 함
  - 표면에 트랙들이촘촘하게 붙어 있음
- **디스크 헤드(disk head)**
  - 디스크의 자기적 패턴을 감지하거나 변형을 유도하는 장치
- **디스크 암(disk arm)**
  - 디스크 헤드를 트랙 위로 움직이는 장치

### 37.3 간단한 디스크 드라이브

{% include image.html alt="트랙 하나와 헤드" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/one-track-disk.png" %}

이 트랙에는 12개의 섹터가 있고 각 섹터는 512 byte 크기를 갖고 있다.  
주소 영역은 0 부터 11까지(0 ~ n-1)로 이루어져 있다.

#### 단일 트랙 지연 시간: 회전 지연

**회전형 지연(rotational delay)** 또는 **회전 지연(rotation delay)** 은 디스크 헤드 아래에 원하는 섹터가 위치할 때까지 기다리는 것을 의미한다.

#### 멀티 트랙: 탐색 시간

{% include image.html alt="탐색을 포함한 트랙과 헤드" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/disk-track-seek.png" %}

**탐색(seek)** 은 읽기 요청을 처리하기 위해 드라이브를 디스크 암을 올바른 트랙 위에 위치시키는 과정니다.
탐색은 여러 단계로 이루어져 있다.

1. 가속 단계: 디스크의 암이 움직이기 시작
2. 활주 단계: 디스크 암이 최고 속도로 움직이는 단계
3. 감속 단계: 디스크 암의 속도가 줄어드는 단계
4. 안정화 단계: 정확한 트랙 위에 위치하는 단계 (**안정화 시간(settling time)** 이 중요, 보통 0.5 ~ 2msec)

#### 그 외의 세부사항

{% include image.html alt="트랙 스큐" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/disk-track-skew.png" %}

- **트랙 비틀림(track skew)**
  - 트랙의 경계를 지나 순차적으로 존재하는 섹터들을 읽을 수 있는 기술
  - 트랙으로 넘어갈 때 읽어야 할 블럭을 놓치지 않고 읽을 수 있음

- **멀티 구역(multi-zoned)**
  - 디스크 드라이브는 바깥 측 트랙들이 안쪽 트랙들보다 많은 섹터들이 있는 트랙
  - 여러 구역으로 나뉘어 있으며 한 구역은 연속적으로 존재하는 트랙들의 집합
  - 각 구역 내의 트랙은 같은 수의 섹터들을 포함하고 있음

- **캐시(cache)** 또는 **트랙 버퍼(track buffer)**
  - 일반적으로 8 또는 16MB 정도 크기의 메모리
  - 드라이브가 디스크에서 읽거나 쓴 데이터를 보관하는 데 사용

- 쓰기 요청의 완료 보고
  - write-back 캐싱(즉시 보고(immediate reporting)): 메모리에 데이터가 기록된 시점에 쓰기가 완료되었다고 보고
    - 빠르게 보일 수 있지만 위험할 수 있음
  - write-through: 디스크에 실제로 기록된 시점에 쓰기가 완료되었다고 보고


### 37.4 I/O 시간 계산

I/O 시간을 나타내는 식

T<sub>I/O</sub> = T<sub>seek</sub> + T<sub>rotation</sub> + T<sub>transfer</sub>


I/O 속도(rate, R<sub>I/O</sub>)를 나타내는 식

R<sub>I/O</sub> = Size<sub>Transfer</sub> / T<sub>I/O</sub>


### 37.5 디스크 스케줄링

운영체제가 디스크에게 I/O 요청을 하면 **디스크 스케줄러**는 다음에 어떤 I/O를 처리할 지 결정한다.  
디스크 스케줄링은 요청 작업이 얼마나 길지 예측이 가능하기 때문에 **SFJ(shotest job first, 짧은 작업 우선)** 원칙을 따르려고 한다.

#### SSTF: 최단 탐색 시간 우선

초기 디스크 스케줄링은 **최단 탐색 시간 우선(shortest seek time first, SSTF)** (또는 **최단 탐색 우선(shortest-seek-first, SSF)** 이라고도 불림) 을 사용했다.  
SSTF 는 트랙을 기준으로 I/O 요청 큐를 정렬하여 가까운 트랙의 요청을 먼저 처리한다.

###### 문제점
- 드라이브의 구조는 호스트 운영체제에게 공개되어 있지 않고 운영체제는 블럭들의 배열로 인식하는 문제
  - 이 문제를 해결하기 위해 운영체제는 SSTF 대신 **가장 가까운 블럭 우선(Nearest-block-first, NBF)** 방식을 사용
- 기아 현상(starvation)
  - 다른 트랙에 있는 요청들이 무시될 수 있음

#### 엘리베이터(SCAN 또는 C-SCAN 이라고 함)

- **SCAN** 알고리즘
  - 트랙의 순서에 따라 디스크를 앞뒤로 가로지르며(스위프(sweep)) 요청을 서비스
  - 가까운 층이 아닌 위, 아래로 이동하는 엘리페이터와 같다하여 엘리페이터 알고리즘
- **F-SCAN** 알고리즘
  - 스위프하는 동안에 큐를 동결
  - 늦게 도착한 요청들의 처리를 지연시켜 요청에 대한 기아 현상을 없앰
- **C-SCAN** 알고리즘 (Circular SCAN)
  - 스위프하는 방향이 양 방향이 아닌, 밖에서 안으로만 스위프

##### 문제점

- SJF 원칙을 지키기 위해 최선을 다하지 않음 (회전 무시)

#### SPTF: 최단 위치 잡기 우선

디스크 회전 비용을 고려하기 위해
**최단 위치 잡기 우선(shortest positioning time first, SPTF)** (또는 **최단 접근 시간 우선(shortest access time first, SATF)**) 을 이용한다.

탐색과 회전에 걸리는 시간이 다르기 때문에 상황에 따라 다음 차례가 달라진다.  
SPTF가 유용하고 성능을 개선할 수 있다.   
하지만 운영체제가 트랙의 경계 또는 디스크 헤드가 어디있는지 알 수 없기 때문에 드라이브 내부에서 실행된다.

#### 다른 스케줄링 쟁점들

- 디스크는 상세한 트랙 배치 정보와 헤드의 위치 정보로 최선의 순서(SPTF)로 정렬
- **I/O 병합(I/O merging)**
  - 디스크로 내려보내는 요청의 개수를 줄여 오버헤드 감소
- **작업 보전(work-conserving)**
  - 디스크가 유휴 상태가 되지 않도록 함
- **작업 비보전(non-work-conserving)**
  - **예측 디스크 스케줄링(anticipatory disk scheduling)** 으로 잠시 기다리는 것이 더 좋을 수 있음


<br/>

## 38장. Redundant Array of Inexpensive Disks (RAID)

**Redundant Array of Inexpensive Disks** 또는 RAID 로 알려진 기술에 대해 알아본다.  
이 기술은 고속이면서 대용량의 디스크 시스템을 만든다.

RAID 는 하나의 디스크처럼 보이지만 내부에는 여러 개의 디스크와 메모리, 시스템을 관리하기 위한 프로세서들로 이루어져있다.  
RAID 하드웨어는 컴퓨터 시스템과 유사하며 디스크의 그룹을 관리하기 위한 시스템이다.

### 장점

RAID 는 장점들을 투명하게 제공하여 확산력(deployability)을 개선 시켰다.  
사용자와 관리자가 소프트웨어 호환성을 걱정하지 않고 사용할 수 있다.

- 성능
  - 디스크 여러 개를 병렬적으로 사용하여 I/O 시간 개선
- 용량
  - 많은 디스크 공간으로 데이터 양이 많음
- 신뢰성
  - **데이터 중복 기술(redundancy)** 으로 디스크 한 개의 고장 감내 가능

### 38.1 인터페이스와 RAID 의 내부

RAID 도 선형적인 블럭들의 배열로 보이며 파일 시스템이 각 블럭을 읽거나 쓸 수 있다.  
파일 시스템이 논리적 I/O 요청을 하면 내부에서 요청 가능한 디스크를 계산하고 물리적으로 I/O 를 발생시킨다. (2개의 복사본을 유지한다면 두 번 물리적 I/O 실행)


### 38.2 결함 모델

RAID 는 특정 종류의 결함을 파악하고 복구하도록 설계되었다.

- **고장시 멈춤(fail-stop)** 결함 모델
  - "정상 작동" 이거나 "멈춤" 상태로 있다고 가정
  - 동작 중인 디스크에 모든 블럭을 읽거나 쓸 수 있음
  - 멈춤 상태의 디스크는 완전히 사용 불가능
  - 디스크가 고장나면 쉽게 파악할 수 있다고 가정한다는 것이 단점

### 38.3 RAID 의 평가 방법

- 용량
  - 클라이언트가 사용할 수 있는 유효 용량 평가
  - 중복 저장이 없다면 N*B
  - 두 개의 복사본을 갖는다면 (N*B)/2
- 신뢰성
  - 몇 개의 디스크 결함을 감내할 수 있는지 평가
- 성능
  - 워크로드에 따라 크게 달라지기 때문에 평가가 어려움

### 38.4 RAID 레벨 0: 스트라이핑

RAID 레벨 0 또는 **스트라이핑(striping)** 방식은 성능과 용량에 대한 훌륭한 상한 기준을 나타낸다.  
이 방식은 블럭들을 여러 디스크에 걸쳐 줄을 긋는 것 처럼 저장한다. (중복 저장을 하지 않음)

디스크 배열의 블럭들을 라운드 로빈 방식으로 디스크를 가로질러 펼친다.  
연속적인 청크에 대해 요청을 받았을 때 병렬성을 가장 잘 활용하도록 설계되었다.  
같은 행에 있는 블럭들은 **스트라이프(stripe)** 라고 한다.

| 디스크0 | 디스크1 | 디스크2 | 디스크3 |
|:----:|:----:|:----:|:----:|
|  0   |  1   |  2   |  3   |
|  4   |  5   |  6   |  7   |
|  8   |  9   |  10  |  11  |
|  12  |  13  |  14  |  15  |


#### 청크 크기

청크 크기는 RAID 성능에 영향을 준다.

- 작은 청크 크기
  - 많은 파일들이 여러 디스크에 걸쳐 스트라이프 되어 병렬성이 증가
  - 여러 디스크에서 찾아 블럭 위치를 찾아야 하므로 찾는데 오래 걸림
- 큰 청크 크기
  - 병렬성이 감소되어 처리 성능을 높이기 위해서는 여러 요청을 병행하게 실행해야 함
  - 위치 찾는 시간 감소

#### RAID-0 분석으로 돌아가서

- 유효 용량
  - B 개의 블럭을 갖는 N개의 디스크라면 N*B 만큼의 유효 용량
- 신뢰성
  - 어느 디스크라도 고장나면 전체 디스크 손실
- 성능
  - 병렬로 사용자 I/O 요청 처리가 가능

#### RAID-0 의 성능

- 단일 요청의 지연시간
  - 한 블럭과 디스크에 대한 요청의 지연 시간은 거의 동일
- RAID 의 정상 상태(steady state) 에서의 처리 성능(throughput)
  - 최대 대역폭 기대 가능
  - 처리성능은 N(디스크 수) * S(디스크 하나의 순차 접근 대역폭) 와 같음

### 38.5 RAID 레벨 1: 미러링

첫 번째 RAID 레벨은 RAID 레벨 1 또는 미러링으로 불린다.  
각 블럭에 대해 하나 이상의 사본을 둬서 디스크 고장에 대처한다.

| 디스크0 | 디스크1 | 디스크2 | 디스크3 |
|:----:|:----:|:----:|:----:|
|  0   |  0   |  1   |  1   |
|  2   |  2   |  3   |  3   |
|  4   |  4   |  5   |  5   |
|  6   |  6   |  7   |  7   |

이 방식은 일반적으로 미러링(RAID-1)을 스트라이핑(RAID-0) 하기 때문에 RAID-10 또는 RAID 1+0 이라고 한다.

#### RAID-1 분석

- 용량
  - 비용이 많이 듦
  - 미러링 레벨이 2라면 최대 사용 가능한 용량의 반만 사용 가능 (N*B)/2
- 신뢰성
  - 디스크 중 고장이 발생해도 감내 가능
- 성능
  - 단일 읽기는 단일 디스크에서 읽는 요청의 지연 시간과 동일
  - 쓰기의 경우 병렬적으로 이루어지지만, 물리적으로 두 개의 쓰기가 연산되어야 하므로 최악의 탐색과 회전 지연시간에 의해 결정
- 처리 성능
  - 순차 쓰기의 경우 N/2 * S 또는 최대 대역폭의 절반의 대역폭
  - 순차 읽기 상황도 N/2 * S 으로 동일

#### 38.6 RAID 레벨 4: 패리티를 이용한 공간 절약

패리티 기반의 접근 방법은 저장 공간을 적게 사용하여 미러링 기반 시스템의 공간 낭비를 극복하고자 한다.  
하지만 성능 저하가 발생될 수 있다.

| 디스크0 | 디스크1 | 디스크2 | 디스크3 | 디스크4  |
|:----:|:----:|:----:|:----:|:-----:|
|  0   |  1   |  2   |  3   |  P0   |
|  4   |  5   |  6   |  7   |  P1   |
|  8   |  9   |  10  |  11  |  P2   |
|  12  |  13  |  14  |  15  |  P3   |

스트라이프마다 중복 정보를 담고 있는 패리티 블럭을 추가한다.
블럭 P1 은 블럭 4,5,6 과 7번으로부터 계산된 중복 정보를 가지고 있다.  
고장난 디스크로부터 데이터를 복구하기 위해서는 스 행의 모든 값을 읽은 후 패리티를 통해 올바른 값을 **다시 계산** 한다.

#### RAID-4 분석

- 용량
  - 디스크 하나를 패리티 정보 저장에 사용하기 때문에 (N-1)*B
- 신뢰성
  - 하나만의 디스크 고장 감내 가능
  - 두 개 이상의 고장은 복원 불가능
- 성능
  - 순차 읽기의 경우 최대 유효한 대역폭은 (N-1)*S MB/s
  - 순차 쓰기의 경우 스프라이프 전부 쓰기가 가장 효율적인 방법이므로 (N-1)*S MB/s

<br>

##### 특정 블럭과 함께 패리티 블럭을 갱신하는 정확하고 효율적인 두 가지 방법

- **가산적 패리티(additive parity)**
  - 스트라이프 내의 다른 모든 블록을 병렬로 읽고 새로운 블럭과 함께 갱신
  - 디스크의 개수에 따라 계산의 양이 다르기 때문에 많은 수의 읽기 연산이 필요해질 수 있음
- **감산적 패리티(subtractive parity)**
  - 갱신 하고자 하는 블록과 패리티 값을 읽음 (동일하면 그대로 유지)
  - 이전의 패리티 비트를 현재 상태의 반대 값으로 뒤집어서 처리
  - P<sub>new</sub> = (C<sub>old</sub> &oplus; C<sub>new</sub>) &oplus; P<sub>old</sub>

##### 문제점

- **small-write 문제**
  - 쓰기가 동시에 요청되면 패리티 디스크는 병목으로 작용
  - 패리티 디스크로 인해 순차적으로 실행되어야 함


### 38.7 RAID 레벨 5: 순환 패리티

RAID-5 는 RAID-4 와 거의 동일하게 동작하지만 패리티 블럭을 **순환(rotate)** 하여 small-write 문제를 해결한다.

| 디스크0 | 디스크1 | 디스크2 | 디스크3 | 디스크4 |
|:----:|:----:|:----:|:----:|:----:|
|  0   |  1   |  2   |  3   |  P0  |
|  5   |  6   |  7   |  P1  |  4   |
|  10  |  11  |  P2  |  8   |  9   |
|  15  |  P3  |  12  |  13  |  14  |
|  P4  |  16  |  17  |  18  |  P9  |


#### RAID-5 분석

많은 부분은 RAID-4와 동일하다.  
모든 디스크를 활용할 수 있기 때문에 랜덤 읽기 성능이 약간 더 좋다.  
RAID-5 성능이 거의 RAID-4와 동일하기 때문에 RAID-5로 완전히 대체되었다.

### 38.5 RAID 비교: 정리

성능만을 원하고 신뢰성을 고려하지 않는다면 스트라이핑  
임의 I/O 성능과 신뢰성을 원한다면 미러링  
순차 I/O 만 사용하거나 용량과 신뢰성이 목적이라면 RAID-5


### 38.9 RAID 와 관련된 다른 흥미로운 주제들

- 디스크가 고장났을 때 **대체용 스페어(hot spare)** 로 고장난 디스크를 대신하는 방법도 있음
- 잠재된 섹터 오류(latent sector error) 또는 블럭 훼손(block corruption) 을 고려한 모델들도 있음
- 소프트웨어 레이어로 RAID(**소프트웨어 RAID**) 구성도 가능.
  - 저렴하지만 일관성-유지 등의 문제 발생


