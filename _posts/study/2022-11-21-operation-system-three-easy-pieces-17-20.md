---
title: '[Study] 운영체제 아주 쉬운 세가지 이야기 17장~20장'
tags: [study, book, operation-system]
categories: study
---

운영체제 아주 쉬운 세가지 이야기 책에 대한 스터디를 진행한다.  
이 글에서는 17장부터 20장까지의 내용을 정리한다. 

<!--more-->

## 17장. 빈 공간 관리

빈 공간 관리가 어려운 경우는 관리하는 고악ㄴ이 가변-크기 빈 공간들의 집합으로 구성되어 있는 경우다. (세그멘테이션)  
이러한 경우에는 외부 단편화가 존재한다.  
이번장에서 이 문제를 해결하고자 한다.  

### 17.1 가정

**외부 단편화** 방지에 중점을 둔다.  
하지만 바대로 **내부 단편화** 문제가 있을 수 있다.  
할당기가 요청한 크기보다 더 큰 메모리 청크를 할당할 경우, 
요청되지 않은 공간에 대해 할당 청크의 내부에서 낭비가 발생하기 때문에 내부 단편화라고 한다.  

### 17.2 저수준 기법들

할당기에서 사용되는 기법에 대해 논의한다.

- **분할(splitting)** 과 **병합(coalescing)**
- 할당된 영역의 크기를 빠르고 상대적으로 쉽게 파악할 수 있는 방법
- 빈 공간과 사용 중인 공간을 추적하기 위해 빈 공간 내에 간단한 리스트 구현

#### 분할과 병합

힙의 빈 공간 리스트에 2개의 원소가 있다고 가정한다.  
하나는 10 바이트의 빈 세그멘트(바이트 0-9) 이고 나머지는 빈 세그멘트(바이트 20-29) 를 표현한다.
10 바이트를 초과하는 모든 요청은 실패할 것이고 작은 요청은 쉽게 충족할 것이다.  

{% include image.html alt="분할" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/space-splitting.png" %}

1바이트만 요청하게 된다면 할당기는 **분할(splitting)** 작업을 수행한다.  
두 번째 원소를 사용해서 충족했다고 가정하면 두 번째 빈 공간은 20이 아닌 21에서 시작하고 길이는 9가 된다.

{% include image.html alt="병합" source_txt='운영체제 아주 쉬운 세가지 이야기' path="/images/study/operating-system/space-coalescing.png" %}

분할데 동방되는 기법은 **병합(coalescing)** 이다.  
힙의 중간에 존재하는 공간을 반환하면 빈 공간들을 병합함으로써 하나의 큰 빈 공간으로 만든다.  


#### 할당된 공간의 크기 파악

메모리 영역의 크기를 파악하여 공간을 빈 공간 리스트에 추가하기 위해 할당기는 **헤더(header)** 블럭에 추가 정보를 저장한다.  
여기서 주의할 점으로 빈 영역의 크기는 헤더 크기 + 사용자에게 할당된 영역의 크기로 된다. (n 바이트 + 헤더 크기의 청크를 찾음)  
헤더는 다음과 같은 정보들을 저장할 수 있다.  

- 할당된 공간의 크기
- 추가의 포인터
  - 해제 속도 향상
- 매직넘버
  - 부가적인 무결성 검사 제공
- 기타 정보

#### 빈 공간 리스트 내장

새로운 노드를 위한 공간을 할당하기 위해 빈 공간 내에 리스트를 구축해야 한다.  
요청하기에 충분한 크기가 있다면 요청 크기 + 헤더 크기를 충족하는 청크와 빈 청크 두 개로 **분할**한다.  

메모리 반환이 일어나면 라이브러리는 빈 공간의 크기를 파악하고 빈 청크를 빈 공간 리스트에 삽입한다.  
그리고 단편화가 발생되지 않도록 리스트를 순회하면서 인접한 청크를 병합한다. 

#### 힙의 확장

대부분의 전통적인 할당기는 적은 크기의 힙으로 시작하여 부족하면 운영체제에게 메모리를 요청한다.  
할당기는 힙을 확장하기 위해 특정 시스템 콜(sbrk)을 호출한다.  

### 17.3 기본적략

할당기는 속도가 빠르고 단편화를 최소로 해야 한다.  
빈 공간 할당을 위한 몇 가지 기본 정책에 대해 알아본다.

#### 최적 적합(Best Fit)

- 빈 공간 리스트를 검색하여 요청한 크기와 같거나 더 큰 메모리 청크를 찾음   
- 후보자 그룹중 가장 작은 크기의 청크 반환 (최적 청크, 최소 적합)  

##### 장점 
- 공간 낭비 최소화
- 빈 공간 리스트를 한번만 순회하면 정확한 블럭을 찾음

##### 단점
- 정교하지 않은 구현은 항상 전체 검색하기 때문에 성능 저하

#### 최악 적합(Worst Fit)

- 최적 적합의 반대
- 가장 큰 빈 청크를 찾아 요청된 크기 만큼만 반환하고 남은 부분은 빈 공간 리스트에 유지

##### 장점
- 최적 적합 방식에서 발생되는 작은 청크 방지

##### 단점
- 항상 빈 공간 리스트 전체를 탐색하는 오버헤드 존재

#### 최초 적합(First Fit)

- 요청보다 큰 첫 번째 블럭을 찾아 반환

##### 장점
- 전체 탐색할 필요가 없어서 속도가 빠름

##### 단점

- 리스트 시작에 작은 객체가 많이 생길 수 있음
  - 빈 공간 리스트 순서 관리 필요 (ex. 주소-기반 정렬, address-based ordering)

#### 다음 적합(Next Fit)

- 리스트 처음부터 탐색이 아닌 마지막으로 찾았던 원소를 가리키는 추가의 포인터 유지
- 전체 탐색을 하지 않기 때문에 최초 적합의 성능과 비슷

##### 장점

- 빈 공간 탐색을 리스트 전체에 균등하게 분산
- 첫 부분에만 단편이 발생하는 것을 방지

### 17.4 다른 접근법

기본적인 접근 방식외에도 메모리 할당을 향상시키 위한 방법에 대해 알아본다. 

#### 개별 리스트

- 별도의 개별리스트(segregated list)
- 자주 요청하는 크기가 있다면 그 크기의 객체를 관리하기 위한 별도의 리스트 유지

##### 장점

- 단편화 가능성 감소
  - 특정 크기의 요청을 위한 메모리 청크를 유지하기 때문
- 요청된 크기의 청크만 존재하여 할당과 해제 요청을 신속히 처리

##### 단점

- 지정된 크기의 메모리 풀과 일반적인 풀에 얼만큼 메모리 할당을 해야할지 결정하는 추가적인 오버헤드 존재
  - **슬랩 할당기(slab allocator)** 는 이문제를 해결 (할당된 캐시공간이 부족하면 추가 슬랩 요청)

#### 버디 할당

- **이진 버디 할당기(binary buddy allocator)** 합병을 간단히 하는 방법 중 하나임
- 빈 메모리는 2의 거듭제곱 크기로 생각하고 메모리 요청이 발생하면 충분한 공간이 발견될 때까지 빈 공간을 2개로 분할

##### 장점

- 블럭이 해제될 때는 다음 블럭이 비어있는지 확인하고 합병하는 식으로 재귀 합병이 발생됨

##### 단점

- 2의 거듭제곱 크기만큼의 블럭만 할당되어 **내부 단편화** 발생될 수 있음


#### 기타 아이디어

위의 방식들은 확장성에 문제가 있음  
빈 공간들의 개수가 늘어갈수록 리스트 검색이 느려질 수 있음
정교한 할당기는 복잡한 자료구조를 사용하여 이 비용을 줄임
- 균형 이진트리(balanced binary tree)
- 스플레이 트리(splay tree)
- 부분 정렬 트리(partially ordered tree)


